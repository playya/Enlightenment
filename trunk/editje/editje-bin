#!/usr/bin/env python
#
# Copyright (C) 2009 Samsung Electronics.
#
# This file is part of Editje.
#
# Editje is free software: you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Editje is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with Editje. If not, see <http://www.gnu.org/licenses/>.

import os
import sys
import re
from optparse import OptionParser

import elementary
import edje

from editje.sysconfig import VERSION
from editje.editje import Editje
import editje.swapfile as swapfile
from editje.popup_win import PopupWindow

vtext = "editje " + str(VERSION)
usage = "usage: %prog [FILE [GROUP]]\n" + \
    "   or: %prog -s [-i IN_PORT] -o OUT_PORT [-o OUT_PORT]... FILE GROUP"

parser = OptionParser(usage=usage, version=vtext)
parser.add_option(
    "-s", "--slave-mode", action="store_true", dest="slave", default=False,
    help="open editor in slave mode")
parser.add_option(
    "-i", "--in-port", dest="in_port", type="int", default=8000,
    help="listening port number, for slave mode (default is 8000)")
parser.add_option(
    "-o", "--out-port", dest="out_ports", type="int", action="append",
    help="writing port number, for slave mode (at least one must be given)")

file_re = re.compile(r"(.*\.ed[cj])$")
group_re = re.compile(r"([a-zA-Z0-9_]+)$")


def file_and_group_parse(file_, grp):
    r = file_re.match(file_)
    if not r:
        #FIXME: do we really want to barf for non ".*\.ed[cj]"
        #file names? Maybe to document it in the usage string,
        #then
        parser.error("wrong format for FILE argument")

    f = r.group(0)

    if not grp:
        return [f, ""]

    r = group_re.match(grp)
    if not r:
        parser.error("wrong format for GROUP argument")

    return [f, r.group(0)]


def open_editje_abort_cb(bt, pop):
    pop.hide()
    pop.delete()


def open_editje_on_swap_error_cb(bt, data):
    pop, option, sf, group, slave_mode = data
    sf.open(option)
    pop.hide()
    open_editje_with_swap_file(sf, group, slave_mode=slave_mode)
    pop.delete()


def open_editje_with_swap_file(sf, group, slave_mode=False, in_port=None,
                               out_ports=None):
    editje = Editje(
        sf, slave_mode=slave_mode, in_port=in_port, out_ports=out_ports)

    if group and group in edje.file_collection_list(sf.workfile):
        editje.group = group
    editje.show()


def open_editje(file_, group, slave_mode=False, in_port=None, out_ports=None):
    try:
        sf = swapfile.SwapFile()
        if not slave_mode and not file_:
            sf.file = ""
            sf.new = True
        else:
            sf.file = os.path.realpath(file_)

        sf.open()
    except swapfile.CacheAlreadyExists, e:
        if slave_mode:
            # sticking to REPLACE action in slave mode
            sf.open(swapfile.REPLACE)
            open_editje_with_swap_file(
                sf, group, slave_mode, in_port, out_ports)
        else:
            pop = PopupWindow()
            pop.title = "Editje - Swap file already exists"

            lb = elementary.Label(pop)
            lb.label_set(
                "Swap file to " + file_ + " already exists.<br>" +
                "Another program may be editing the same file<br>" +
                "or an edition session for this file crashed.")
            pop.pack_end(lb)
            lb.show()

            pop.action_add(
                "Ignore Swap", open_editje_on_swap_error_cb,
                data=(pop, swapfile.REPLACE, sf, group, slave_mode))
            pop.action_add(
                "Recover", open_editje_on_swap_error_cb,
                data=(pop, swapfile.RESTORE, sf, group, slave_mode))
            pop.action_add("Abort", open_editje_abort_cb, data=pop)
            pop.show()
    except swapfile.CompileError, e:
        if slave_mode:
            raise RuntimeError("compiling error")
        else:
            pop = PopupWindow()
            pop.title = "Editje - Compiler Error"

            lb = elementary.Label(pop)
            lb.label_set("Compile Error: " + file_ + "<br>" + e.message)
            pop.pack_end(lb)
            lb.show()

            pop.action_add("OK", open_editje_abort_cb, data=pop)
            pop.show()

            return None
    except Exception, e:
        if slave_mode:
            raise RuntimeError("file error")
        else:
            pop = PopupWindow()
            pop.title = "Editje - File Error"

            lb = elementary.Label(pop)
            lb.label_set("Error with file: " + file_ + "<br>" + str(e))
            pop.pack_end(lb)
            lb.show()

            pop.action_add("OK", open_editje_abort_cb, data=pop)
            pop.show()

            return None
    else:
        open_editje_with_swap_file(sf, group, slave_mode, in_port, out_ports)


if __name__ == "__main__":
    elementary.init()
    elementary.finger_size_set(15)
    elementary.policy_set(elementary.ELM_POLICY_QUIT,
                          elementary.ELM_POLICY_QUIT_LAST_WINDOW_CLOSED)

    options, args = parser.parse_args()
    slave_mode = options.slave
    out_ports = options.out_ports

    args_dict = {}

    if slave_mode:
        if not args:
            parser.error("incorrect number of arguments")

        if len(args) != 2:
            parser.error("incorrect number of arguments")

        if not out_ports:
            parser.error("you must provide at least one writing port")

        file_, group = file_and_group_parse(args[0], args[1])

        args_list = [file_, group, slave_mode]
        args_dict = {"in_port": options.in_port, "out_ports": out_ports}
    elif not args:
        args_list = ["", "main"]
    else:
        if len(args) == 1:
            file_, group = file_and_group_parse(args[0], "")
        elif len(args) == 2:
            file_, group = file_and_group_parse(args[0], args[1])
        else:
            parser.error("incorrect number of arguments")

        args_list = [file_, group]

    try:
        open_editje(*args_list, **args_dict)
    except SystemExit, e:
        elementary.shutdown()
        sys.exit(str(e))

    elementary.run()
    elementary.shutdown()
