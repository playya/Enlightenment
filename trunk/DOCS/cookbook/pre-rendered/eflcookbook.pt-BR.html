<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Livro de Receitas EFL</title><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><meta name="description" content="
   
  "></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="pt-BR"><div class="titlepage"><div><div><h1 class="title"><a name="id2440824"></a>Livro de Receitas EFL</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="surname">Varios</span></h3></div><h4 class="editedby">Editado por</h4><h3 class="editor"><span class="firstname">Ben</span> <span class="othername">'technikolor'</span> <span class="surname">Rockwood</span></h3></div></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="3"><b>Histórico de Revisões</b></th></tr><tr><td align="left">Revisão v0.1</td><td align="left">20 de Fevereiro 2004</td><td align="left">br</td></tr><tr><td align="left" colspan="3">Initial document</td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Resumo</b></p><p>
   
  </p></div></div></div><div></div><hr></div><div class="toc"><p><b>Índice</b></p><dl><dt>1. <a href="#id2440922">Introdução</a></dt><dt>2. <a href="#id2440217">Imlib2</a></dt><dd><dl><dt><a href="#id2461818">Receita: marca d'agua para imagens</a></dt><dt><a href="#id2443504">Receita: Escalonando imagem</a></dt><dt><a href="#id2443491">Receita: Rotação Livre</a></dt><dt><a href="#id2530984">Receita: Rotação de imagen em 90 graus</a></dt><dt><a href="#id2530677">Receita: Reflexão de Imagem</a></dt></dl></dd><dt>3. <a href="#id2530118">EVAS</a></dt><dd><dl><dt><a href="#id2529964">Receita: Usando Ecore_Evas para simplificar a inicialização de canvas X11</a></dt><dt><a href="#id2532834">Receita: Vínculos de teclado, usando eventos de teclado Evas</a></dt><dt><a href="#id2533239">Receita: Introdução aos objetos inteligentes Evas</a></dt></dl></dd><dt>4. <a href="#id2536392">Ecore</a></dt><dd><dl><dt><a href="#id2537815">Receita: Introdução ao Ecore Config</a></dt><dt><a href="#id2537741">Receita: Listeners Ecore Config</a></dt><dt><a href="#id2537681">Receite: Conexão para um servidor com Ecore_Con</a></dt><dt><a href="#id2537553">Receita: Introdução a Ecore Ipc</a></dt><dt><a href="#id2542355">Receita: Temporizadores Ecore</a></dt><dt><a href="#id2540983">Receita: Adicionando eventos Ecore</a></dt></dl></dd><dt>5. <a href="#id2544619">EDB &amp; EET</a></dt><dd><dl><dt><a href="#id2546029">Receita: Criando arquivos EDBs pelo shell</a></dt><dt><a href="#id2545950">Recetta: Introdução ao EDB</a></dt><dt><a href="#id2546428">Receita: Recuperação de chave EDB</a></dt></dl></dd><dt>6. <a href="#id2545702">Esmart</a></dt><dd><dl><dt><a href="#id2545692">Receita: Indrodução ao Esmart Trans</a></dt><dt><a href="#id2547931">Receta: Introdução ao Container Esmart</a></dt></dl></dd><dt>7. <a href="#id2544601">Epeg y Epsilon </a></dt><dd><dl><dt><a href="#id2552644">Receita: Thumbnailing simples com Epeg</a></dt><dt><a href="#id2552563">Receta: Thumbnailing simples com Epsilon</a></dt></dl></dd><dt>8. <a href="#id2551783">Etox</a></dt><dd><dl><dt><a href="#id2551205">Receta: Perspectiva geral de Etox</a></dt></dl></dd><dt>9. <a href="#id2550256">Edje</a></dt><dd><dl><dt><a href="#id2550632">Receita: Um template para construir aplicações Edjes</a></dt><dt><a href="#id2553920">Receita: Criando/Disparando callbacks Edje</a></dt><dt><a href="#id2555448">Receita: Trabalhando com arquivos Edje</a></dt><dd><dl><dt><a href="#id2555005">edje_cc</a></dt><dt><a href="#id2556633">edje_decc</a></dt><dt><a href="#id2556670">edje_recc</a></dt><dt><a href="#id2556827">edje_ls</a></dt><dt><a href="#id2556891">edje</a></dt></dl></dd></dl></dd><dt>10. <a href="#id2552491">Edje EDC e Embryo</a></dt><dd><dl><dt><a href="#id2558153">Receita: Comutador Edje/Embryo</a></dt><dt><a href="#id2559323">Receita: Efeito de dilução Edje no texto </a></dt></dl></dd><dt>11. <a href="#id2559205">EWL</a></dt><dd><dl><dt><a href="#id2559267">Receta: Introducción a EWL</a></dt></dl></dd><dt>12. <a href="#id2564397">Evoak</a></dt><dd><dl><dt><a href="#id2557825">Receita: Cliente Evoak hello </a></dt></dl></dd><dt>13. <a href="#id2565653">Emotion</a></dt><dd><dl><dt><a href="#id2565714">Receita: Player DVD com Emotion</a></dt><dt><a href="#id2564387">Receita: Player de midia expandido com Emotion</a></dt></dl></dd></dl></div><div class="list-of-examples"><p><b>Lista de Exemplos</b></p><dl><dt>2.1. <a href="#id2443103">Programa Marca d'agua com Imlib2</a></dt><dt>2.2. <a href="#id2443528">Escalando imagem</a></dt><dt>2.3. <a href="#id2443458">Rotação livre</a></dt><dt>2.4. <a href="#id2531003">rotação de imagem em 90 graus</a></dt><dt>2.5. <a href="#id2530665">Reflexão de Imagem</a></dt><dt>3.1. <a href="#id2440153">Template Ecore_Evas</a></dt><dt>3.2. <a href="#id2532859">Captura do teclado usando eventos EVAS</a></dt><dt>3.3. <a href="#id2532914">Compilação de keybinds EVAS</a></dt><dt>3.4. <a href="#id2532716">foo.h</a></dt><dt>3.5. <a href="#id2532740">foo.c</a></dt><dt>3.6. <a href="#id2534775">main.c</a></dt><dt>3.7. <a href="#id2534883">Compilação</a></dt><dt>4.1. <a href="#id2537833">Um simples programa Ecore_Config</a></dt><dt>4.2. <a href="#id2537945">Comando para comilação</a></dt><dt>4.3. <a href="#id2537977">Um simples script config.db (build_cfg_db.sh)</a></dt><dt>4.4. <a href="#id2537785">Ecore_Config listener</a></dt><dt>4.5. <a href="#id2538602">Compilação</a></dt><dt>4.6. <a href="#id2537726">Preâmbulo</a></dt><dt>4.7. <a href="#id2539230">Entendendo a parte de inicialização</a></dt><dt>4.8. <a href="#id2539339">capturando os eventos</a></dt><dt>4.9. <a href="#id2539446">conectando</a></dt><dt>4.10. <a href="#id2539588">vai speed racer</a></dt><dt>4.11. <a href="#id2539660">adicionado</a></dt><dt>4.12. <a href="#id2539799">removido</a></dt><dt>4.13. <a href="#id2539887">dado</a></dt><dt>4.14. <a href="#id2539976">compilação</a></dt><dt>4.15. <a href="#id2537584">Cliente Ecore_Ipc: preâmbulo</a></dt><dt>4.16. <a href="#id2537621">Cliente Ecore_Ipc: início do main</a></dt><dt>4.17. <a href="#id2541051">Cliente Ecore_Ipc: main criando o cliente</a></dt><dt>4.18. <a href="#id2541115">Cliente Ecore_Ipc: final de main</a></dt><dt>4.19. <a href="#id2541191">Cliente Ecore_Ipc: sig_exit_cb</a></dt><dt>4.20. <a href="#id2541234">Cliente Ecore_Ipc: os callbacks</a></dt><dt>4.21. <a href="#id2541389">Servidor Ecore_Ipc : preâmbulo</a></dt><dt>4.22. <a href="#id2541425">Servidor Ecore_Ipc: início de main</a></dt><dt>4.23. <a href="#id2541459">Servidor Ecore_Ipc: criando o servidor</a></dt><dt>4.24. <a href="#id2541499">Servidor Ecore_Ipc: final de main</a></dt><dt>4.25. <a href="#id2541523">Servidor Ecore_Ipc: callback sig_exit</a></dt><dt>4.26. <a href="#id2541547">Servidor Ecore_Ipc: os callbacks</a></dt><dt>4.27. <a href="#id2541624">Ecore_Ipc: compilação</a></dt><dt>4.28. <a href="#id2542377">Temporizadores Ecore</a></dt><dt>4.29. <a href="#id2542517">Compilação</a></dt><dt>4.30. <a href="#id2540678">Exemplo de evento Ecore</a></dt><dt>4.31. <a href="#id2542263"></a></dt><dt>5.1. <a href="#id2546065">Arquivo de escript shell de comandos EDB</a></dt><dt>5.2. <a href="#id2545968">Introdução ao EDB</a></dt><dt>5.3. <a href="#id2546643">Compilando</a></dt><dt>5.4. <a href="#id2545709">recuperação de chaves EDB</a></dt><dt>5.5. <a href="#id2545782">Compilação</a></dt><dt>6.1. <a href="#id2548017">Declarações e Inclusões</a></dt><dt>6.2. <a href="#id2548060">main</a></dt><dt>6.3. <a href="#id2548105">callbacks de saída e remoção</a></dt><dt>6.4. <a href="#id2548140">_freshen_trans</a></dt><dt>6.5. <a href="#id2548190">resize_cb</a></dt><dt>6.6. <a href="#id2548242">move_cb</a></dt><dt>6.7. <a href="#id2548264">Iniciar ecore/ecore_evas</a></dt><dt>6.8. <a href="#id2548311">Criando o objeto Esmart_Trans</a></dt><dt>6.9. <a href="#id2548376">makefile sencilla</a></dt><dt>6.10. <a href="#id2547175">Includes e declarações</a></dt><dt>6.11. <a href="#id2549006">main</a></dt><dt>6.12. <a href="#id2549046">Inicialização</a></dt><dt>6.13. <a href="#id2549097">Finalização</a></dt><dt>6.14. <a href="#id2549120">callbacks de janela</a></dt><dt>6.15. <a href="#id2549166">make_gui</a></dt><dt>6.16. <a href="#id2549250">Callbacks Edje</a></dt><dt>6.17. <a href="#id2549282">container_build</a></dt><dt>6.18. <a href="#id2547844">Añadiendo Elementos al Contenedor</a></dt><dt>6.19. <a href="#id2549695">_set_text</a></dt><dt>6.20. <a href="#id2549740">_left_click_cb</a></dt><dt>6.21. <a href="#id2549779">_right_click_cb</a></dt><dt>6.22. <a href="#id2549818">_item_selected</a></dt><dt>6.23. <a href="#id2549858">La Edc</a></dt><dt>6.24. <a href="#id2549954">A Parte Container</a></dt><dt>6.25. <a href="#id2550015">O Grupo Elemento</a></dt><dt>6.26. <a href="#id2550076">Makefile</a></dt><dt>7.1. <a href="#id2551318">Um simples Thumbnail Epeg</a></dt><dt>7.2. <a href="#id2552695"></a></dt><dt>7.3. <a href="#id2551542">Um simples Thumbnail Epsilon</a></dt><dt>7.4. <a href="#id2553098"></a></dt><dt>8.1. <a href="#id2550691">Exemplo Etox</a></dt><dt>8.2. <a href="#id2550712"></a></dt><dt>9.1. <a href="#id2550670">Template Edje</a></dt><dt>9.2. <a href="#id2553715">Programa callback</a></dt><dt>9.3. <a href="#id2555609">arquivo EDC</a></dt><dt>9.4. <a href="#id2555687">Compilação</a></dt><dt>9.5. <a href="#id2555027">Uso do edje_cc</a></dt><dt>9.6. <a href="#id2556654">Uso do edje_decc</a></dt><dt>9.7. <a href="#id2556697">Uso do edje_recc</a></dt><dt>9.8. <a href="#id2556845">Uso do edje_ls</a></dt><dt>9.9. <a href="#id2556937">Uso do edje</a></dt><dt>10.1. <a href="#id2559565">Criando a variável</a></dt><dt>10.2. <a href="#id2559592">Inicializando variáveis</a></dt><dt>10.3. <a href="#id2559638">O botão toggler</a></dt><dt>10.4. <a href="#id2559708">Conectando-se com os eventos de mouse</a></dt><dt>10.5. <a href="#id2559365">Contruir o script</a></dt><dt>10.6. <a href="#ex-Edje_no_Embryo">Comutador Edje sem Embryo</a></dt><dt>10.7. <a href="#id2560463">Diluindo efeito com texto</a></dt><dt>10.8. <a href="#id2560528">Compliação</a></dt><dt>11.1. <a href="#id2559260">Includes e declarações</a></dt><dt>11.2. <a href="#id2559321">main</a></dt><dt>11.3. <a href="#id2561692">mk_gui: Criar a janela</a></dt><dt>11.4. <a href="#id2561962">O container principal</a></dt><dt>11.5. <a href="#id2562037">Criar a barra de menu</a></dt><dt>11.6. <a href="#id2562149">Criar o painel de rolagem</a></dt><dt>11.7. <a href="#id2562228">Criar a área de texto</a></dt><dt>11.8. <a href="#id2562267">Criar o conteúdo do menu</a></dt><dt>11.9. <a href="#id2562411">Vincular callbacks</a></dt><dt>11.10. <a href="#id2562440">callback de finalização</a></dt><dt>11.11. <a href="#id2562487">Callback do item open do menu file</a></dt><dt>11.12. <a href="#id2562599">Callback de finalização do diálogo de arquivo</a></dt><dt>11.13. <a href="#id2562639">Callback do botão open do diálogo de arquivo</a></dt><dt>11.14. <a href="#id2561477">Callback do botão home do diálogo de aquivo</a></dt><dt>11.15. <a href="#id2561520">Ler o arquivo de texto</a></dt><dt>11.16. <a href="#id2561567">Callback de teclado</a></dt><dt>11.17. <a href="#id2563069">Compilação</a></dt><dt>12.1. <a href="#id2564442">Includes e pré-declarações</a></dt><dt>12.2. <a href="#id2565767">main</a></dt><dt>12.3. <a href="#id2565894">Callback de informação de canvas</a></dt><dt>12.4. <a href="#id2565926">Callback de desconexão</a></dt><dt>12.5. <a href="#id2565952">rotina de setup</a></dt><dt>12.6. <a href="#id2566060">Compilação</a></dt><dt>13.1. <a href="#id2566948">Compilação</a></dt><dt>13.2. <a href="#id2566970">Reprodutor de DVD em 55 linhas de código</a></dt><dt>13.3. <a href="#id2564072">Reprodutor de midia Emotion</a></dt></dl></div><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a name="id2440922"></a>Capítulo 1. Introdução</h2></div></div><div></div></div><p>
Bem-vindo ao estado iluminado da programação. Este livro é uma coleção de idéias, 
dicas, tutoriais e introduções arranjadas no estilo receita com o objetivo de ajudar
você a se tornar rapidamente hábil com as Enlightenment Foundation Libraries 
(Bibliotecas de Fundação do Enlightenment) . As 
Enlightenment Foundation Libraries, chamadas simplesmente de EFL, são uma coleção 
de bibliotecas originalmente escritas para suportar o gerenciador de janelas 
Enlightenment DR17. No entanto, ao passo que cresciam e iam sendo testadas, foram
adicionadas funcionalidades gerais que levou-nos a desfrutar de um conjunto de 
bibliotecas ricas e poderosas que podem resolver todo tipo de problemas e também
atuar como uma venerável alternativa para as atualmente populares GTK e QT.
</p><p>
	As EFL são um grupo amplo de bibliotecas C que podem resolver uma grande quantidade de necessidade gráficas em diversas plataformas.
	A seguir uma análise concisa das bibliotecas que fazem parte da EFL.
</p><div class="variablelist"><p class="title"><b>Lista de componentes EFL</b></p><dl><dt><span class="term">Imlib2</span></dt><dd><p>
	Biblioteca completa de manipulação de imagem, incluindo renderização de drawables X11.
	</p></dd><dt><span class="term">EVAS</span></dt><dd><p>
	Biblioteca de canvas com vários motores de backend incluindo aceleração de hardware via OpenGL.
        </p></dd><dt><span class="term">Ecore</span></dt><dd><p>
	Coleção modular de bibliotecas com controle de eventos e temporizadores. Inclui também sockets, IPC, setup de FB e X11, controle de eventos, controle de job, controle de configuração, e mais.
        </p></dd><dt><span class="term">EDB</span></dt><dd><p>
	Uma biblioteca de base de dados capaz de armazenar strings, valores e dados para controle de configuração simples, consistente e centralizado.
        </p></dd><dt><span class="term">EET</span></dt><dd><p>
	Un formato flexivel de container para armazenar imagens binárias e dados.
        </p></dd><dt><span class="term">Edje</span></dt><dd><p>
    Uma biblioteca e toolkit de abstração de imagens baseado no EVAS, mantendo todos os aspectos de interface de usuário completamente separados do código da aplicação usando mensagens.
        </p></dd><dt><span class="term">Embryo</span></dt><dd><p>
	Uma linguagem de script típicamente usanda com Edje para controle avançado.
        </p></dd><dt><span class="term">Etox</span></dt><dd><p>
	Uma biblioteca de formatação e manipulação de texto, completa com capacidades de estilização de texto.        
        </p></dd><dt><span class="term">Esmart</span></dt><dd><p>
	Uma biblioteca consistente de vários objetos inteligentes EVAS para fácil reutilização, incluindo o popular hack de transparência.
        </p></dd><dt><span class="term">Epeg</span></dt><dd><p>
	Uma biblioteca de thumbnailing rápida como um raio para imagens JPEGs independente de outros componentes EFL.
        </p></dd><dt><span class="term">Epsilon</span></dt><dd><p>
	Uma biblioteca de thumbnailing flexivel e rápida para PNG, XCF, GIF and JPEG.
        </p></dd><dt><span class="term">Evoak</span></dt><dd><p>
	Uma biblioteca e toolkit de servidor canvas EVAS.
        </p></dd><dt><span class="term">EWL</span></dt><dd><p>
	Uma completa biblioteca de widgets.        
        </p></dd><dt><span class="term">Emotion</span></dt><dd><p>
	Uma biblioteca de objetos EVAS para reprodução de vídeo e DVD utilizando libxine.
        </p></dd></dl></div></div><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a name="id2440217"></a>Capítulo 2. Imlib2</h2></div></div><div></div></div><div class="toc"><p><b>Índice</b></p><dl><dt><a href="#id2461818">Receita: marca d'agua para imagens</a></dt><dt><a href="#id2443504">Receita: Escalonando imagem</a></dt><dt><a href="#id2443491">Receita: Rotação Livre</a></dt><dt><a href="#id2530984">Receita: Rotação de imagen em 90 graus</a></dt><dt><a href="#id2530677">Receita: Reflexão de Imagem</a></dt></dl></div><p>
Imlib2 é a sucessora da Imlib. Não é apenas uma nova versão - é uma biblioteca completamente nova. Imlib2 pode ser
instalada junto com a Imlib 1.x já que são efetivamente bibliotecas diferentes - mas elas tem funcionalidade similar.
</p><p>
Imlib2 pode fazer o seguinte:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>Carregar imagens do disco em um dos muitos formatos</p></li><li style="list-style-type: disc"><p>Salvar imagens no disco em um dos muitos formatos</p></li><li style="list-style-type: disc"><p>Renderizar dados de imagem dentro de outras imagens</p></li><li style="list-style-type: disc"><p>Renderizar imagens em uma "drawable X"</p></li><li style="list-style-type: disc"><p>Produzir pixmaps e mascaras de pixmap de imagem</p></li><li style="list-style-type: disc"><p>Aplicar filtros em imagens</p></li><li style="list-style-type: disc"><p>Rotacionar imagens</p></li><li style="list-style-type: disc"><p>Aceitar dados RGBA para imagens</p></li><li style="list-style-type: disc"><p>Scalar imagens</p></li><li style="list-style-type: disc"><p>Alpha blend de imagens em outras imagens ou "drawables"</p></li><li style="list-style-type: disc"><p>Aplicar correção de cor, tabelas de modificação e fatores na imagem</p></li><li style="list-style-type: disc"><p>Renderizar imagens sobre imagens com correção de cor e tabelas de modificação</p></li><li style="list-style-type: disc"><p>Renderizar texto truetype com anti-aliasing</p></li><li style="list-style-type: disc"><p>Renderizar texto truetype con anti-aliasing em qualquer ângulo</p></li><li style="list-style-type: disc"><p>Renderizar linha com anti-aliasing</p></li><li style="list-style-type: disc"><p>Renderizar retangulo</p></li><li style="list-style-type: disc"><p>Renderizar gradientes linerares mult-cores</p></li><li style="list-style-type: disc"><p>Dispor inteligentemente os dados na memória  para o máximo de rendimento</p></li><li style="list-style-type: disc"><p>Alocar cores automaticamente</p></li><li style="list-style-type: disc"><p>Permitir controle completo sobre o cache e alocação de cor</p></li><li style="list-style-type: disc"><p>Fornecer instruções assembly MMX altamente otimizado para rotinhas centrais</p></li><li style="list-style-type: disc"><p>Fornecer interface para plug-in de filtros</p></li><li style="list-style-type: disc"><p>Fornecer interface de carga e gravação de imagens por plug-ins em tempo de execução</p></li><li style="list-style-type: disc"><p>A biblioteca de composição, renderização e manipulação mais rápida para o X</p></li></ul></div><p>
Se o que você quer fazer não está na lista acima, então provavelmente a Imlib2 não faz. Se faz, 
provavelmente irá fazer mais rápido que qualquer outra biblioteca que encontrar (isto inclui 
dk-pixbuf, gdkrgb, etc.) principalmente por causa do código altamente otimizado e um subsistema 
inteligente que faz o trabalho sujo pra você e separa as partes que causam tédio deixando que
a Imlib2 faça todas as otimizaçõões pra você.
</p><p>
Imlib2 fornece um potente motor para manipulação e renderização de imagem. Usando carregadores, o Imlib2 pode manejar uma variedade 
de formatos incluindo BMP, GIF (via unGIF), JPEG, PNG, PNM, TGA, TIFF, XPM entre outros.
</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2461818"></a>Receita: marca d'agua para imagens</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Ben</span> <span class="othername">technikolor</span> <span class="surname">Rockwood</span></h3></div></div></div><div></div></div><p>
Com tanta gente publicando tantas imagens online é fácil esquecer de 
onde elas vieram e difícil assegurar que material com direitos de cópia 
não seja inadivertidamente mal utilizado.  Simplesmente adicionando uma 
marca d'agua, como um logo do seu site, em cada uma das imagems pode 
resolver ambos problemas. Mas adicionar marcas d'agua manualmente é uma 
tarefa longa e repetitiva. Imlib2 pode fácilmente ser usada para resolver 
este problema. O que precisamos fazer é pegar uma imagem de entrada, e 
então espeficicar uma imagem para a marca d'agua (seu logo), posicionar 
a marca d'agua  na imagem de entrada e então salvar em uma nova imagem que 
usaremos no site. A aplicação seria algo parecido com isto:
</p><div class="example"><a name="id2443103"></a><p class="title"><b>Exemplo 2.1. Programa Marca d'agua com Imlib2</b></p><pre class="programlisting">
#define X_DISPLAY_MISSING
#include &lt;Imlib2.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv){

    Imlib_Image image_input, image_watermark, image_output;
    int     w_input, h_input;
    int     w_watermark, h_watermark;
    char    watermark[] = "watermark.png";

    if(argc &gt; 1)  {
        printf("Input image is: %s\n", argv[1]);
        printf("Watermark is: %s\n", watermark);
    }
    else {
        printf("Usage: %s input_image output_imagename\n", argv[0]);
        exit(1);
    }

    image_input = imlib_load_image(argv[1]);
    if(image_input) {
        imlib_context_set_image(image_input);
        w_input = imlib_image_get_width();
        h_input = imlib_image_get_height();
        printf("Input size is: %d by %d\n", w_input, h_input);
        image_output = imlib_clone_image();
    }

    image_watermark = imlib_load_image(watermark);
    if(image_watermark) {
        imlib_context_set_image(image_watermark);
        w_watermark = imlib_image_get_width();
        h_watermark = imlib_image_get_height();
        printf("WaterMark size is: %d by %d\n", 
		w_watermark, h_watermark);
    }

    if(image_output) {
        int dest_x, dest_y;

        dest_x = w_input - w_watermark;
        dest_y = h_input - h_watermark;
        imlib_context_set_image(image_output);

        imlib_blend_image_onto_image(image_watermark, 0, 
		0, 0, w_watermark, h_watermark, 
		dest_x, dest_y, w_watermark, h_watermark);
        imlib_save_image(argv[2]);
        printf("Wrote watermarked image to filename: %s\n", argv[2]);
    }


        return(0);
}

</pre></div><p>
Vendo o exemplo, primeiro fazemos uma checagem básica dos argumentos, aceitando uma imagem 
de entrada como primeiro argumento e um nome de imagem de saída para nossa cópia com a marca d'agua.
Usando <tt class="function">imlib_load_image()</tt> carregamos a imagem de entrada e então 
obtemos as suas dimensões usando as funções get.
Com a função <tt class="function">imlib_clone_image()</tt> podemos criar uma cópia da imagem 
de entrada, que será a base da nossa imagem com a marca d'agua de saída. Depois carregamos 
la imagem que será a marca d'agua, e observe que usamos <tt class="function">imlib_context_set_image()</tt> 
para mudar o contexto de imagem de entrada (image_input) para a imagem de marca 
d'agua (image_watermark). Agora obemos as dimensões da imagem também.
No bloco final fazemos um simples cáculo para determinar a posicionamento da marca d'agua 
na imagem de saída, neste caso quero que a marca d'agua fique no canto direito inferior. A função 
mágica que faz o trabalho real neste programa é <tt class="function">imlib_blend_image_onto_image()</tt>. 
Observe que mudamos o contexto da imagem de saída antes de continuar. A função blend irá, como seu 
próprio nome sugere (to blend = misturar), mistura duas imagens juntas que referimos como imagem 
fonte e imagem de destino. A função blend mistura uma imagem fonte sobre a imagem no contexto atual 
que nós designamos como o destino. Os argumentos passados para <tt class="function">imlib_blend_image_onto_image()</tt> 
podem parecer estranhos, precisamos dizer que fonte usar (a marca d'agua), se quer mesclar com canal alfa 
(0 para não), as dimensões da imagem fonte (x, y, w, h), as dimensões da imagem de destino (x, y, w, h). 
Você notará que no exemplo colocamos as posições x, y da imagem fonte (marca d'agua) como 0 e usamos a 
largura total. O destino (imagem de entrada) se coloca no canto inferior direito menos as dimensões da marca 
d'agua, então especificamos a largura e altura da marca d'agua. Finalmente, usamos a função 
<tt class="function">imlib_save_image()</tt> para salvar a imagem de saída.
</p><p>
Enquanto este exemplo deve ser melhorado significativamente para uso real, ele demostra a base 
de mesclagem da Imlib2 para resolver eficientemente um problema muito comum.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2443504"></a>Receita: Escalonando imagem</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Conforme mais pessoas obtem a habilidade de publicar imagens na internet 
é muitas vezes desejado escalonar estas imagens para um tamanho menor para 
reduzir o uso de banda. Isto pode ser facilmente resolvido usando um 
simples programa Imlib2.
</p><p>
Esta receita pega o nome da imagem de entrada, a nova largura, altura e o nome 
da imagem de saída, então escala a imagem de entrada para os valores dados, 
salvando-a na imagem de saída.
</p><div class="example"><a name="id2443528"></a><p class="title"><b>Exemplo 2.2. Escalando imagem</b></p><pre class="programlisting">
#define X_DISPLAY_MISSING

#include &lt;Imlib2.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char ** argv) {
    Imlib_Image in_img, out_img;
    int w, h;

    if (argc != 5) {
        fprintf(stderr, "Usage: %s [in_img] [w] [h] [out_img]\n", argv[0]);
        return 1;
    }

    in_img = imlib_load_image(argv[1]);
    if (!in_img) {
        fprintf(stderr, "Unable to load %s\n", argv[1]);
        return 1;
    }
    imlib_context_set_image(in_img);

    w = atoi(argv[2]);
    h = atoi(argv[3]);
    out_img = imlib_create_cropped_scaled_image(0, 0, imlib_image_get_width(),
                                            imlib_image_get_height(), w, h );
    if (!out_img) {
        fprintf(stderr, "Failed to create scaled image\n");
        return 1;
    }

    imlib_context_set_image(out_img);
    imlib_save_image(argv[4]);
    return 0;
}

</pre></div><p>
No exemplo ha uma mínima checagem dos argumentos, simplesmente checa se o 
número de argumentos passado está correto.
</p><p>
A imagem fonte é carregada com uma chamada à <tt class="function">imlib_load_image()</tt>, 
do qual carregará os dados da imagem na memória. Se a chamada falhar, NULL será 
retornado. Uma vez com os dados da imagem precisamos selecionar a imagem para ser o 
contexto atual. Isto diz ao Imlib2 em qual imagem se efetuará as operações. Isto é 
feito chamando <tt class="function">imlib_context_set_image()</tt>.
Uma vez que a imagem foi definida como contexto atual podemos continuar com o 
escalonamento. Isto é feito chamando <tt class="function">imlib_create_cropped_scaled_image()</tt>, 
que pega como argumentos, a posição de inicio em x, y, largura e altura da imagem fonte, e a 
largura e altura da imagem escalada. A razão de passarmos a informações da imagem fonte é 
que esta função pode recortar a imagem se assim desejar. Para recortar, simplesmente 
modifica-se o x, y, largura da fonte e altura da fonte desejado. Isto resultará em uma 
nova imagem out_img sendo produzida. Se o escalonamento falhar, será devolvido NULL . 
Nós então definimos a out_img para ser o contexto atual e chamamos a função de 
gravar, <tt class="function">imlib_save_image()</tt>.
</p><p>
Apesar de simples, este programa mostra a simplicidade de escalonamento de imagem usando a API da Imlib2.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2443491"></a>Receita: Rotação Livre</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Algumas vezes é desejado rotacioanr uma imagem em um ângulo 
específico. Imblib2 faz este processo fácilmente. Este exemplo 
mostra como fazer isto. Se você deseja rotacionar a imagem em 
angulos de 90 graus, veja a receita de roação de 90 graus já 
esta receita deixa uma borda negra ao redor da imagem.
</p><div class="example"><a name="id2443458"></a><p class="title"><b>Exemplo 2.3. Rotação livre</b></p><pre class="programlisting">
#define X_DISPLAY_MISSING

#include &lt;Imlib2.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main(int argc, char ** argv) {
    Imlib_Image in_img, out_img;
    float angle = 0.0;
    
    if (argc != 4) {
        fprintf(stderr, "Usage: %s [in_img] [angle] [out_img]\n", argv[0]);
        return 1;
    }
    
    in_img = imlib_load_image(argv[1]);
    if (!in_img) {
        fprintf(stderr, "Unable to load %s\n", argv[1]);
        return 1;
    }
    imlib_context_set_image(in_img);
    
    angle = (atof(argv[2]) * (M_PI / 180.0));
    out_img = imlib_create_rotated_image(angle);
    if (!out_img) {
        fprintf(stderr, "Failed to create rotated image\n");
        return 1;
    }
 
    imlib_context_set_image(out_img);
    imlib_save_image(argv[3]);
    return 0;
}
</pre></div><p>
Antes uma checagem simples dos argumentos. Começamos carregando 
a imagem específicada na memoria com 
<tt class="function">imlib_load_image()</tt> passando o nome da imagem 
como parâmetro. Então pegamos a imagem fazendo-a como conexto 
atual com <tt class="function">imblib_context_set_image</tt>. Os 
contextos sãos usados na Imlib2 para saber qual imagem 
trabalhar. Quando você quer fazer chamada imlib em uma imagem, 
a imagem deve estar selecionada como contexto atual. Então 
convertemos o ângulo dado em graus para radiano já que a função 
de rotação da Imlib2 trabalha em redianos. A rotação é feita com 
<tt class="function">imlib_create_rotated_image()</tt>.  A função de 
rotação irá retornar a nova imagem. Para salvar a nova imagem 
precisamos seleciona-la como contexto atual, e novamente chamar 
<tt class="function">imlib_context_set_image()</tt>. Então uma simples 
chamada à <tt class="function">imlib_save_image()</tt> dando o nome do 
arquivo de saída salva a nova imagem rotacionada.

</p><p>
A função de rotação da Imlib2 colocará uma borda preta 
em volta da imagem para preencher qualquer espaço vazio. 
Esta borda é calculada de maneira que a imagem rotacioanda 
caiba na saída. Isto colocará bordas ao redor da imagem de 
saida se você rotacionar em 180 graus.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2530984"></a>Receita: Rotação de imagen em 90 graus</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Com uma câmera digital as vezes é desejado rotacionar sua 
imagem em 90, 180 ou 270 graus. Esta receita mostrará como 
fazer isto fácilmente com a Imlib2. Esta receita também não 
colocará bordas pretas ao redor da imagem como visto no 
exemplo de ratação livre.
</p><div class="example"><a name="id2531003"></a><p class="title"><b>Exemplo 2.4. rotação de imagem em 90 graus</b></p><pre class="programlisting">
#define X_DISPLAY_MISSING

#include &lt;Imlib2.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char ** argv) {
    Imlib_Image in_img;
    int dir = 0;

    if (argc != 3) {
        fprintf(stderr, "Usage: %s [in_img] [out_img]\n", argv[0]);
        return 1;
    }
    
    in_img = imlib_load_image(argv[1]);
    if (!in_img) {
        fprintf(stderr, "Unable to load %s\n", argv[1]);
        return 1;
    }
    imlib_context_set_image(in_img);
    imlib_image_orientate(1);
    imlib_save_image(argv[2]);
    return 0;
}   
</pre></div><p>
Antes uma simples checagem de erro, nós carregamos a imagem a ser rotacionada 
com uma chamada à <tt class="function">imlib_load_image()</tt>.
Esta função aceita um nome de arquivo e retorna um objeto Imlib_Image, 
ou NULL no caso de erro ao tentar carregar. Uma vez carregada a imagem 
é definida como o contexto atual, a imagem que a Imlib2 fará todas as 
operações, com <tt class="function">imlib_context_set_image()</tt>.
A rotação é feita atravéz da chamada à <tt class="function">imlib_image_orientate()</tt>.
O parâmetro para _orientate muda a quantidade de rotação. Os valores 
possíveis são: [1, 2, 3] que siginifica a rotação no sentido horário de 
[90, 180, 270] graus respectivamente. Uma vez rotacionada chamamos 
<tt class="function">imlib_save_image()</tt> informando o nome do arquivo para a 
nova imagem para que o Imlib2 grave a imagem rotacionada.
</p><p>
Com este exemplo em mãos você deve estar habilitado à rotacionar imagens rápidamente em intervalos de 90 graus usando Imlib2.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2530677"></a>Receita: Reflexão de Imagem</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
A Imlib2 contém funções para fazer reflexão de imagem. Isto pode 
ser feito horizontal, vertical ou diagonalmente. Esta receita 
mostrará como implementar esta funcionalidade.
</p><div class="example"><a name="id2530665"></a><p class="title"><b>Exemplo 2.5. Reflexão de Imagem</b></p><pre class="programlisting">
#define X_DISPLAY_MISSING

#include &lt;Imlib2.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char ** argv) {
    Imlib_Image in_img;
    int dir = 0;

    if (argc != 4) {
        fprintf(stderr, "Usage: %s [in_img] [dir] [out_img]\n", argv[0]);
        return 1;
    }

    in_img = imlib_load_image(argv[1]);
    if (!in_img) {
        fprintf(stderr, "Unable to load %s\n", argv[1]);
        return 1;
    }
    imlib_context_set_image(in_img);

    dir = atoi(argv[2]);
    switch(dir) {
        case HORIZONTAL:
            imlib_image_flip_horizontal();
            break;

        case VERTICAL:
            imlib_image_flip_vertical();
            break;

        case DIAGONAL:
            imlib_image_flip_diagonal();
            break;

        default:
            fprintf(stderr, "Unknown value\n");
            return 1;
    }
    imlib_save_image(argv[3]);
    return 0;
}
</pre></div><p>
Este exemplo faz uma mínima checagem de argumentos, então carrega 
a imagem usando <tt class="function">imlib_load_image()</tt> passando o 
nome do arquivo. <tt class="function">imlib_load_image()</tt> devolveré um 
objeto Imlib_Image, ou NULL se falhar. Uma vez com o objeto de imagem 
selecionamos-o como o contexto atual com a chamada à 
<tt class="function">imlib_context_set_image()</tt>.  Isto diz ao Imlib2 
que esta é a imagem que nós queremos trabalhar e todas as operações 
serão feitas nela. Com o contexto de imagem configurado decidimos o tipo 
de reflexão que queremos efetuar. Isto é feito com uma das chamadas: 
<tt class="function">imlib_image_flip_horizontal()</tt>, 
<tt class="function">imlib_image_flip_vertical()</tt>, e 
<tt class="function">imlib_image_flip_diagonal()</tt>. 
A reflexão diagonal essencialmente pega o canto superior esquerdo 
e a faz como canto inferior direito. O canto superior direito se transforma no 
canto inferior esquerdo. Uma vez feita a reflexão na imagem chamamos 
<tt class="function">imlib_save_image()</tt> para salvar informando o nome 
do novo arquivo, e assim terminamos.
</p><p>
Isto deve fornecer um exemplo de imagem reflexionada com Imlib2. Este exemplo necessitará de 
aperfeiçoamentos antes de ser posto como uma aplicação real mas o básico está aí.
</p></div></div><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a name="id2530118"></a>Capítulo 3. EVAS</h2></div></div><div></div></div><div class="toc"><p><b>Índice</b></p><dl><dt><a href="#id2529964">Receita: Usando Ecore_Evas para simplificar a inicialização de canvas X11</a></dt><dt><a href="#id2532834">Receita: Vínculos de teclado, usando eventos de teclado Evas</a></dt><dt><a href="#id2533239">Receita: Introdução aos objetos inteligentes Evas</a></dt></dl></div><p>
Evas é uma API de canvas com aceleração por hardware que pode desenhar texto com anti-aliasing, 
imagens suaves super e sub-sampleadas, alpha-blend, assim como limitar-se à utilizar 
primitivas X11 normais como pixmap, linhas e retângulos com velocidade se sua CPU ou hardware 
gráfico são muito lentos.
</p><p>
Evas abstrai qualquer necessidade de conhecimento avançado sobre as características do 
display do seu XServer,  qual a tonalidade de cor ou quais visuais mágicas ele tem. O 
maximo que você precisa informar ao Evas é quantas cores ( no máximo ) utilizar se 
o seu display não for truecolor. Por padrão sugere-se usar 216 cores ( isto equivale a 
um cubo 6x6x6 - exatamente é o mesmo cubo de cor utilizado pelo Netscape, Mozilla, 
gdkrgb, etc. de maneira que as cores serão compartilhadas). Se Evas não pode alocar 
suficiente cores, ele continuará reduzindo o tamanho do cubo de cor até alcançar branco 
e preto. Desta maneira, o Evas pode mostrar qualquer coisa em um terminal preto e 
branco, VGA 16 cores, 256 cores e 15, 16, 24 e 32bit de cores.
</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2529964"></a>Receita: Usando Ecore_Evas para simplificar a inicialização de canvas X11</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Ben</span> <span class="othername">technikolor</span> <span class="surname">Rockwood</span></h3></div></div></div><div></div></div><p>
Evas é uma biblioteca potente e simples de usar, mas antes de estabelecer um canvas, 
um drawable X11 deve ser configurado. Configurar manualmente o X11 pode ser uma 
tarefa caótica e frustrante que te impossibilita se concentrar no que realmente 
deseja fazer: desenvovler uma aplicação Evas. Mas tudo isto pode ser evitado 
usando o módulo Ecore_Evas do Ecore para fazer todo o trabalho pesado por você.
</p><p>
O seguinte exemplo é um template básico que pode ser usando como ponto 
de partida para qualquer aplicação Evas que desejar construir, cortando 
significativamente o tempo de desenvolvimento.
</p><div class="example"><a name="id2440153"></a><p class="title"><b>Exemplo 3.1. Template Ecore_Evas</b></p><pre class="programlisting">
#include &lt;Ecore_Evas.h&gt;
#include &lt;Ecore.h&gt;

#define WIDTH 400
#define HEIGHT 400

        Ecore_Evas  *   ee;
        Evas        *   evas;
        Evas_Object *   base_rect;

int main(){

        ecore_init();

   ee = ecore_evas_software_x11_new(NULL, 0,  0, 0, WIDTH, HEIGHT);
        ecore_evas_title_set(ee, "Ecore_Evas Template");
        ecore_evas_borderless_set(ee, 0);
        ecore_evas_show(ee);


   evas = ecore_evas_get(ee);
        evas_font_path_append(evas, "fonts/");


   base_rect = evas_object_rectangle_add(evas);
        evas_object_resize(base_rect, (double)WIDTH, (double)HEIGHT);
        evas_object_color_set(base_rect, 244, 243, 242, 255);
        evas_object_show(base_rect);

        /* Insert Object Here */

        ecore_main_loop_begin();

        return 0;
}
</pre></div><p>
Um detalhe completo sobre Ecore_Evas pode ser econtrado no capítulo 
de Ecore neste livro, mas este básico template deve permitir você 
brincar com Evas imediatamente. As chamdas importantes para observar 
são <tt class="function">ecore_evas_borderless_set()</tt> que define se 
a janela Evas está controlada pelo seu gerênciador de janelas ou sem 
bordas, e <tt class="function">evas_font_path_append()</tt> que define 
o(s) caminho(s) das fontes utilizadas por sua aplicação Evas.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2532834"></a>Receita: Vínculos de teclado, usando eventos de teclado Evas</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Ben</span> <span class="othername">technikolor</span> <span class="surname">Rockwood</span></h3></div></div></div><div></div></div><p>
Muitas aplicações pode se beneficiar por fornecer vínculos de teclado para 
operações comumente usadas. Quer aceitando texto de forma que a EFL não espera, 
ou apenas um jeito de vincular a tecla + para aumentar o volume de um mixador, 
os vinculos de teclado (keybinds) pode adicionar pequenas funcionalidades 
fazendo sua aplicação um sucesso.
</p><p>
O seguinte código é uma aplicação simples e completa, útil para 
explorar keybinds usando callbacks de evento EVAS. O exemplo 
criará numa janela  de cor preta de 100 por 100 pixels do qual 
pode-se pressionar teclas.
</p><div class="example"><a name="id2532859"></a><p class="title"><b>Exemplo 3.2. Captura do teclado usando eventos EVAS</b></p><pre class="programlisting">
#include &lt;Ecore_Evas.h&gt;
#include &lt;Ecore.h&gt;

#define WIDTH 100
#define HEIGHT 100

        Ecore_Evas  *   ee;
        Evas        *   evas;
        Evas_Object *   base_rect;

static int main_signal_exit(void *data, int ev_type, void *ev)
{
   ecore_main_loop_quit();
   return 1;
}

void key_down(void *data, Evas *e, Evas_Object *obj, void *event_info) {
        Evas_Event_Key_Down *ev;

        ev = (Evas_Event_Key_Down *)event_info;
        printf("You hit key: %s\n", ev-&gt;keyname);
}

int main(){
        ecore_init();
        ecore_event_handler_add(ECORE_EVENT_SIGNAL_EXIT, 
			main_signal_exit, NULL);

   ee = ecore_evas_software_x11_new(NULL, 0,  0, 0, WIDTH, HEIGHT);
        ecore_evas_title_set(ee, "EVAS KeyBind Example");
        ecore_evas_borderless_set(ee, 0);
        ecore_evas_show(ee);

   evas = ecore_evas_get(ee);

   base_rect = evas_object_rectangle_add(evas);
        evas_object_resize(base_rect, (double)WIDTH, (double)HEIGHT);
        evas_object_color_set(base_rect, 0, 0, 0, 255);
        evas_object_focus_set(base_rect, 1);
        evas_object_show(base_rect);

        evas_object_event_callback_add(base_rect, 
			EVAS_CALLBACK_KEY_DOWN, key_down, NULL);      

        ecore_main_loop_begin();
        
        ecore_evas_shutdown();
        ecore_shutdown();

        return 0;
}
</pre></div><p>
Você pode compilar este exemplo da seguinte maneira:
</p><div class="example"><a name="id2532914"></a><p class="title"><b>Exemplo 3.3. Compilação de keybinds EVAS</b></p><pre class="programlisting">
gcc `evas-config --libs --cflags` `ecore-config --libs --cflags` \
&gt; key_test.c -o key_test
</pre></div><p>
Neste exemplo o canvas é iniciado de maneira habitual usando 
Ecore_Evas para fazer o trabalho sujo. A mágica ocorre no 
callback <tt class="function">evas_object_event_callback_add()</tt>.
</p><pre class="programlisting">
        evas_object_event_callback_add(base_rect,
                        EVAS_CALLBACK_KEY_DOWN, key_down, NULL);
</pre><p>
Adicionando um callback à base_rect, que atua como um backgound do 
canvas, nós podemos executar uma função ( neste caso a 
<tt class="function">key_down()</tt> ) quando encontramos um evento de 
tecla pressionada, EVAS_CALLBACK_KEY_DOWN, conforme definido em 
<tt class="filename">Evas.h</tt>.
</p><p>
Há uma coisa muito importante para se fazer em adição a definição do 
callback: capturar o foco. A função <tt class="function">evas_object_focus_set()</tt> 
captura o foco num objeto Evas dado. Que é o objeto que tem o foco que aceitará 
os eventos sempre quando você explicitamente define o objeto Evas do qual o 
callback está vinculado. E só um objeto pode ter o foco de cada vez. O maior 
problema comumente encontrado com os callbacks Evas é esquecer de capturar o foco.
</p><pre class="programlisting">
void key_down(void *data, Evas *e, Evas_Object *obj, void *event_info) {
        Evas_Event_Key_Down *ev;

        ev = (Evas_Event_Key_Down *)event_info;
        printf("You hit key: %s\n", ev-&gt;keyname);
}
</pre><p>
A função <tt class="function">key_down()</tt> é chamda toda vez que um evento 
de tecla pressionada ocorre depois de definir seu callback. A declaração 
da função é a mesma de um callback Evas comum 
( ver <tt class="filename">Evas.h</tt> ). A parte importante da informação que 
nós precisamos saber é qual tecla foi pressionada, que está contida 
na estrutura <tt class="varname">event_info</tt> Evas. Antes de inciar a 
estrutura <tt class="varname">Evas_Event_Key_Down</tt> para usar como visto acima 
podemos acessar o elemento <tt class="varname">keyname</tt> para determinar qual 
tecla foi pressionada.
</p><p>
Na maioria dos casos você provavelmente usará um <tt class="function">switch</tt> 
ou <tt class="function">if</tt>s alinhados para definir quais teclas fazem o que, 
e recomenda-se que esta funcionalidade seja complementada com uma 
configuração EDB para fornecer centralização e fácil expansão da 
configuração de keybinds das suas aplicações.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2533239"></a>Receita: Introdução aos objetos inteligentes Evas</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Quando trabalhar mais com Evas, você terá vários 
<tt class="literal">Evas_Object</tt> dos quais estará trabalhando e 
aplicando as mesmas operações para mantê-los em sincronia. Seria mais 
conveniente agrupar todos este <tt class="literal">Evas_Object</tt> em um único 
objeto onde todas as transformações podem ser aplicadas.
</p><p>
Os objetos inteligentes Evas fornecem a capacidade de escrever 
seus próprios objetos e ter a Evas chamando suas funções para
movimentar, redimencionar, esconder, fazer camadas e todas as coisas 
que um <tt class="literal">Evas_Object</tt> é responsável de controlar. Junto 
com os callbacks normais do <tt class="literal">Evas_Object</tt>, os objetos 
inteligentes permitem definir suas próprias funções para controlar 
quaisquer operações especiais que desejar.
</p><p>
Esta introdução está dividia em 3 arquivos: foo.h, foo.c e main.c. O 
objeto inteligente criado chama-se <tt class="literal">foo</tt> e está 
definido nos foo.c e foo.h, main.c mostra como o novo objeto 
inteligente pode ser usado.
</p><p>
O objeto inteligente em si é apenas dois quadrados, um dentro do outro, 
onde o interno está separado 10% da borda do quadrado externo. Ao passo 
que o programa principal se executa um callback de temporizador Ecore 
reposicionará e redimencionará o objeto inteligente.
</p><p>
O arquivo básico para este objeto inteligente vem de um template 
Evas Smart Object de autoria de Atmos e localizada em: <tt class="literal"><a href="http://www.atmos.org/code/src/evas_smart_template_atmos.c" target="_top">
www.atmos.org/code/src/evas_smart_template_atmos.c</a></tt> 
que foi baseado no template de autoria de Rephorm.
</p><p>
Primeiro precisamos definir a interface externa do nosso objeto 
inteligente. Neste caso apenas precisamos de uma chamada para 
criar o novo objeto.
</p><div class="example"><a name="id2532716"></a><p class="title"><b>Exemplo 3.4. foo.h</b></p><pre class="programlisting">
#ifndef _FOO_H_
#define _FOO_H_ 
   
#include &lt;Evas.h&gt;

Evas_Object *foo_new(Evas *e);

#endif
</pre></div><p>
</p><p>
Com isto fora do caminho, entramos na escura entranhas da besta, o código do objeto inteligente.
</p><div class="example"><a name="id2532740"></a><p class="title"><b>Exemplo 3.5. foo.c</b></p><pre class="programlisting">
#include &lt;Evas.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct _Foo_Object Foo_Object;
struct _Foo_Object {
	Evas_Object *clip;
	Evas_Coord x, y, w, h;

	Evas_Object *outer;
	Evas_Object *inner;
};  
</pre></div><p>
<tt class="literal">Foo_Object</tt> armazenará toda a informação do nosso objeto. Neste 
caso é o objeto caixa externa, caixa interna, um objeto de clipping e a atual 
posição e tamanho do objeto.
</p><p>
</p><pre class="programlisting">
static Evas_Smart *_foo_object_smart_get();
static Evas_Object *foo_object_new(Evas *evas);
static void _foo_object_add(Evas_Object *o);
static void _foo_object_del(Evas_Object *o);
static void _foo_object_layer_set(Evas_Object *o, int l);
static void _foo_object_raise(Evas_Object *o);
static void _foo_object_lower(Evas_Object *o);
static void _foo_object_stack_above(Evas_Object *o, Evas_Object *above);
static void _foo_object_stack_below(Evas_Object *o, Evas_Object *below);
static void _foo_object_move(Evas_Object *o, Evas_Coord x, Evas_Coord y);
static void _foo_object_resize(Evas_Object *o, Evas_Coord w, Evas_Coord h);
static void _foo_object_show(Evas_Object *o);
static void _foo_object_hide(Evas_Object *o);
static void _foo_object_color_set(Evas_Object *o, int r, int g, int b, int a);
static void _foo_object_clip_set(Evas_Object *o, Evas_Object *clip);
static void _foo_object_clip_unset(Evas_Object *o);
</pre><p>
As pré-declarações requeridas para o objeto inteligente. Estas serão explicadas 
quando chegarmos na implementação.
</p><p>
</p><pre class="programlisting">
Evas_Object *foo_new(Evas *e) {
    Evas_Object *result = NULL;
    Foo_Object *data = NULL;

    if ((result = foo_object_new(e))) {
        if ((data = evas_object_smart_data_get(result)))
            return result;
        else
            evas_object_del(result);
    }

    return NULL;
}
</pre><p>
<tt class="function">foo_new()</tt> única interface externa e é responsável 
por configurar o objeto em si. A chamada à <tt class="function">foo_object_new()</tt> 
fará o trabalho pesado na criação do objeto. A 
<tt class="function">evas_object_smart_data_get()</tt> é mais uma checagem de erro 
do que qualquer outra coisa. Quando executa-se <tt class="function">foo_object_new()</tt> 
adicionará o objeto inteligente ao evas e isto resultará em uma chamada à 
<tt class="literal">add</tt>. Neste caso <tt class="literal">add</tt> criará um 
<tt class="literal">Foo_Object</tt>. Assim, estamos apenas certificando 
que <tt class="literal">Foo_Object</tt> foi criado.
</p><p>
</p><pre class="programlisting">
static Evas_Object *foo_object_new(Evas *evas) {
    Evas_Object *foo_object;

    foo_object = evas_object_smart_add(evas, _foo_object_smart_get());
    return foo_object;
}
</pre><p>
Nossa função <tt class="function">foo_object_new()</tt> tem uma simples 
tarefa de adicionar nosso objeto inteligente num Evas dado. Se faz 
isto através de <tt class="function">evas_object_smart_add()</tt> passando 
o Evas e o objeto <tt class="literal">Evas_Smart *</tt>. Nosso 
<tt class="literal">Evas_Smart *</tt> é produzido por chamar 
<tt class="function">_foo_object_smart_get()</tt>.
</p><p>
</p><pre class="programlisting">
static Evas_Smart *_foo_object_smart_get() {
    static Evas_Smart *smart = NULL;
    if (smart)
        return (smart);

    smart = evas_smart_new("foo_object",
                            _foo_object_add,
                            _foo_object_del,
                            _foo_object_layer_set,
                            _foo_object_raise,
                            _foo_object_lower,
                            _foo_object_stack_above,
                            _foo_object_stack_below,
                            _foo_object_move,
                            _foo_object_resize,
                            _foo_object_show,
                            _foo_object_hide,
                            _foo_object_color_set,
                            _foo_object_clip_set,
                            _foo_object_clip_unset,
                            NULL
                          );
    return smart;
}
</pre><p>
Você irá observar que <tt class="literal">Evas_Smart *smart</tt> nesta função é 
declarado como <tt class="literal">static</tt>. Porque não importa quantos 
<tt class="literal">Evas_Object</tt> criemos, só haverá um único objeto 
<tt class="literal">Evas_Smart</tt>. Como Raster enfatiza, <tt class="literal">Evas_Smart</tt> 
é como uma definição de classe C++, não uma instância. O 
<tt class="literal">Evas_Object</tt> é a instância do 
<tt class="literal">Evas_Smart</tt>.
</p><p>
O objeto inteligente em si é criado atravéz de uma 
chamada à função  <tt class="function">evas_smart_new()</tt>. 
Para esta função passamos o nome do objeto inteligente, todas 
as rotina de callback para o objeto inteligente, e qualquer 
dado de usuário. Neste casso nós não temos dados de usuário, 
então usamos NULL.
</p><p>
</p><pre class="programlisting">
static void _foo_object_add(Evas_Object *o) {
    Foo_Object *data = NULL;
    Evas *evas = NULL;

    evas = evas_object_evas_get(o);

    data = (Foo_Object *)malloc(sizeof(Foo_Object));
    memset(data, 0, sizeof(Foo_Object));

    data-&gt;clip = evas_object_rectangle_add(evas);
    data-&gt;outer = evas_object_rectangle_add(evas);
    evas_object_color_set(data-&gt;outer, 0, 0, 0, 255);
    evas_object_clip_set(data-&gt;outer, data-&gt;clip);
    evas_object_show(data-&gt;outer);

    data-&gt;inner = evas_object_rectangle_add(evas);
    evas_object_color_set(data-&gt;inner, 255, 255, 255, 126);
    evas_object_clip_set(data-&gt;inner, data-&gt;clip);
    evas_object_show(data-&gt;inner);

    data-&gt;x = 0;
    data-&gt;y = 0;
    data-&gt;w = 0;
    data-&gt;h = 0;

    evas_object_smart_data_set(o, data);
}
</pre><p>
Quando <tt class="function">evas_object_smart_add()</tt> é chamada 
em <tt class="function">foo_object_new()</tt>, esta função, 
<tt class="function">_foo_object_add()</tt>, será chamada de modo  
que podemos inicializar qualquer dado interno para este objeto 
inteligente.
</p><p>
Para este objeto inteligente nós inicializamos três <tt class="literal">Evas_Object</tt> 
internos. Sendo estes <tt class="literal">data-&gt;clip</tt>usado para fazer clipping com 
os outros dois objetos, <tt class="literal">data-&gt;outer</tt> que é nosso retângulo externo 
e <tt class="literal">data-&gt;inner</tt>, nosso retângulo interno. Os retângulos interno 
e externo tem o clipping setado para o objeto clip e são mostrados imediatamente. 
O objeto clip não é mostrado, só será mostrando quando o usuário chamar 
<tt class="function">evas_object_show()</tt> neste objeto.
</p><p>
Finalmente chamamos <tt class="function">evas_object_smart_data_set()</tt> para setar 
nosso novo <tt class="literal">Foo_Object</tt> como dado para este objeto inteligente. 
Este dado será recuperado em outras funções deste objeto chamando a 
<tt class="function">evas_object_smart_data_get()</tt>.
</p><p>
</p><pre class="programlisting">
static void _foo_object_del(Evas_Object *o) {
    Foo_Object *data;

    if ((data = evas_object_smart_data_get(o))) {
        evas_object_del(data-&gt;clip);
        evas_object_del(data-&gt;outer);
        evas_object_del(data-&gt;inner);
        free(data);
    }
}
</pre><p>
O callback <tt class="function">_foo_object_del()</tt> será 
executado se o usuário chamar <tt class="function">evas_object_del()</tt> em 
nosso objeto. Para este objetos é simples, basta chamar 
<tt class="function">evas_object_del</tt> no nossos 3 retângulos e 
liberar a nossa estrutura <tt class="literal">Foo_Object</tt>.
</p><p>
</p><pre class="programlisting">
static void _foo_object_layer_set(Evas_Object *o, int l) {
    Foo_Object *data;

    if ((data = evas_object_smart_data_get(o))) {
        evas_object_layer_set(data-&gt;clip, l);
    }
}

static void _foo_object_raise(Evas_Object *o) {
    Foo_Object *data;

    if ((data = evas_object_smart_data_get(o))) {
        evas_object_raise(data-&gt;clip);
    }
}

static void _foo_object_lower(Evas_Object *o) {
    Foo_Object *data;

    if ((data = evas_object_smart_data_get(o))) {
        evas_object_lower(data-&gt;clip);
    }
}

static void _foo_object_stack_above(Evas_Object *o, Evas_Object *above) {
    Foo_Object *data;

    if ((data = evas_object_smart_data_get(o))) {
        evas_object_stack_above(data-&gt;clip, above);
    }
}

static void _foo_object_stack_below(Evas_Object *o, Evas_Object *below) {
    Foo_Object *data;

    if ((data = evas_object_smart_data_get(o))) {
        evas_object_stack_below(data-&gt;clip, below);
    }
}
</pre><p>
Este grupo de funções: <tt class="function">_foo_object_layer_set()</tt>,
<tt class="function">_foo_object_raise()</tt>,
<tt class="function">_foo_object_lower()</tt>,
<tt class="function">_foo_object_stack_above()</tt>, e
<tt class="function">_foo_object_stack_below()</tt> trabalham todos 
da mesma maneira, aplicando a função requerida 
<tt class="function">evas_object_*</tt> no objeto <tt class="literal">data-&gt;clip</tt>.
</p><p>
Estas funções são disparadas pelo uso de:
<tt class="function">evas_object_layer_set()</tt>,
<tt class="function">evas_object_raise()</tt>,
<tt class="function">evas_object_lower()</tt>,
<tt class="function">evas_object_stack_above()</tt>, e
<tt class="function">evas_object_stack_below()</tt> respectivamente.
</p><p>
</p><pre class="programlisting">
static void _foo_object_move(Evas_Object *o, Evas_Coord x, Evas_Coord y) {
    Foo_Object *data;

    if ((data = evas_object_smart_data_get(o))) {
        float ix, iy;
        ix = (data-&gt;w - (data-&gt;w * 0.8)) / 2;
        iy = (data-&gt;h - (data-&gt;h * 0.8)) / 2;

        evas_object_move(data-&gt;clip, x, y);
        evas_object_move(data-&gt;outer, x, y);
        evas_object_move(data-&gt;inner, x + ix, y + iy);

        data-&gt;x = x;
        data-&gt;y = y;
    }
}
</pre><p>
O callback <tt class="function">_foo_object_move()</tt> será disparado quando 
<tt class="function">evas_object_move()</tt> é chamada em nosso objeto. Cada 
um dos objetos interno é movido na posição correta com chamadas para
 <tt class="function">evas_object_move()</tt>.
</p><p>
</p><pre class="programlisting">
static void _foo_object_resize(Evas_Object *o, Evas_Coord w, Evas_Coord h) {
    Foo_Object *data;

    if ((data = evas_object_smart_data_get(o))) {
        float ix, iy, iw, ih;
        iw = w * 0.8;
        ih = h * 0.8;

        ix = (w - iw) / 2;
        iy = (h - iw) / 2;

        evas_object_resize(data-&gt;clip, w, h);
        evas_object_resize(data-&gt;outer, w, h);

        evas_object_move(data-&gt;inner, data-&gt;x + ix, data-&gt;y + iy);
        evas_object_resize(data-&gt;inner, iw, ih);

        data-&gt;w = w;
        data-&gt;h = h;
    }
}
</pre><p>
O callback <tt class="function">_foo_object_resize()</tt> será disparado quando
o usuário chama <tt class="function">_foo_object_resize()</tt> no nosso objeto. Assim,
para nosso objeto, precisamos redimensionar <tt class="literal">data-&gt;clip</tt> e 
<tt class="literal">data-&gt;outer</tt> ao tamanho completo disponível para nosso objeto.
Isto é feito com as chamadas à <tt class="function">evas_object_resize()</tt>.
Então precisamos mover e redimencionar o objeto <tt class="literal">data-&gt;inner</tt> para 
que permaneça na posição correta no retângulo externo. Isto é feito 
com <tt class="function">evas_object_move()</tt> e
<tt class="function">evas_object_resize()</tt> respectivamente. Então guardamos a largura
e altura atual do nosso objeto para que possamos referência-los mais tarde.
</p><p>
</p><pre class="programlisting">
static void _foo_object_show(Evas_Object *o) {
    Foo_Object *data;

    if ((data = evas_object_smart_data_get(o)))
            evas_object_show(data-&gt;clip);
}
</pre><p>
O callback <tt class="function">_foo_object_show()</tt> será disparando quando
<tt class="function">evas_object_show()</tt> for chamada no nosso objeto. Para
mostrar nosso objeto todo o que precisamos fazer é mostrar a região de clipe,
já que o retângulo atual está "clipado". Isto é feito chamando 
<tt class="function">evas_object_show()</tt>. 
</p><p>
</p><pre class="programlisting">
static void _foo_object_hide(Evas_Object *o) {
    Foo_Object *data;

    if ((data = evas_object_smart_data_get(o)))
        evas_object_hide(data-&gt;clip);
}
</pre><p>
O callback <tt class="function">_foo_object_hide()</tt> será disparado quando
uma chamada à <tt class="function">evas_object_hide()</tt> for feita no nosso objeto.
Por estarmos usando um objeto de clipping interno só precisamos esconder o objeto
clip, <tt class="literal">data-&gt;clip</tt>, para esconder nosso objeto inteligente.
Isto é feito por meio da chamada à <tt class="function">evas_object_hide()</tt>.
</p><p>
</p><pre class="programlisting">
static void _foo_object_color_set(Evas_Object *o, int r, int g, int b, int a) {
}
</pre><p>
A função <tt class="function">_foo_object_color_set()</tt> será disparada quando
<tt class="function">evas_object_color_set()</tt> for chamada por nosso 
<tt class="literal">Evas_Object</tt>. Mas, já que não quero mudar as cores do 
meu objeto, ignoro este callback.
</p><p>
</p><pre class="programlisting">
static void _foo_object_clip_set(Evas_Object *o, Evas_Object *clip) {
    Foo_Object *data;

    if ((data = evas_object_smart_data_get(o)))
        evas_object_clip_set(data-&gt;clip, clip);
}
</pre><p>
O callback <tt class="function">_foo_object_clip_set()</tt> será disparada quando 
<tt class="function">evas_object_clip_set()</tt> for chadamda por nosso objeto. Neste caso 
propagamos isto a nosso objeto de clipping interno por meio da chamada à 
<tt class="function">evas_object_clip_set()</tt>.
</p><p>
</p><pre class="programlisting">
static void _foo_object_clip_unset(Evas_Object *o) {
    Foo_Object *data;

    if ((data = evas_object_smart_data_get(o)))
        evas_object_clip_unset(data-&gt;clip);
}
</pre><p>
O callback <tt class="function">_foo_object_clip_unset()</tt> será disparado quando 
uma chamada a <tt class="function">evas_object_clip_unset()</tt> for feita no 
nosso objeto. Nós simplesmente removemos o clip interno por meio da chaamda á 
<tt class="function">evas_object_clip_unset()</tt>.
</p><p>
Uma vez completo nossoo código do objeto inteligente, podemos criar o 
programa principal para utilizar o novo objeto inteligente.
</p><div class="example"><a name="id2534775"></a><p class="title"><b>Exemplo 3.6. main.c</b></p><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;Ecore_Evas.h&gt;
#include &lt;Ecore.h&gt;
#include "foo.h"

#define WIDTH 400
#define HEIGHT 400
#define STEP 10

static int dir = -1;
static int cur_width = WIDTH;
static int cur_height = HEIGHT;

static int timer_cb(void *data);

int main() {
    Ecore_Evas  *ee;
    Evas        *evas;
    Evas_Object *o;

    ecore_init();

    ee = ecore_evas_software_x11_new(NULL, 0, 0, 0, WIDTH, HEIGHT);
    ecore_evas_title_set(ee, "Smart Object Example");
    ecore_evas_borderless_set(ee, 0);
    ecore_evas_show(ee);

    evas = ecore_evas_get(ee);

    o = evas_object_rectangle_add(evas);
    evas_object_resize(o, (double)WIDTH, (double)HEIGHT);
    evas_object_color_set(o, 200, 200, 200, 255);
    evas_object_layer_set(o, -255);
    evas_object_show(o);

    o = foo_new(evas);
    evas_object_move(o, 0, 0);
    evas_object_resize(o, (double)WIDTH, (double)HEIGHT);
    evas_object_layer_set(o, 0);
    evas_object_show(o);

    ecore_timer_add(0.1, timer_cb, o);
    ecore_main_loop_begin();

    return 0;
}   
        
static int timer_cb(void *data) {
    Evas_Object *o = (Evas_Object *)data;
    Evas_Coord x, y;

    cur_width += (dir * STEP);
    cur_height += (dir * STEP);

    x = (WIDTH - cur_width) / 2;
    y = (HEIGHT - cur_height) / 2;

    if ((cur_width &lt; STEP) || (cur_width &gt; (WIDTH - STEP)))
        dir *= -1;

    evas_object_move(o, x, y);
    evas_object_resize(o, cur_width, cur_height);
    return 1;
}
</pre></div><p>
Muito deste programa é parte da receita usando Ecore_Evas dado anteriormente. 
A criação de nosso novo objeto inteligente e vista no fragmento de código:
</p><pre class="programlisting">
    o = foo_new(evas);
    evas_object_move(o, 0, 0);
    evas_object_resize(o, (double)WIDTH, (double)HEIGHT);
    evas_object_layer_set(o, 0);
    evas_object_show(o);
</pre><p>
Uma vez que a sua nova <tt class="function">foo_new()</tt>  
devolve nosso objeto, podemos manipula-lo com as chamadas normais 
Evas, e assim ajustarmos a posição, tamanho, camada e então mostrar o objeto.
</p><p>
Uma vez criado e mostrado o novo objeto inteligente, iniciamos um 
temporizador Ecore para disparar a cada 0.1 segundos. Quando o 
temporizador disparar ele irá executar a função <tt class="function">timer_cb()</tt>. 
Esta função callback diminuirá e aumentará o tamanho de nosso objeto 
inteligente enquanto o mantém centralizado na janela principal.
</p><p>
Compilar este exemplo é tão simples como:
</p><div class="example"><a name="id2534883"></a><p class="title"><b>Exemplo 3.7. Compilação</b></p><pre class="screen">
zero@oberon [evas_smart] -&gt; gcc -o foo foo.c main.c \
    `ecore-config --cflags --libs` `evas-config --cflags --libs`
</pre></div><p>
</p><p>
Os objetos inteligentes Evas são simples de criar mas fornecem um 
potente mecanismo para abstrair partes do seu programa. Para ver 
mais objetos inteligente dê uma olhada em qualquer dos objetos 
Esmart, Etox ou Emotion.
</p></div></div><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a name="id2536392"></a>Capítulo 4. Ecore</h2></div></div><div></div></div><div class="toc"><p><b>Índice</b></p><dl><dt><a href="#id2537815">Receita: Introdução ao Ecore Config</a></dt><dt><a href="#id2537741">Receita: Listeners Ecore Config</a></dt><dt><a href="#id2537681">Receite: Conexão para um servidor com Ecore_Con</a></dt><dt><a href="#id2537553">Receita: Introdução a Ecore Ipc</a></dt><dt><a href="#id2542355">Receita: Temporizadores Ecore</a></dt><dt><a href="#id2540983">Receita: Adicionando eventos Ecore</a></dt></dl></div><p>
O que é Ecore? Ecore é o núcleo central da camada de abstração de eventos e abstração X que permite 
fazer seleções, Xdnd, coisas do X em geral, loops de evento, controle de expiração e 
tempo de inatividade de uma maneira rápida, otimizada e conveniente. É uma biblioteca separada 
de maneira que qualquer um pode usar suas tarefas nas aplicações de um modo fácil.
</p><p>
Ecore é totalmente modular. Em sua base está os controladores de eventos, temporizadores, e 
funções de inicialização e encerramento. Os módulos de abstração Ecore incluem:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>Ecore X</p></li><li style="list-style-type: disc"><p>Ecore FB</p></li><li style="list-style-type: disc"><p>Ecore EVAS</p></li><li style="list-style-type: disc"><p>Ecore TXT</p></li><li style="list-style-type: disc"><p>Ecore Job</p></li><li style="list-style-type: disc"><p>Ecore IPC</p></li><li style="list-style-type: disc"><p>Ecore Con</p></li><li style="list-style-type: disc"><p>Ecore Config</p></li></ul></div><p>
Ecore é tão modular e potente que pode ser muito útil no desenvolvimento de programas não gráficos. Por exemplo, vários 
servidores web estão sendo escritos só com Ecore e o módulo Ecore_Con para abstrair a comunicação por socket.
</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2537815"></a>Receita: Introdução ao Ecore Config</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
O módulo Ecore_Config provê ao programador uma jeito muito simples de preparar
arquivos de configuração para seu programa. Esta receita dará um exemplo de como
integrar os principios do Ecore_Config em seu programa e utilizar-lo para conseguir 
os dados de configuração.
</p><div class="example"><a name="id2537833"></a><p class="title"><b>Exemplo 4.1. Um simples programa Ecore_Config</b></p><pre class="programlisting">
#include &lt;Ecore_Config.h&gt;

int main(int argc, char ** argv) {
    int i;
    float j;
    char *str;

    if (ecore_config_init("foo") != ECORE_CONFIG_ERR_SUCC) {
        printf("Cannot init Ecore_Config");
        return 1;
    }

    ecore_config_int_default("/int_example", 1);
    ecore_config_string_default("/this/is/a/string/example", "String");
    ecore_config_float_default("/float/example", 2.22);

    ecore_config_load();

    i = ecore_config_int_get("/int_example");
    str = ecore_config_string_get("/this/is/a/string/example");
    j = ecore_config_float_get("/float/example");

    printf("str is (%s)\n", str);
    printf("i is (%d)\n", i);
    printf("j is (%f)\n", j);

    free(str);

    ecore_config_shutdown();
    return 0;
}
</pre></div><p>
Como pode ver, o uso básico do Ecore_Config é simples. O sistema é inicializado 
com a função <tt class="function">ecore_config_init</tt>. O nome do programa indica 
onde o Ecore_Config irá procurar pela sua base de dados de configuração. O 
diretório e o nome do arquivo são: ~/.e/apps/NOME_DO_PROGRAMA/config.db.
</p><p>
Para cada variável de configuração que você receber do Ecore_Config, pode assinar 
um valor padrão no caso do usuário não ter um arquivo config.db. Os valores 
por padrão são assinados com ecore_config_*_default onde * é um dos tipos 
Ecore_Config. O primeiro parâmetro é a chave que vai ser acessada. Estas chaves 
devem ser únicas em seu programa. O valor passado é do tipo apropriado para esta chamada.
</p><p>
A chamada a <tt class="function">ecore_config_load</tt> irá ler os valores do arquivo 
config.db no Ecore_Config. Depois disto, podemos acessar os arquivos com os 
métodos ecore_config_*_get (novamente * é o tipo de dados desejado). Estas rotinas 
usam do nome da chave para este item e retornam o valor associado à chave. Cada 
função retorna um tipo que corresponde ao nome da chamada da função.
</p><p>
<tt class="function">ecore_config_shutdown</tt> é então chamada para terminar o sistema Ecore_Config antes de sair do programa.
</p><div class="example"><a name="id2537945"></a><p class="title"><b>Exemplo 4.2. Comando para comilação</b></p><pre class="programlisting">
gcc -o ecore_config_example ecore_config_example.c `ecore-config --cflags --libs`
</pre></div><p>
Para compilar o programa você pode usar o script ecore-config para obter toda informação de biblioteca 
e linkagem requerida pelo Ecore_Config.

Se você executar este programa como está, receberá como saída os valores passados pelo 
ecore_config. O programa uma vez funcionando, você pode criar um simples arquivo config.db para ler os valores.
</p><div class="example"><a name="id2537977"></a><p class="title"><b>Exemplo 4.3. Um simples script config.db (build_cfg_db.sh)</b></p><pre class="programlisting">
#!/bin/sh

DB=config.db

edb_ed $DB add /int_example int 2
edb_ed $DB add /this/is/a/string/example str "this is a string"
edb_ed $DB add /float/example float 42.10101
</pre></div><p>
Quando for executado, o build_cfg_db.sh criará um arquivo config.db no diretório atual. 
Este arquivo pode ser compiado para ~/.e/apps/NOME_DO_PROGRAMA/config.db onde 
NOME_DO_PROGRAMA é o valor passado para ecore_config_init. Uma vez copiado para o diretório, 
executando o programa test mostrará os valores do arquivo config no lugar dos valores 
padrão. Você pode especificar quantas chaves de configuração desejar no arquivo 
config e o Ecore_Config mostrará o valor do usuário ou o valor padrão.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2537741"></a>Receita: Listeners Ecore Config</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Quando se usa Ecore Config para controlar a configuração da sua aplicação é bom ser 
notificado quando esta configuração for modificada. Consegue-se isto mediante o uso 
de listeners Ecore_Config.
</p><p>
</p><div class="example"><a name="id2537785"></a><p class="title"><b>Exemplo 4.4. Ecore_Config listener</b></p><pre class="programlisting">
#include &lt;Ecore.h&gt;
#include &lt;Ecore_Config.h&gt;

static int listener_cb(const char *key, const Ecore_Config_Type type,
            const int tag, void *data);

enum {
    EX_ITEM,
    EX_STR_ITEM,
    EX_FLOAT_ITEM
};

int main(int argc, char ** argv) {
    int i;
    float j;
    char *str;

    if (!ecore_init()) {
        printf("Cannot init ecore");
        return 1;
    }

    if (ecore_config_init("foo") != ECORE_CONFIG_ERR_SUCC) {
        printf("Cannot init Ecore_Config");
        ecore_shutdown();
        return 1;
    }

    ecore_config_int_default("/int/example", 1);
    ecore_config_string_default("/string/example", "String");
    ecore_config_float_default("/float/example", 2.22);

    ecore_config_listen("int_ex", "/int/example", listener_cb, 
                                                EX_ITEM, NULL);
    ecore_config_listen("str_ex", "/string/example", listener_cb, 
                                                EX_STR_ITEM, NULL);
    ecore_config_listen("float_ex", "/float/example", listener_cb, 
                                                EX_FLOAT_ITEM, NULL);

    ecore_main_loop_begin();
    ecore_config_shutdown();
    ecore_shutdown();
    return 0;
}

static int listener_cb(const char *key, const Ecore_Config_Type type,
                                            const int tag, void *data) {

    switch(tag) {
        case EX_ITEM:
            {
                int i = ecore_config_int_get(key);
                printf("int_example :: %d\n", %i);
            }
            break;

        case EX_STR_ITEM:
            {
                char *str = ecore_config_string_get(key);
                printf("str :: %s\n", %str);
                free(str);
            }
            break;

        case EX_FLOAT_ITEM:
            {
                float f = ecore_config_float_get(key);
                printf("float :: %f\n", %f);
            }
            break;

        default:
            printf("Unknown tag (%d)\n", tag);
            break;
    }
}
</pre></div><p>
Ecore_Config é inicializado da maneira habitual, e criamos algumas chaves padrão como normalmente ocorre. As partes interessantes entram no jogo com as chamadas para <tt class="function">ecore_config_listen()</tt>. Esta é a chamada que diz para o Ecore_Config que desejamos ser notificados das mudanças da configuração.
<tt class="function">ecore_config_listen()</tt> pega 5 parâmetros:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>name</p></li><li style="list-style-type: disc"><p>key</p></li><li style="list-style-type: disc"><p>listener callback</p></li><li style="list-style-type: disc"><p>id tag</p></li><li style="list-style-type: disc"><p>user data</p></li></ul></div><p>
O campo <tt class="literal">name</tt> é uma string dado por você para identificar este callback de listener. O campo 
<tt class="literal">key</tt> é o nome da chave que deseja escutar, este será o mesmo nome da chave passado para as chamadas _default acima. O 
<tt class="literal">listener callback</tt> é a função callback que será executada em caso de mudança. O 
<tt class="literal">id tag</tt> é uma etiqueta numérica que pode ser dada a cada listener e será passada para a função callback. Finalmente, 
<tt class="literal">user data</tt> é qualquer dado que deseja ser passado para a callback quando este é executado.
</p><p>
A função callback tem uma assinatura semelhante a:
</p><pre class="programlisting">
int listener_cb(const char *key, const Ecore_Config_Type type,
                                    const int tag, void *data);
</pre><p>
O campo <tt class="literal">key</tt> é o nome da chave que quer escutar.
O parâmetro <tt class="literal">type</tt> conterá o tipo Ecore_Config. Este pode ser um dos:
</p><div class="variablelist"><dl><dt><span class="term">PT_NIL</span></dt><dd><p>Propriedade sem valor</p></dd><dt><span class="term">PT_INT</span></dt><dd><p>Prpriedade inteira</p></dd><dt><span class="term">PT_FLT</span></dt><dd><p>Propriedade Float</p></dd><dt><span class="term">PT_STR</span></dt><dd><p>Propriedade String</p></dd><dt><span class="term">PT_RGB</span></dt><dd><p>Propriedade Colour</p></dd><dt><span class="term">PT_THM</span></dt><dd><p>Propriedade Theme</p></dd></dl></div><p>
O parâmetro <tt class="literal">tag</tt> é o valor que foi passado acima, na chamada de 
criação de listener. Finalmente, <tt class="literal">data</tt> é qualquer dado anexado 
ao listener quando este foi criado.
</p><p>
Se desejar remover o listener em um momento posterior use <tt class="function">ecore_config_deaf()</tt>. Que tem três parâmetros:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>name</p></li><li style="list-style-type: disc"><p>key</p></li><li style="list-style-type: disc"><p>listener callback</p></li></ul></div><p>
Cada um dos parâmetros corresponde ao parâmetro dado na chamada inicial <tt class="function">ecore_config_listen()</tt>.
</p><p>
</p><div class="example"><a name="id2538602"></a><p class="title"><b>Exemplo 4.5. Compilação</b></p><pre class="screen">
zero@oberon [ecore_config] -&gt; gcc -o ecfg ecfg_listener.c \
    `ecore-config --cflags --libs`
</pre></div><p>
Se você executar o programa verá os valores padrões na tela. Se você executar agora examine como segue:
</p><pre class="screen">zero@oberon [ecore_config] -&gt; examine foo</pre><p> (foo é o nome passado 
para <tt class="function">ecore_config_init()</tt>). Você deve então ser capaz de modificar a configuração da sua aplicação e, após 
digitar 'save', ver no console os valores modificados.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2537681"></a>Receite: Conexão para um servidor com Ecore_Con</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Client/server estão tornando-se completamente comuns hoje em dia. Para este fim,
Ecore pode simplifcar sua vida. Ecore tem o subsistema Ecore_Con que controla 
toda chatisse de conectar com servidores e de clientes conectados no seu servidor.
</p><p>
Esta receita mostra um exemplo conectando com um outro servidor e 
recebendo alguma informação de volta. Nós iremos conectar com 
o website do enlightement e pegar uma das páginas.
</p><p>
Agora, antes de você ficar confuso. A terminologia Ecore_Con pode semear um
pouco de confusão embaralhando seu cérebro. Quando você está conectando com um
servidor estará trabalhando com as chamadas de servidor do ecore_con. Isto inclue os 
callbacks de servidor.
</p><p>
Lembrando que estou fazendo poucas checagem dos valores retornados neste programa, 
você provavelmente desejará fazer muito mais nos seus programas.
</p><div class="example"><a name="id2537726"></a><p class="title"><b>Exemplo 4.6. Preâmbulo</b></p><pre class="programlisting">
#include &lt;Ecore.h&gt;
#include &lt;Ecore_Con.h&gt;

static int server_add_cb(void *data, int type, void *ev);
static int server_del_cb(void *data, int type, void *ev);
static int server_data_cb(void *data, int type, void *ev);

struct Data {
    char *data;
    int data_size;
};
</pre><p>
Se estiver usando apenas o ecore_con, tudo que você precisa sãos os
headers <tt class="literal">Ecore.h</tt> e <tt class="literal">Ecore_Con.h</tt> 
para funcionar. Temos umas pré-declarações casuais para manter o 
compilador feliz e uma estrutura de dados simples que iremos usar 
em diversos lugares.
</p></div><div class="example"><a name="id2539230"></a><p class="title"><b>Exemplo 4.7. Entendendo a parte de inicialização</b></p><pre class="programlisting">
int
main(int argc, char ** argv)
{
    struct Data gd;
    struct Data *sd;
    Ecore_Con_Server *srv;
    Ecore_Event_Handler *add = NULL, *del = NULL, *data = NULL;

    sd = calloc(1, sizeof(struct Data));
    gd.data = "In the land of the night "
                "the ship of the sun "
                "is drawn by the grateful dead."
                "~ Egyptian book of the Dead";


    ecore_init();
    ecore_con_init();
</pre><p>
Iniciamos algumas declarações no corpo do main do programa. Quando você chama 
o método de conexão do ecore_con, ele irá retornar um <tt class="literal">Ecore_Con_Server *</tt> 
com o qual podemos usar para manipular a conexão se assim desejarmos.
</p><p>
Também estou gardando os <tt class="literal">Ecore_Event_Handler</tt>s que 
vou cirar, para eu mesmo poder liberar os recursos de memória no fim do programa.
</p><p>
A variável <tt class="literal">gd</tt> é meu dado &#8220;<span class="quote">global</span>&#8221;. Ela será 
passada para todas chamadas de cada um dos controladores de evento. A variável 
<tt class="literal">sd</tt> é meu dado &#8220;<span class="quote">local</span>&#8221;. Ela será passada para
o controlador quando este servidor estiver trabalhando.
</p><p>
Mas, antes de partirmos de fato para a diversão, devemos nos certificar 
de inicializar o ecore e ecore_con com as chamadas à 
<tt class="literal">ecore_init()</tt> e <tt class="literal">ecore_con_init()</tt>. 
Como mencionei antes, sempre verifique os valores retornados.
</p></div><div class="example"><a name="id2539339"></a><p class="title"><b>Exemplo 4.8. capturando os eventos</b></p><pre class="programlisting">
    add = ecore_event_handler_add(ECORE_CON_EVENT_SERVER_ADD, 
                                            server_add_cb, &amp;gd);
    del = ecore_event_handler_add(ECORE_CON_EVENT_SERVER_DEL, 
                                            server_del_cb, &amp;gd);
    data = ecore_event_handler_add(ECORE_CON_EVENT_SERVER_DATA, 
                                            server_data_cb, &amp;gd);
</pre><p>
Se nós queremos de fato receber algum evento por qualquer motivo, precisamos
nós mesmos conectá-lo ao sistema de eventos do ecore. Isto é feito por meio 
de chamadas à <tt class="literal">ecore_event_handler_add()</tt>. No caso de conexão
para outro servidor os eventos que estamos interessados são:

</p><div class="variablelist"><dl><dt><span class="term">ECORE_CON_EVENT_SERVER_ADD</span></dt><dd><p>Chamado quando conectamos com um servidor</p></dd><dt><span class="term">ECORE_CON_EVENT_SERVER_DEL</span></dt><dd><p>Chamado quando disconectamos do servidor</p></dd><dt><span class="term">ECORE_CON_EVENT_SERVER_DATA</span></dt><dd><p>Chamado quando temos dados recebidos do servidor</p></dd></dl></div><p>

Para cada uma das chamadas destes controladores, nós passamos a função 
que irá controlar o evento e o dado global <tt class="literal">gd</tt> que criamos acima.
Se não tem qualquer dado pra passar, você pode usar um ponteiro <tt class="literal">NULL</tt>.
</p></div><div class="example"><a name="id2539446"></a><p class="title"><b>Exemplo 4.9. conectando</b></p><pre class="programlisting">
    srv = ecore_con_server_connect(ECORE_CON_REMOTE_SYSTEM, 
                                    "www.enlightenment.org", 80, sd);
</pre><p>
Uma vez que tudo está inicializado, podemos criar uma conexão com o servidor. 
Isto é feito com uma chamada para <tt class="literal">ecore_con_server_connect()</tt>. 
A chamada irá retornar para nós um <tt class="literal">Ecore_Con_Server *</tt> que podemos 
guardar se desejarmos. A chamada de conexão tem quatro parâmetros. O tipo de conexão,
o nome do host, a porta e qualquer dado associado com o servidor.
</p><p>
O tipo de conexão é um dos:
</p><div class="variablelist"><dl><dt><span class="term">ECORE_CON_LOCAL_USER</span></dt><dd><p>Conectará com o servidor que estiver escutando no socket Unix 
 em <tt class="literal">~/.ecore/[name]/[port]</tt></p></dd><dt><span class="term">ECORE_CON_LOCAL_SYSTEM</span></dt><dd><p>Conectará com o servidor que estiver escutando no socket Unix
 em <tt class="literal">/tmp/.ecore_service|[name]|[port]</tt></p></dd><dt><span class="term">ECORE_CON_REMOTE_SYSTEM</span></dt><dd><p>Conectará com o servidor que estiver escutando na porta TCP
 <tt class="literal">[name]:[port]</tt></p></dd><dt><span class="term">ECORE_CON_USE_SSL</span></dt><dd><p>Se a biblioteca foi compilada com suporte à SSL, a conexão 
 será instruída à usar encriptação SSL na transmissão</p></dd></dl></div><p>

O último parâmetro é o dado que é específico (per-server) para cada servidor conectado que queremos passar
para cada controlador de evento. Se você não tem este dado "per-server", então pode passar tranquilamente 
<tt class="literal">NULL</tt> como parâmetro.
</p></div><div class="example"><a name="id2539588"></a><p class="title"><b>Exemplo 4.10. vai speed racer</b></p><pre class="programlisting">
    ecore_main_loop_begin();

    ecore_event_handler_del(add);
    ecore_event_handler_del(del);
    ecore_event_handler_del(data);

    ecore_con_shutdown();
    ecore_shutdown();
    return 0;
}
</pre><p>
Agora que estamos conectado, nós iniciamos o loop principal de evento 
com a <tt class="literal">ecore_main_loop_begin()</tt>. 
Como sou um bom programador, também removo meus controladores de 
eventos quando saímos do loop principal com a <tt class="literal">ecore_event_handler_del()</tt>. 
Depois disto, é muito importante terminar tudo que inicializamos, 
<tt class="literal">ecore_con_shutdown()</tt> e <tt class="literal">ecore_shutdown()</tt> 
fará esta mágica para nós.
</p><p>
Claro, você pode criar sempre suas conexões depois que o loop 
principal de eventos foi inicializado, tudo funcionará do mesmo modo
(você só precisa registrar os controladores de evento uma vez). Só  
estou fazendo isto antes porque é mais fácil para um exemplo.
</p></div><div class="example"><a name="id2539660"></a><p class="title"><b>Exemplo 4.11. adicionado</b></p><pre class="programlisting">
static int
server_add_cb(void *data, int type, void *ev)
{
    Ecore_Con_Event_Server_Add *e;
    struct Data *sd;
    struct Data *gd;
    char buf[1024];

    e = ev;
    gd = data;
    sd = ecore_con_server_data_get(e-&gt;server);

    printf("Connected to server ...\n");

    snprintf(buf, 1024, "GET http://www.enlightenment.org/"
                        "pages/enlightenment.html HTTP/1.0\r\n");
    ecore_con_server_send(e-&gt;server, buf, strlen(buf));

    snprintf(buf, 1024, "\r\n");
    ecore_con_server_send(e-&gt;server, buf, strlen(buf));

    return 1;
}
</pre><p>
Então agora, a controladora para <tt class="literal">ECORE_CON_EVENT_SERVER_ADD</tt>, 
que neste caso é a <tt class="literal">server_add_cb</tt>, irá disparar quando tivermos 
estabelecido uma conexão com um servidor.
</p><p>
O vento add dará informações sobre este evento por intermédio da estrutura 
<tt class="literal">Ecore_Con_Event_Server_Add</tt>. A princípio, estaremos 
interessados no membro <tt class="literal">server</tt> que é o handler do servidor 
que foi retornado na chamada de conexão.
</p><p>
O dado global que passamos no controlador de evento será devolvido 
no parâmetro <tt class="literal">void *data</tt> e o dado "per-server" que 
passamos na chamada  de conexão pode ser obtido com uma chamada para 
a <tt class="literal">ecore_con_server_data_get()</tt>.
</p><p>
Agora que estamos conectado com o servidor, podemos enviar um 
pedido de um documento, que neste caso estou enviando um pedido HTTP. 
O dado é enviado para o servidor chamando a <tt class="literal">ecore_con_server_send()</tt> e 
passando como parâmetros o servidor, o dado e o tamanho do dado.
</p><p>
Certifique-se de retornar 1 para cada um dos seus controladores, pois se você 
retornar 0 o Ecore removerá o controlador e de evento da lista de 
controladores disponíveis.
</p></div><div class="example"><a name="id2539799"></a><p class="title"><b>Exemplo 4.12. removido</b></p><pre class="programlisting">
static int
server_del_cb(void *data, int type, void *ev)
{
    Ecore_Con_Event_Server_Del *e;
    struct Data *sd;
    struct Data *gd;

    e = ev;
    gd = data;
    sd = ecore_con_server_data_get(e-&gt;server);

    ecore_con_server_del(e-&gt;server);

    printf("%s\n\n", gd-&gt;data);
    if (sd-&gt;data) {
        printf("%s\n", sd-&gt;data);
        free(sd-&gt;data);
    }

    ecore_main_loop_quit();
    return 1;
}
</pre><p>
Vamos agora para o controlador <tt class="literal">ECORE_CON_EVENT_SERVER_DEL</tt>.
Ele funciona de forma similar ao controlador add, mas o tipo de evento passado 
é um <tt class="literal">Ecore_Con_Event_Server_Del</tt>.
</p><p>
Agora, o callback del será disparado quando formos disconectado do servidor remoto. Isto significa 
que é nossa responsabilidade remover da memoria o servidor. Isto é feito com a chamada 
à <tt class="literal">ecore_con_server_del()</tt>. Nós, é claro, não precismos fazer isto aqui, 
podemos fazer em qualquer momento quando nos for conveniente.
</p><p>
No caso deste exemplo, já que o servidor fechará a conexão uma vez que a 
pagina web foi retornada, estou fazendo o processamento dos dados no 
controlador del. Como não quero continuar após pegar a pagina chamo 
<tt class="literal">ecore_main_loop_quit()</tt> para parar o loop principal de evento.
</p></div><div class="example"><a name="id2539887"></a><p class="title"><b>Exemplo 4.13. dado</b></p><pre class="programlisting">
static int
server_data_cb(void *data, int type, void *ev)
{
    Ecore_Con_Event_Server_Data *e;
    struct Data *sd;
    struct Data *gd;

    e = ev;
    gd = data;
    sd = ecore_con_server_data_get(e-&gt;server);
   
    sd-&gt;data = realloc(sd-&gt;data, sd-&gt;data_size + e-&gt;size + 1);
    memcpy(sd-&gt;data + sd-&gt;data_size, e-&gt;data, e-&gt;size);
                        
    sd-&gt;data_size += e-&gt;size;
    sd-&gt;data[sd-&gt;data_size] = '\0';
                                
    return 1;
}
</pre><p>
A <tt class="literal">ECORE_CON_EVENT_SERVER_DATA</tt> é também similiar aos 
callbacks add e del. A estrutua de evento desta vez é uma 
<tt class="literal">Ecore_Con_Event_Server_Data</tt> que apresenta para nós 
dois novos membros interessantes, que são: <tt class="literal">size</tt> e 
<tt class="literal">data</tt>. Que nos fornecem o dado recebido do servidor e o tamanho deste dado.
Este dado <span class="emphasis"><em>não</em></span> é terminado com NULL, portanto certifique-se de usar o 
parâmetro <tt class="literal">size</tt>.
</p><p>
No meu caso, só estou guardando o dado na minha estrutura "per-server" 
enquanto pego a desconexão. Você pode, é claro, fazer qualquer 
processamento que deseja aqui.
</p></div><div class="example"><a name="id2539976"></a><p class="title"><b>Exemplo 4.14. compilação</b></p><pre class="screen">
zero@oberon [ecore_con] -&gt; gcc -o srv main.c `ecore-config --cflags --libs`
</pre><p>
Uma vez feito tudo isto, a compilação é a parte simples. O programa pode 
ser executado com o simples comando </p><pre class="screen">./srv</pre><p> e deverá 
imprimir na tela a pagina web selecionada.
</p></div><p>
Ecore_Con torna fácil trabalhar com quaisquer tipos de servidores remotos, seja 
HTTP, IRC ou qualquer um customizado, todas as funcionalidade estão 
encapsuladas e controladas muito bem atravéz do loop de evento Ecore.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2537553"></a>Receita: Introdução a Ecore Ipc</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
A biblioteca Ecore_Ipc provê um "wrapper" robusto e eficiente para o módulo Ecore_Con. 
Ecore_Ipc lhe permite configurar as comunições do seu servidor e controlar todos os 
aspectos internos chatos necessários. Este receita dará um exemplo simples de 
um cliente Ecore e um servidor Ecore.
</p><p>
Quando trabalhamos com Ecore_Ipc, escrevendo uma aplicação cliente ou um servidor, um 
objeto Ecore_Ipc_Server será criado. Porque em qualquer caso há um servidor sendo 
manipulado, para ser inicializado ou para se comunicar. Depois disto, todo o resto é fácil.
</p><div class="example"><a name="id2537584"></a><p class="title"><b>Exemplo 4.15. Cliente Ecore_Ipc: preâmbulo</b></p><pre class="programlisting">
#include &lt;Ecore.h&gt;
#include &lt;Ecore_Ipc.h&gt;

int sig_exit_cb(void *data, int ev_type, void *ev);
int handler_server_add(void *data, int ev_type, void *ev);
int handler_server_del(void *data, int ev_type, void *ev);
int handler_server_data(void *data, int ev_type, void *ev);
</pre></div><p>
O arquivo Ecore.h é incluido para que possamos ter acesso ao tipo de sinal de saída. As funções
serão explicadas mais tarde quando seus callbacks são conectados.
</p><div class="example"><a name="id2537621"></a><p class="title"><b>Exemplo 4.16. Cliente Ecore_Ipc: início do main</b></p><pre class="programlisting">
int main(int argc, char ** argv) {
    Ecore_Ipc_Server *server;

    if (!ecore_init()) {
        printf("unable to init ecore\n");
        return 1;
    }

    if (!ecore_ipc_init()) {
        printf("unable to init ecore_con\n");
        ecore_shutdown();
        return 1;
    }
    ecore_event_handler_add(ECORE_EVENT_SIGNAL_EXIT, sig_exit_cb, NULL);
</pre></div><p>
Como mencionado anteriormente, sempre que estamos escrevendo uma aplicação cliente, também 
usamos um objeto Ecore_Ipc_Server. Usar Ecore_Ipc requer a inicialização de Ecore. Isto se 
faz com uma simples chamada à <tt class="function">ecore_init</tt>. Ecore_Ipc é então iniciado com 
uma chamada à <tt class="function">ecore_ipc_init</tt>. Caso alguma delas devolver 0, é tomada a 
ação apropriada para desfazer qualquer inicialização feita até este momento. O callback
ECORE_EVENT_SIGNAL_EXIT é conectado de modo que podemos sair corretamente se for necessário.
</p><div class="example"><a name="id2541051"></a><p class="title"><b>Exemplo 4.17. Cliente Ecore_Ipc: main criando o cliente</b></p><pre class="programlisting">
    server = ecore_ipc_server_connect(ECORE_IPC_REMOTE_SYSTEM, 
                                        "localhost", 9999, NULL);
    ecore_event_handler_add(ECORE_IPC_EVENT_SERVER_ADD, 
                                        handler_server_add, NULL);
    ecore_event_handler_add(ECORE_IPC_EVENT_SERVER_DEL, 
                                        handler_server_del, NULL);
    ecore_event_handler_add(ECORE_IPC_EVENT_SERVER_DATA, 
                                        handler_server_data, NULL);
</pre></div><p>
Neste exemplo criamos uma conexão remota com o servidor chamado "localhost" na porta 9999. 
Isto é feito com o método <tt class="function">ecore_ipc_server_connect</tt>. O primeiro parâmetro é o tipo 
de conexão que se deseja fazer, podendo ser: ECORE_IPC_REMOTE_SYSTEM, ECORE_IPC_LOCAL_SYSTEM 
ou ECORE_IPC_LOCAL_USER. Se OpenSSL estava disponível quando Ecore_Ipc foi compilado, ECORE_IPC_USE_SSL pode
ser combinado com o tipo de conexão por meio de um OR para criar uma conexão SSL.
</p><p>
As três chamadas à <tt class="function">ecore_event_handler_add</tt> configura os callbacks para os 
diferentes tipos de eventos que receberemos do servidor. Um servidor foi adicionado, um servidor foi eliminado
ou o servidor nos enviou dados.
</p><div class="example"><a name="id2541115"></a><p class="title"><b>Exemplo 4.18. Cliente Ecore_Ipc: final de main</b></p><pre class="programlisting">
    ecore_ipc_server_send(server, 3, 4, 0, 0, 0, "Look ma, no pants", 17);

    ecore_main_loop_begin();

    ecore_ipc_server_del(server);
    ecore_ipc_shutdown();
    ecore_shutdown();
    return 0;
}
</pre></div><p>
Para o propósito deste exemplo, o cliente quando iniciar enviará uma mensagem para o servidor do qual responderá.
A mensagem do cliente é enviando com o comando <tt class="function">ecore_ipc_server_send</tt>. 
Este comando, <tt class="function">ecore_ipc_server_send</tt>, pega o servidor IPC, os opcodes maior e 
menor, os parâmetros ref e ref_to, o response, os dados e o tamanho dos dados. Este parâmetros, exceto 
o servidor IPC, são definidos pelo cliente e podem referir-se a qualquer coisa que se deseja. Isto possibilita dar
máxima flexibilidade na criação de aplicações IPC cliente/servidor.
</p><p>
Depois de enviar a mensagem entramos no lopp principal ecore e esperamos os eventos. Se sairmos do loop, 
apagamos o objeto servidor, finalizamos Ecore_Ipc chamando a <tt class="function">ecore_ipc_shutdown</tt>, e
finalizamos o ecore com <tt class="function">ecore_shutdown</tt>.
</p><div class="example"><a name="id2541191"></a><p class="title"><b>Exemplo 4.19. Cliente Ecore_Ipc: sig_exit_cb</b></p><pre class="programlisting">
int sig_exit_cb(void *data, int ev_type, void *ev) {
    ecore_main_loop_quit();
    return 1;
}
</pre></div><p>
A <tt class="function">sig_exit_cb</tt> simplesmente diz ao ecore para sair do loop principal. Ela não é 
estritamente necessária, se a única coisa que está sendo feito é chamar a <tt class="function">ecore_main_loop_quit()</tt>, 
o Ecore controlará isto por sí próprio se não houver um controlador. Mas isto mostra como um controlador pode ser 
criado se necessitar de um na sua aplicação.
</p><div class="example"><a name="id2541234"></a><p class="title"><b>Exemplo 4.20. Cliente Ecore_Ipc: os callbacks</b></p><pre class="programlisting">
int handler_server_add(void *data, int ev_type, void *ev) {
    Ecore_Ipc_Event_Server_Add *e = (Ecore_Ipc_Event_Server_Add *)ev;
    printf("Got a server add %p\n", e-&gt;server);
    return 1;
}

int handler_server_del(void *data, int ev_type, void *ev) {
    Ecore_Ipc_Event_Server_Del *e = (Ecore_Ipc_Event_Server_Del *)ev;
    printf("Got a server del %p\n", e-&gt;server);
    return 1;
}

int handler_server_data(void *data, int ev_type, void *ev) {
    Ecore_Ipc_Event_Server_Data *e = (Ecore_Ipc_Event_Server_Data *)ev;
    printf("Got server data %p [%i] [%i] [%i] (%s)\n", e-&gt;server, e-&gt;major,
                                e-&gt;minor, e-&gt;size, (char *)e-&gt;data);
    return 1;
}
</pre></div><p>
Este três callbacks, <tt class="function">handler_server_add</tt>, <tt class="function">handler_server_del</tt>, 
e <tt class="function">handler_server_data</tt>, são o corpo do cliente controlando todos os eventos relacionados com 
o servidor que estamos conectados. Cada um destes callbacks tem uma estrutura de evento associada, 
Ecore_Ipc_Event_Server_Add, Ecore_Ipc_Event_Server_Del e Ecore_Ipc_Event_Server_Data, contendo informação
sobre o próprio evento.
</p><p>
Quando conectamos pela primeira vez com o servidor, a função callback <tt class="function">handler_server_add</tt> será
executada permitindo fazer qualquer inicialização.
</p><p>
Se o servidor quebrar a conexão, <tt class="function">handler_server_del</tt> será executada permitindo qualquer limpeza requerida.
</p><p>
Quando o servidor envia dados para o cliente, <tt class="function">handler_server_data</tt> será executada.
Que neste exemplo apenas imprime alguma informação sobre a própria mensagem e seu corpo.
</p><p>
E este é a parte cliente. O código é bastante simples graças as abstrações providas pelo Ecore.
</p><div class="example"><a name="id2541389"></a><p class="title"><b>Exemplo 4.21. Servidor Ecore_Ipc : preâmbulo</b></p><pre class="programlisting">
#include &lt;Ecore.h&gt;
#include &lt;Ecore_Ipc.h&gt;

int sig_exit_cb(void *data, int ev_type, void *ev);
int handler_client_add(void *data, int ev_type, void *ev);
int handler_client_del(void *data, int ev_type, void *ev);
int handler_client_data(void *data, int ev_type, void *ev);
</pre></div><p>
Como no cliente, o header Ecore.h é incluído para ter acesso ao sinal exit. O header
Ecore_Ipc.h é requerido para aplicações que fazem uso a biblioteca Ecore_Ipc. Cada
controlador de sinal será explicado no seu próprio código.
</p><div class="example"><a name="id2541425"></a><p class="title"><b>Exemplo 4.22. Servidor Ecore_Ipc: início de main</b></p><pre class="programlisting">
int main(int argc, char ** argv) { 
    Ecore_Ipc_Server *server;
    
    if (!ecore_init()) {
        printf("Failed to init ecore\n");
        return 1;
    }
    
    if (!ecore_ipc_init()) {
        printf("failed to init ecore_con\n");
        ecore_shutdown();
        return 1;
    }
    
    ecore_event_handler_add(ECORE_EVENT_SIGNAL_EXIT, sig_exit_cb, NULL);
</pre></div><p>
Aqui é igual a inicialização do cliente.
</p><div class="example"><a name="id2541459"></a><p class="title"><b>Exemplo 4.23. Servidor Ecore_Ipc: criando o servidor</b></p><pre class="programlisting">
    server = ecore_ipc_server_add(ECORE_IPC_REMOTE_SYSTEM, "localhost", 9999, NULL);
    ecore_event_handler_add(ECORE_IPC_EVENT_CLIENT_ADD, handler_client_add, NULL);
    ecore_event_handler_add(ECORE_IPC_EVENT_CLIENT_DEL, handler_client_del, NULL);
    ecore_event_handler_add(ECORE_IPC_EVENT_CLIENT_DATA, handler_client_data, NULL);
</pre></div><p>
Diferente do cliente, para o servidor nós adicionamos um listener para a porta 999 na máquina 
"localhost" por meio da chamada a <tt class="function">ecore_ipc_server_add</tt>. Isto criará 
e devolverá o objeto servidor. Então, conectamos os controladores de eventos necessários, a 
diferência com o cliente é que aqui queremos os eventos CLIENT no lugar dos eventos SERVER.
</p><div class="example"><a name="id2541499"></a><p class="title"><b>Exemplo 4.24. Servidor Ecore_Ipc: final de main</b></p><pre class="programlisting">
    ecore_main_loop_begin();

    ecore_ipc_server_del(server);
    ecore_ipc_shutdown();
    ecore_shutdown();
    return 0;
}
</pre></div><p>
Novamente isto é idêntico ao cliente, menos o envio de dados ao servidor.
</p><div class="example"><a name="id2541523"></a><p class="title"><b>Exemplo 4.25. Servidor Ecore_Ipc: callback sig_exit</b></p><pre class="programlisting">
</pre></div><p>
<tt class="function">sig_exit_cb</tt> novamente igual ao que foi visto no cliente.
</p><div class="example"><a name="id2541547"></a><p class="title"><b>Exemplo 4.26. Servidor Ecore_Ipc: os callbacks</b></p><pre class="programlisting">
int handler_client_add(void *data, int ev_type, void *ev) {
    Ecore_Ipc_Event_Client_Add *e = (Ecore_Ipc_Event_Client_Add *)ev;
    printf("client %p connected to server\n", e-&gt;client);
    return 1;
}

int handler_client_del(void *data, int ev_type, void *ev) {
    Ecore_Ipc_Event_Client_Del *e = (Ecore_Ipc_Event_Client_Del *)ev;
    printf("client %p disconnected from server\n", e-&gt;client);
    return 1;
}

int handler_client_data(void *data, int ev_type, void *ev) {
    Ecore_Ipc_Event_Client_Data *e = (Ecore_Ipc_Event_Client_Data *)ev;
    printf("client %p sent [%i] [%i] [%i] (%s)\n", e-&gt;client, e-&gt;major,
                                e-&gt;minor, e-&gt;size, (char *)e-&gt;data);
    
    ecore_ipc_client_send(e-&gt;client, 3, 4, 0, 0, 0, "Pants On!", 9);
    return 1;
}
</pre></div><p>
Os callbacks de evento são similiares aos vistos na aplicação cliente. A principal diferência 
é que estes são eventos _Client_ em vez de eventos _Server_.
</p><p>
O callback add é quando um cliente se coencta ao nosso servidor, o callback del, em 
oposição, é quando o cliente se desconecta. O callback data é para quando um cliente 
envia dados para o servidor.
</p><p>
Ao final do callback <tt class="function">handler_client_data</tt> fazemos uma chamada a 
<tt class="function">ecore_ipc_client_send</tt>. Isto envia os dados ao cliente. Como no
envio de dados ao servidor, os parâmetros são: o cliente que receberá os dados, os 
opcodes maior e menor, ref, ref_to, response, os dados e o tamanho dos dados.
</p><div class="example"><a name="id2541624"></a><p class="title"><b>Exemplo 4.27. Ecore_Ipc: compilação</b></p><pre class="programlisting">
CC = gcc
    
all: server client

server: server.c
    $(CC) -o server server.c `ecore-config --cflags --libs`
    
client: client.c
    $(CC) -o client client.c `ecore-config --cflags --libs`

clean:
    rm server client
</pre></div><p>
Como em outras aplicações ecore, é muito fácil compilar uma aplicação Ecore_Ipc. Se 
sua biblioteca ecore foi compilada com suporte a Ecore_Ipc, simplesmente invocando o 
comando 'ecore-config --cflags --libs' adicionará todos os caminhos das bibliotecas 
requeridas e as informações de linkagem.
</p><p>
Como foi visto neste exemplo, Ecore_Ipc é uma biblioteca fácil de usar para criar aplicações cliente/servidor.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2542355"></a>Receita: Temporizadores Ecore</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Se você precisa que um callback seja disparado num determinado momento com a 
possibilidade de repetir o temporizador continuamente, então <tt class="literal">Ecore_Timer</tt> 
é o que você procura.
</p><p>
</p><div class="example"><a name="id2542377"></a><p class="title"><b>Exemplo 4.28. Temporizadores Ecore</b></p><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;Ecore.h&gt;

static int timer_one_cb(void *data);
static int timer_two_cb(void *data);

int main(int argc, char ** argv) {
    ecore_init();

    ecore_timer_add(1, timer_one_cb, NULL);
    ecore_timer_add(0.5, timer_two_cb, NULL);

    ecore_main_loop_begin();
    ecore_shutdown();

    return 0;
}

static int timer_one_cb(void *data) {
    printf("1");
    fflush(stdout);
    return 1;
}

static int timer_two_cb(void *data) {
    printf("2");
    fflush(stdout);
    return 1;
}
</pre></div><p>
</p><p>
A criação dos temporizadores é simples bastando chamar <tt class="function">ecore_timer_add()</tt>.
Isto retornará uma estrutura <tt class="literal">Ecore_Timer</tt> ou NULL se a chamada falhar. Neste 
caso eu estou ignorando o valor de retorno. Os três parâmetros são:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>double timeout</p></li><li style="list-style-type: disc"><p>int (*callback)(void *data)</p></li><li style="list-style-type: disc"><p>const void *user_data</p></li></ul></div><p>
</p><p>
O parâmetro timeout dá o número de segundos que expirará o temporizador. No caso do exemplo, demos 
1 segundo e 0.5 segundos respectivamente. A função callback é a que será executada quando o 
temporizador expirar e user_data é qualquer dado para ser passado para a função callback.
</p><p>
As funções callback tem a mesma assinatura <tt class="literal">int callback(void *data)</tt>. O 
valor de retorno do temporizador deve ser 0 ou 1. Se você retornar 0 o temporizador expirará e 
<span class="emphasis"><em>não</em></span> será executado novamente. Se você retornar 1, o temporizador será 
re-agendado para se executar novamanete após o fim do tempo dado pelo parâmetro 
timeout. Isto permite que você ative ou continue com o temporizador do jeito que 
necessitar seu programa.
</p><p>
Se você tem um temporizador que deseja remover em um determinado momento basta 
chamar <tt class="function">ecore_timer_del(Ecore_Timer *)</tt>. Se a eliminação for 
bem sucedida o ponteiro será retornado, caso contrário será retornado NULL. 
Depois disto a estrutura <tt class="literal">Ecore_Timer</tt> será invalidada e você não 
poderá mais usar novamente no seu programa.
</p><p>
Compilar o exemplo é bem simples:
</p><div class="example"><a name="id2542517"></a><p class="title"><b>Exemplo 4.29. Compilação</b></p><pre class="screen">
gcc -Wall -o etimer etimer.c `ecore-config --cflags --libs`
</pre></div><p>
Se você executar o programa deverá ver uma série de '1's e '2's na tela com duas vezes mais '2's que '1's.
</p><p>
Os temporizadores <tt class="literal">Ecore_Timer</tt> são fáceis de usar provendo um potente mecanismo de temporização para seus programas.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2540983"></a>Receita: Adicionando eventos Ecore</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Se você sempre precisa fazer seus próprios eventos você pode 
facilmente conecta-los no sistema de eventos Ecore. Ele dá a 
você a capacidade de adicionar eventos dentro de uma fila de 
eventos e ter o Ecore para remete-lo para outra parte da aplicação.
</p><p>
O seguinte programa cria um simples evento e temporizador. Quando o 
temporizador dispara ele irá adicionar seu novo evento dentro de 
uma fila de eventos. Então seu evento irá imprimir uma mensagem e 
terminará a aplicação 
</p><div class="example"><a name="id2540678"></a><p class="title"><b>Exemplo 4.30. Exemplo de evento Ecore</b></p><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;Ecore.h&gt;

static int timer_cb(void *data);
static int event_cb(void *data, int type, void *ev);
static void event_free(void *data, void *ev);

int MY_EVENT_TYPE = 0;

typedef struct Event_Struct Event_Struct;
struct Event_Struct {
    char *name;
};

int
main(int argc, char ** argv)
{
    ecore_init();

    MY_EVENT_TYPE = ecore_event_type_new();
    ecore_event_handler_add(MY_EVENT_TYPE, event_cb, NULL);
    ecore_timer_add(1, timer_cb, NULL);

    ecore_main_loop_begin();
    ecore_shutdown();
    return 0;
}

static int
timer_cb(void *data)
{
    Event_Struct *e;
    Ecore_Event *event;

    e = malloc(sizeof(Event_Struct));
    e-&gt;name = strdup("ned");

    event = ecore_event_add(MY_EVENT_TYPE, e, event_free, NULL);
    return 0;
}

static int
event_cb(void *data, int type, void *ev)
{
    Event_Struct *e;

    e = ev;
    printf("Got event %s\n", e-&gt;name);
    ecore_main_loop_quit();
    return 1;
}

static void
event_free(void *data, void *ev)
{
    Event_Struct *e;

    e = ev;
    free(e-&gt;name);
    free(e);
}
</pre><p>
Cada evento tem um id de evento associado. Este id é simplesmente 
um valor inteiro que é fornecido quando se chama <tt class="literal">ecore_event_type_new()</tt>. 
Uma vez que nós temos o id de evento podemos usá-lo nas chamadas 
<tt class="literal">ecore_event_handler_add()</tt>. Isto é tudo o que precisa para criar o evento.
</p><p>
Ecore nos dá a capacidade de passar uma estrutura de evento para nosso 
evento. Só que você precisa ter cuidado, se você não especificar uma função 
para liberar a memória (free function) usada pela estrutura, a ecore irá usar 
uma função genérica que apenas chama <tt class="literal">free</tt> pro valor. Então, 
não coloque nada na estrutura que você precise sem tomar cuidado. (Ou prepare-se
para uma enxurrada de SEGV's muito estranhas no seu programa)
</p><p>
Neste exemplo nós criamos uma simples <tt class="literal">Event_Struct</tt> que é passado.
A chamada que de fato cria o evento é <tt class="literal">ecore_event_add()</tt>. Que recebe 
o id de evento, o dado de evento, a "free function" e qualquer dado para passar 
para a "free function".
</p><p>
Como você pode ver, nós passamos nossa <tt class="literal">Event_Struct</tt> como um
dado de evento e informamos a função <tt class="literal">event_free</tt> como a 
"free function" que se encarregará de limpar da memória a estrutura.
</p></div><p>
E é isto. Você pode compilar como descrito abaixo e tudo deve funcionar.
</p><div class="example"><a name="id2542263"></a><p class="title"><b>Exemplo 4.31. </b></p><pre class="screen">
zero@oberon [ecore_event] -&gt; gcc -o ev main.c `ecore-config --cflags --libs`
</pre></div><p>
Como visto, é realmente muito fácil extender o Ecore com seus próprios eventos. 
O sistema foi configurado para permitir ser extendido como desejado.
</p></div></div><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a name="id2544619"></a>Capítulo 5. EDB &amp; EET</h2></div></div><div></div></div><div class="toc"><p><b>Índice</b></p><dl><dt><a href="#id2546029">Receita: Criando arquivos EDBs pelo shell</a></dt><dt><a href="#id2545950">Recetta: Introdução ao EDB</a></dt><dt><a href="#id2546428">Receita: Recuperação de chave EDB</a></dt></dl></div><p>
EDB é uma biblioteca de conveniência de base 
de dados envolvendo o Berkeley DB 2.7.7 da 
Sleepycat Software. Seu propósito é fazer de 
forma fácil, rápido, eficente e portável o 
acesso as informações da base de dados.
</p><p>
EET é uma pequena biblioteca desenhada para escrever 
pedaçoes arbitrários de dados em um arquivo, opcionalmente 
compactá-los (muito semelhante a um arquivo zip) e permitir 
uma leitura veloz para acesso aleatório mais tarde. EET não 
faz zip, dado que um zip tem mais complexidade que o necessário, 
e foi mais simples implementar isto uma vez aqui.
</p><p>
EDB fornece um método excelente de armazenar e recuperar 
informações de configuração de aplicação, contudo 
pode ser usado de uma maneira mais extensíva que esta. Ebits,
o predecessor da Edje, usava EDB como container para temas 
Ebit antes da EET. Uma Edb consiste em uma série de pares 
valor/chave, que pode consistir numa variedade de tipos de 
dados, incluindo inteiros, valores de ponto flutuante, 
strings e dados binários. A API simplificada provê funções 
simples, completas e unificadas para gerenciar e acessar 
seu banco de dados.
</p><p>
Em adição à biblioteca, há disponível uma variedade 
de ferramentas para acessar e modificar seus EDBs.
O edb_ed fornece uma simples interface de linha de comando 
que pode ser fácilmente usada em scripts, especialmente 
útil para uso com o GNU autotools. O edb_vt_ed fornece uma 
inferface ncurses fácil de usar. Finalmente, edb_gtk_ed 
fornece uma elegante e fácil interface GUI, especialmente 
útil para o usuário final editar os dados contidos nos EDBs.
</p><p>
Eet é extremamente rápida, pequena e simples. Os arquivos 
Eet podem ser pequenos e altamente compactados, tornando-os 
ótimos para enviar pela internet sem ter que arquivar, 
compactar ou descompcatar, e instalá-los. Permitem leituras 
velozes de acesso aleatórios como um ráio uma vez criados, 
fazendo-os perfeitos para armazenar dados que são escritos 
uma vez (ou raramente) e lidos muitas vezes, mas o programa 
não quer ter que lê-lo todas as vezes.
</p><p>
Também pode codificar e descodificar estruturas de dados 
na memória, bem como dados de imagem para gravar em arquivos 
Eet ou enviar pela rede à outras máquinas, ou apenas escrever 
arquivos arbitrário no sistema. Todos os dados codificados são 
independente da plataforma podendo ser lidos e escritos em 
qualquer arquitetura.
</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2546029"></a>Receita: Criando arquivos EDBs pelo shell</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Muitas vezes é desejado criar arqiuvos EDB por intermédio de 
um simples script shell. Para então ser parte do processo de construção.
</p><p>
Isto pode ser facilmente implementado usando o programa <b class="command">edb_ed</b>.
<b class="command">edb_ed</b> é uma interface muito simples para EDB, permitindo 
criar/editar/apagar pares chave/valor dentro da base de dados EDB.
</p><div class="example"><a name="id2546065"></a><p class="title"><b>Exemplo 5.1. Arquivo de escript shell de comandos EDB</b></p><pre class="programlisting">
#!/bin/sh

DB=out.db

edb_ed $DB add /global/debug_lvl int 2
edb_ed $DB add /foo/theme str "default"
edb_ed $DB add /bar/number_of_accounts int 1
edb_ed $DB add /nan/another float 2.3
</pre></div><p>
Se o arquivo de output não existe na primeira chamada ao comando <tt class="function">add</tt>,
então <b class="command">edb_ed</b> criará o arquivo e fará qualquer inicialização necessária.
A <tt class="function">add</tt> é usada para adicionar entradas na base de dados. O primeiro parâmetro depois de add
é a chave que os dados serão inseridos na base de dados. Esta chave será usada no futuro para atualizar os 
dados pela sua aplicação. O próximo parâmetro é o tipo do dado que será adicionado. Que pode ser:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>int</p></li><li style="list-style-type: disc"><p>str</p></li><li style="list-style-type: disc"><p>float</p></li><li style="list-style-type: disc"><p>data</p></li></ul></div><p>
O último parâmetro é o valor que será associado com esta chave.
</p><p>
Usando o <b class="command">edb_ed</b> você pode criar/editar/visualizar qualquer arquivo 
EDB requerido pela sua aplicação de maneira fácil e rápida.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2545950"></a>Recetta: Introdução ao EDB</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
EDB fornece um potente backend de base de dados para usar nas suas aplicações. 
Esta receita é uma simples introdução que abrirá um banco de dados, 
escreverá várias chaves e depois lerá os dados.
</p><p>
</p><div class="example"><a name="id2545968"></a><p class="title"><b>Exemplo 5.2. Introdução ao EDB</b></p><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;Edb.h&gt;

#define INT_KEY     "/int/val"
#define STR_KEY     "/str/val"
#define FLT_KEY     "/float/val"

int main(int argc, char ** argv) {
    E_DB_File *db_file = NULL;
    char *str;
    int i;
    float f;

    if (argc &lt; 2) {
        printf("Need db file\n");
        return 0;
    }

    db_file = e_db_open(argv[1]);
    if (db_file == NULL) {
        printf("Error opening db file (%s)\n", argv[1]);
        return 0;
    }

    printf("Adding values...\n");
    e_db_int_set(db_file, INT_KEY, 42);
    e_db_float_set(db_file, FLT_KEY, 3.14159);
    e_db_str_set(db_file, STR_KEY, "My cats breath smells like...");

    printf("Reading values...\n");
    if (e_db_int_get(db_file, INT_KEY, &amp;i))
        printf("Retrieved (%s) with value (%d)\n", INT_KEY, i);

    if (e_db_float_get(db_file, FLT_KEY, &amp;f))
        printf("Retrieved (%s) with value (%f)\n", FLT_KEY, f);

    if ((str = e_db_str_get(db_file, STR_KEY)) != NULL) {
        printf("Retrieved (%s) with value (%s)\n", STR_KEY, str);
        free(str);
    }

    e_db_close(db_file);
    e_db_flush();

    return 1;
}
</pre></div><p>
</p><p>
Para usar o EDB você deve incluir o &lt;Edb.h&gt; no seu arquivo para ter acesso a API. A parte 
inicial do programa é bastante padrão, tenho a tendência de digitar errado enquanto defino
as diferentes chaves que irei usar. Enquanto temos o nome do arquivo tentaremos 
abrir/criar a base de dados.
</p><p>
A base de dados será aberta ou, se não existir, será criada com a chamada à <tt class="function">e_db_open()</tt>  que 
devolverá NULL se ocorreu um erro.
</p><p>
Uma vez aberta, podemos escrever nossos valores. Isto é feito por meio das 
três chamadas: <tt class="function">e_db_int_set()</tt>, <tt class="function">e_db_float_set()</tt> e 
<tt class="function">e_db_str_set()</tt>. Você também pode inserir dados genéricos dentro do arquivo .db 
com  <tt class="function">e_db_data_set()</tt>.
</p><p>
Junto com dados normais, você pode guardar metadados sobre a base de dados no próprio arquivo.
Eles não podem ser recuperados com os métodos tradicionais get/set. Estas 
propriedade são tratadas com <tt class="function">e_db_property_set()</tt>
</p><p>
Cada um dos métodos de atribuição de tipo (get/set) usa três parâmetros:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>E_DB_File *db</p></li><li style="list-style-type: disc"><p>char *key</p></li><li style="list-style-type: disc"><p>value</p></li></ul></div><p>
O parâmetro <tt class="literal">value</tt> é do tipo correspondente do metódo, int, float, char * ou void * para _int_set, 
_float_set, _str_set e _data_set respectivamente.
</p><p>
Uma vez que os valores estão na base de dados, eles podem ser recuperados com os métodos de acesso.
Cada um destes métodos usa três parâmetros e retorna um int. O valor de retorno é 1 em caso de 
sucesso e 0 caso contrário.
</p><p>
Como nos métodos de atribuição, os parâmetros dos métodos de acesso são o db, a chave e um 
ponteiro para o valor recuperado.
</p><p>
Quando terminamos com a base de dados podemos fecha-la com uma chamada à
<tt class="function">e_db_close()</tt>. A chamada à <tt class="function">e_db_close()</tt> não dá 
garantia que os dados foram escritos no disco, para isto chamamos <tt class="function">e_db_flush()</tt> 
que escreverá o conteúdo da base de dados no disco.
</p><p>
</p><div class="example"><a name="id2546643"></a><p class="title"><b>Exemplo 5.3. Compilando</b></p><pre class="screen">
zero@oberon [edb] -&gt; gcc -o edb edb_ex.c \
	`edb-config --cflags --libs`
</pre></div><p>
Se você executar o programa deverá ver os valores na tela, depois da execução haverá um 
arquivo .db com o nome que você especificou. Você pode dar uma olhada no arquivo .db com 
o <b class="command">edb_gtk_ed</b> e ver os valores entrados.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2546428"></a>Receita: Recuperação de chave EDB</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
A API EDB faz da recuperação de todas as chaves disponíveis na base de dados uma tarefa simples. 
Estas chaves podem então ser usadas para determinar os tipos de objetos na base de dados, ou simplesmente para
recuperar o objeto.
</p><p>
</p><div class="example"><a name="id2545709"></a><p class="title"><b>Exemplo 5.4. recuperação de chaves EDB</b></p><pre class="programlisting">
#include &lt;Edb.h&gt;

int main(int argc, char ** argv) {
    char ** keys;
    int num_keys, i;

    if (argc &lt; 2) 
        return 0;

    keys = e_db_dump_key_list(argv[1], &amp;num_keys);
    for(i = 0; i &lt; num_keys; i++) {
        printf("key: %s\n", keys[i]);
        free(keys[i]); 
    }
    free(keys);
    return 1;
}
</pre></div><p>
Recuperação de chaves se faz simplesmente por meio da chamada à 
<tt class="function">e_db_dump_key_list()</tt>. Que devolverá um array do tipo string (char**) contendo as chaves.
Estas strings, e o próprio array, devem ser removidos da memória pela aplicação. 
<tt class="function">e_db_dump_key_list()</tt> devolverá também o número de chaves contidas no array 
pelo parâmetro <tt class="literal">num_keys</tt>.
</p><p>
Você notará que não precisamos abrir a base de dados para chamar a <tt class="function">e_db_dump_key_list()</tt>.
Esta função trabalha com o arquivo em si no lugar de um objeto db.
</p><p>
</p><div class="example"><a name="id2545782"></a><p class="title"><b>Exemplo 5.5. Compilação</b></p><pre class="screen">
zero@oberon [edb] -&gt; gcc -o edb edb_ex.c \
	`edb-config --cflags --libs`
</pre></div><p>
Executando o programa deverá produzir uma lista de todas as chaves obtidas da base de dados. Isto
pode ser verificado olhando a base de dados por meio de uma ferramente externa como <b class="command">edb_gtk_ed</b>.
</p></div></div><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a name="id2545702"></a>Capítulo 6. Esmart</h2></div></div><div></div></div><div class="toc"><p><b>Índice</b></p><dl><dt><a href="#id2545692">Receita: Indrodução ao Esmart Trans</a></dt><dt><a href="#id2547931">Receta: Introdução ao Container Esmart</a></dt></dl></div><p>
Esmart fornece uma variedade de objetos inteligentes EVAS que dá uma potência significativa em suas aplicações baseadas no EVAS e EFL.
</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2545692"></a>Receita: Indrodução ao Esmart Trans</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Transparência está se tornando cada vez mais uma peculiaridade comum nas aplicações. Para este fim, o
objeto Esmart_Trans foi criado. Este objeto fará todo o trabalho difícil de se produzir  um fundo 
transparente para seus programa.
</p><p>
Esmart_Trans faz a integração do fundo transparente na sua aplicação muito fácil. Você precisa criar o 
objeto trans, e então certificar-se de atualiza-lo conforme a janela vai sendo movida ou redimensionada.
</p><div class="example"><a name="id2548017"></a><p class="title"><b>Exemplo 6.1. Declarações e Inclusões</b></p><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;Ecore.h&gt;
#include &lt;Ecore_Evas.h&gt;
#include &lt;Esmart/Esmart_Trans_X11.h&gt;

int sig_exit_cb(void *data, int ev_type, void *ev);
void win_del_cb(Ecore_Evas *ee);
void win_resize_cb(Ecore_Evas *ee);
void win_move_cb(Ecore_Evas *ee);

static void _freshen_trans(Ecore_Evas *ee);
void make_gui();
</pre></div><p>
Cada aplicação que usa um objeto Esmart_Trans precisa do Ecore, Ecore_Evas, e os arquivos headers 
das Esmart/Esmart_Trans.

A próximas quatro declarações são callbacks do ecore para eventos para nossa janela, saída, remoção, 
redimencionamento e movimento respectivamente.

As últimas declarações são funções utilitárias que são usadas no exemplo e não necessitam estar no 
seu programa.
</p><div class="example"><a name="id2548060"></a><p class="title"><b>Exemplo 6.2. main</b></p><pre class="programlisting">
int main(int argc, char ** argv) {
    int ret = 0;
        
    if (!ecore_init()) {
        printf("Error initializing ecore\n");
        ret = 1;
        goto ECORE_SHUTDOWN;
    }

    if (!ecore_evas_init()) {
        printf("Error initializing ecore_evas\n");
        ret = 1;
        goto ECORE_SHUTDOWN;
    }
    make_gui();
    ecore_main_loop_begin();
        
    ecore_evas_shutdown();

ECORE_SHUTDOWN:
    ecore_shutdown();
                
    return ret;
}
</pre></div><p>
A rotina principal para este programa é bem simples. Ecore e Ecore_Evas são ambas inicializadas com 
as devidas checagem de erros. Então criamos a gui e iniciamos o loop principal de evento ecore.
Quando o ecore sai encerramos tudo e retornamos.
</p><div class="example"><a name="id2548105"></a><p class="title"><b>Exemplo 6.3. callbacks de saída e remoção</b></p><pre class="programlisting">
int sig_exit_cb(void *data, int ev_type, void *ev) {
    ecore_main_loop_quit();
    return 1;
}

void win_del_cb(Ecore_Evas *ee) {
    ecore_main_loop_quit();
}
</pre></div><p>
Os callbacks de saída e remoção são os callbacks ecore genéricos. O callback de saída não é estritamente necessário,
já que o Ecore  irá chamar a <tt class="function">ecore_main_loop_quit()</tt> se não houver nenhum controlador registrado,
mas está incluído pra mostrar como isto é feito.
</p><div class="example"><a name="id2548140"></a><p class="title"><b>Exemplo 6.4. _freshen_trans</b></p><pre class="programlisting">
static void _freshen_trans(Ecore_Evas *ee) {
    int x, y, w, h;
    Evas_Object *o;

    if (!ee) return;

    ecore_evas_geometry_get(ee, &amp;x, &amp;y, &amp;w, &amp;h);
    o = evas_object_name_find(ecore_evas_get(ee), "bg");

    if (!o) {
        fprintf(stderr, "Trans object not found, bad, very bad\n");
        ecore_main_loop_quit();
    }
    esmart_trans_x11_freshen(o, x, y, w, h);
}
</pre></div><p>
A rotina <tt class="function">_freshen_trans</tt> é uma função de ajuda para atualizar a imagem que a transpaência se mostra.
Está será chamada quando precisamos atualizar nossa imagem da qual atualmente está em baixo.

A função captura o tamanho atual do ecore_evas, e então adquire o objeto com o nome "bg"
( este nome é o mesmo que damos a nossa trans quando a criamos ). Então, desde que o objeto exista,  pedimos para
a esmart atualizar a imagem sendo mostrada.
</p><div class="example"><a name="id2548190"></a><p class="title"><b>Exemplo 6.5. resize_cb</b></p><pre class="programlisting">
void win_resize_cb(Ecore_Evas *ee) {
    int w, h;
    int minw, minh;
    int maxw, maxh;
    Evas_Object *o = NULL;

    if (ee) {
        ecore_evas_geometry_get(ee, NULL, NULL, &amp;w, &amp;h);
        ecore_evas_size_min_get(ee, &amp;minw, &amp;minh);
        ecore_evas_size_max_get(ee, &amp;maxw, &amp;maxh);

        if ((w &gt;= minw) &amp;&amp; (h &gt;= minh) &amp;&amp; (h &lt;= maxh) &amp;&amp; (w &lt;= maxw)) {
            if ((o = evas_object_name_find(ecore_evas_get(ee), "bg")))
                evas_object_resize(o, w, h);
        }
    }
    _freshen_trans(ee);
}
</pre></div><p>
Quando a janela for redimensionada precisamos atualizar nosso evas para o tamanho correto e então
atualizar o objeto trans para mostrar a parte do background.

Capturamos o tamanho atual da janela com <tt class="function">ecore_evas_geometry_get</tt> e também o tamanho máximo e mínimo da janela. 
Com o tamanho desejado, o tamanho basea-se entre os limites mínimo e máximo da janela, capturamos o objeto "bg"
( novamente o mesmo do título ) e o redimensionamos.

Uma vez feito o redimensionamento, chamamos a rotina <tt class="function">_freshen_trans</tt> para atualizar a imagem mostrada no bg.
</p><div class="example"><a name="id2548242"></a><p class="title"><b>Exemplo 6.6. move_cb</b></p><pre class="programlisting">
void win_move_cb(Ecore_Evas *ee) {
    _freshen_trans(ee);
}
</pre></div><p>
Quando a janela é movimentada precisamos autalizar a imagem mostrada como transparência.
</p><div class="example"><a name="id2548264"></a><p class="title"><b>Exemplo 6.7. Iniciar ecore/ecore_evas</b></p><pre class="programlisting">
void make_gui() {
    Evas *evas = NULL;
    Ecore_Evas *ee = NULL;
    Evas_Object *trans = NULL;
    int x, y, w, h;

    ecore_event_handler_add(ECORE_EVENT_SIGNAL_EXIT, sig_exit_cb, NULL);

    ee = ecore_evas_software_x11_new(NULL, 0, 0, 0, 300, 200);
    ecore_evas_title_set(ee, "trans demo");

    ecore_evas_callback_delete_request_set(ee, win_del_cb);
    ecore_evas_callback_resize_set(ee, win_resize_cb);
    ecore_evas_callback_move_set(ee, win_move_cb);

    evas = ecore_evas_get(ee);
</pre></div><p>
A primeira parte da make_gui se encarrega de iniciar a ecore e a ecore_evas. Primeiro o callback de saída é conectado 
ao ECORE_EVENT_SIGNAL_EXIT, então o objeto Ecore_Evas é criado com o motor do X11. Se inicia o título da janela e conectamos os 
callbacks escrios acima, delete, resize e move.
Finalmente capturamos a evas para o Ecore_Evas criado.
</p><div class="example"><a name="id2548311"></a><p class="title"><b>Exemplo 6.8. Criando o objeto Esmart_Trans</b></p><pre class="programlisting">
    trans = esmart_trans_x11_new(evas);
    evas_object_move(trans, 0, 0);
    evas_object_layer_set(trans, -5);
    evas_object_name_set(trans, "bg");

    ecore_evas_geometry_get(ee, &amp;x, &amp;y, &amp;w, &amp;h);
    evas_object_resize(trans, w, h);

    evas_object_show(trans);
    ecore_evas_show(ee);

    esmart_trans_x11_freshen(trans, x, y, w, h);
}
</pre></div><p>
Uma vez que tudo esteja iniciado podemos criar o objeto trans. O trans é criado no evas devolvido pela 
<tt class="function">ecore_evas_get</tt>. Esta criação inicial  é feita mediante a chamada à <tt class="function">esmart_trans_x11_new</tt>.
Uma vez com o objeto, o movemos de maneira que ele incie na posição( 0, 0 ) ( o canto superior esquerdo ), ajustamos
a camada para -5 e chamamos o objeto "bg" ( como usamos acima ).

Então capturamos o tamanho atual do ecore_evas e o usamos para redimensionar o objeto trans para o tamanho da janela.
Quando tudo estiver redimensionado mostramos o trans e o ecore_evas.

Como passo final, atualizamos a imagem na transparência da imagem que está atualmente em baixo da janela da forma como está.
</p><div class="example"><a name="id2548376"></a><p class="title"><b>Exemplo 6.9. makefile sencilla</b></p><pre class="programlisting">
CFLAGS = `ecore-config --cflags` `evas-config --cflags` `esmart-config --cflags`
LIBS = `ecore-config --libs` `evas-config --libs` `esmart-config --libs` \
            -lesmart_trans_x11

all:
    gcc -o trans_example trans_example.c $(CFLAGS) $(LIBS)
</pre></div><p>
Para compilar o programa acima precisamos incluir a informação de biblioteca para ecore, ecore_evas e esmart.
Isto é feito por meio dos escripts -config para cada biblioteca. Estes escripts -config sabem onde estão 
cada um dos includes e das bibliotecas iniciando os caminhos (paths) de include e os parâmetros de 
linkagem apropriados para a compilação.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2547931"></a>Receta: Introdução ao Container Esmart</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Geralmente ao desenhar a UI de uma aplicação há um desejo de agrupar os elementos comuns juntos e fazer com que seu layout
dependa um do outro. Para este fim a biblioteca de Container Esmart foi criada. Ela foi projetada para contolar a parte difícil
de layout, e em casos onde ela não faz o que você precisa, as porções de layout do container são extensíveis e modificáveis.
</p><p>
Esta receita dará a base para usar um container Esmart. O produto final é um programa que te permitirá ver algumas
das diferentes combinações de layout do container default. O layout será feito pelo Edje com callbacks para o programa
mudar o layout do container e para informar se o usuário clicou em um elemento do container.
</p><div class="example"><a name="id2547175"></a><p class="title"><b>Exemplo 6.10. Includes e declarações</b></p><pre class="programlisting">
#include &lt;Ecore.h&gt;
#include &lt;Ecore_Evas.h&gt;
#include &lt;Edje.h&gt;
#include &lt;Esmart/Esmart_Container.h&gt;
#include &lt;getopt.h&gt;

static void make_gui(const char *theme);
static void container_build(int align, int direction, int fill);
static void _set_text(int align, int direction);
static void _setup_edje_callbacks(Evas_Object *o);
static void _right_click_cb(void* data, Evas_Object* o, const char* emmission,
                                                            const char* source);
static void _left_click_cb(void* data, Evas_Object* o, const char* emmission,
                                                            const char* source);
static void _item_selected(void* data, Evas_Object* o, const char* emmission,
                                                            const char* source);

static Ecore_Evas *ee;
static Evas_Object *edje;
static Evas_Object *container;

char *str_list[] = {"item 1", "item 2",
                    "item 3", "item 4",
                    "item 5"};
</pre></div><p>
Como nos outros programas EFL precisamos incluir Ecore, Ecore_Evas, Edje e como este é um exemplo de container,
o cabeçalho do Esmart/Esmart_Container. Getopt será usado para permiir algum processo de linha de comando.
</p><p>
Depois vem os protótipos de funções que serão descritos mais tarde quando chegarmos às suas respectivas implementações.
Depois, algumas variáveis globais que serão usadas durante o programa. O array str_list é o conteúdo a ser ordenado no
container.
</p><div class="example"><a name="id2549006"></a><p class="title"><b>Exemplo 6.11. main</b></p><pre class="programlisting">
int main(int argc, char ** argv) {
    int align = 0;
    int direction = 0;
    int fill = 0;
    int ret = 0;
    int c;
    char *theme = NULL;

    while((c = getopt(argc, argv, "a:d:f:t:")) != -1) {
        switch(c) {
            case 'a':
                align = atoi(optarg);
                break;

            case 'd':
                direction = atoi(optarg);
                break;

            case 'f':
                fill = atoi(optarg);
                break;

            case 't':
                theme = strdup(optarg);
                break;

            default:
                printf("Unknown option string\n");
                break;
        }
    }

    if (theme == NULL) {
        printf("Need a theme defined\n");
        exit(-1);
    }
</pre></div><p>
O inicio da função main pega as opções de linha comando e inicia a janela principal. Como você pode ver, solicitamos
um tema para mostrar. Isto pode ser mais inteligente pocurando no diretório default de instalação e no diretório
de aplicações do usuário, mas este exemplo prefere o modo mais fácil e força que o tema seja passado como argumento de linha de comando.
</p><div class="example"><a name="id2549046"></a><p class="title"><b>Exemplo 6.12. Inicialização</b></p><pre class="programlisting">
    if (!ecore_init()) {
        printf("Can't init ecore, bad\n");
        ret = 1;
        goto EXIT;
    }
    ecore_app_args_set(argc, (const char **)argv);
    
    if (!ecore_evas_init()) { 
        printf("Can't init ecore_evas, bad\n");
        ret = 1;
        goto EXIT_ECORE;
    }
    
    if (!edje_init()) {
        printf("Can't init edje, bad\n");
        ret = 1;
        goto EXIT_ECORE_EVAS;
    }
    edje_frametime_set(1.0 / 60.0);
    
    make_gui(theme);
    container_build(align, direction, fill);
    
    ecore_main_loop_begin();
</pre></div><p>
Depois de receber os argumentos de linha de comando, continuamos por inicializar as bibliotecas requeridas, Ecore,
Ecore_Evas e Edje. Tomamos o passo adicional de iniciar o frame rate do Edje.
</p><p>
Uma vez completada a inicialização, criamos a GUI inicial para a aplicação.
Separei a construção do container em uma função separada para deixar o código do container mais fácil de localizar no exemplo.
</p><p>
Quando tudo está criado, chamamos a <tt class="function">ecore_main_loop_begin</tt> e esperamos que ocorram os eventos.

</p><div class="example"><a name="id2549097"></a><p class="title"><b>Exemplo 6.13. Finalização</b></p><pre class="programlisting">
    edje_shutdown();

EXIT_ECORE_EVAS:
    ecore_evas_shutdown();

EXIT_ECORE:
    ecore_shutdown();

EXIT:
    return ret;
}
</pre></div><p>
A rotina de finalização habitual nos faz bons programadores e terminamos tudo o que inicializamos.
</p><div class="example"><a name="id2549120"></a><p class="title"><b>Exemplo 6.14. callbacks de janela</b></p><pre class="programlisting">
static int sig_exit_cb(void *data, int ev_type, void *ev) {
    ecore_main_loop_quit();
    return 1;
}

static void win_del_cb(Ecore_Evas *ee) {
    ecore_main_loop_quit();
}

static void win_resize_cb(Ecore_Evas *ee) {
    int w, h;
    int minw, minh;
    int maxw, maxh;
    Evas_Object *o = NULL;

    if (ee) {
        ecore_evas_geometry_get(ee, NULL, NULL, &amp;w, &amp;h);
        ecore_evas_size_min_get(ee, &amp;minw, &amp;minh);
        ecore_evas_size_max_get(ee, &amp;maxw, &amp;maxh);

        if ((w &gt;= minw) &amp;&amp; (h &gt;= minh) &amp;&amp; (h &lt;= maxh) &amp;&amp; (w &lt;= maxw)) {
            if ((o = evas_object_name_find(ecore_evas_get(ee), "edje")))
                evas_object_resize(o, w, h);
        }
    }
}
</pre></div><p>
No passo seguinte iniciamos alguns callbacks genéricos para ser usados pela UI. Estes serão os callbacks de
sair, destruir e redimensionar. Novamente, as funções habituais EFL. Apesar que o callback de saída não é
estritamente necessário já que Ecore chamará a <tt class="function">ecore_main_loop_quit()</tt> se não houver nenhum
controlador registrado para este callback.
</p><div class="example"><a name="id2549166"></a><p class="title"><b>Exemplo 6.15. make_gui</b></p><pre class="programlisting">
static void make_gui(const char *theme) {
    Evas *evas = NULL;
    Evas_Object *o = NULL;
    Evas_Coord minw, minh;

    ee = NULL;
    edje = NULL;
    container = NULL;

    ecore_event_handler_add(ECORE_EVENT_SIGNAL_EXIT, sig_exit_cb, NULL);

    ee = ecore_evas_software_x11_new(NULL, 0, 0, 0, 300, 400);
    ecore_evas_title_set(ee, "Container Example");

    ecore_evas_callback_delete_request_set(ee, win_del_cb);
    ecore_evas_callback_resize_set(ee, win_resize_cb);
    evas = ecore_evas_get(ee);
    
    // create the edje
    edje = edje_object_add(evas);
    evas_object_move(edje, 0, 0);
    
    if (edje_object_file_set(edje, theme, "container_ex")) {
        evas_object_name_set(edje, "edje");
        
        edje_object_size_min_get(edje, &amp;minw, &amp;minh);
        ecore_evas_size_min_set(ee, (int)minw, (int)minh);
        evas_object_resize(edje, (int)minw, (int)minh);
        ecore_evas_resize(ee, (int)minw, (int)minh);
        
        edje_object_size_max_get(edje, &amp;minw, &amp;minh);
        ecore_evas_size_max_set(ee, (int)minw, (int)minh);
        evas_object_show(edje);
    
    } else {
        printf("Unable to open (%s) for edje theme\n", theme);
        exit(-1);
    }
    _setup_edje_callbacks(edje);
    ecore_evas_show(ee);
}
</pre></div><p>
A GUI consiste do Ecore_Evas que contém o próprio canvas, e o Edje que usaremos para controlar nosso layout.
A função <tt class="function">make_gui</tt> inicia os callbacks definidos mais acima e cria o Ecore_Evas.
</p><p>
Uma vez definido o Evas e os callbacks, criamos o objeto Edje que definirá nosso layout.
A chamada à <tt class="function">edje_object_add</tt> é usada para criar o objeto no Evas,
e uma vez que isto é feito, pegamos o tema passado pelo usuário e configuramos o Edje para usar este tema, o parâmetro
"container_ex" é o nome do grupo dentro do EET que vamos usar.
</p><p>
Uma vez que o arquivo de tema foi passado para o Edje, usamos os valores no arquivo de tema para inciar os
limites do tamanho da aplicação, e mostramos o Edje. Então iniciamos os callbacks no Edje e mostramos o Ecore_Evas.
</p><div class="example"><a name="id2549250"></a><p class="title"><b>Exemplo 6.16. Callbacks Edje</b></p><pre class="programlisting">
static void _setup_edje_callbacks(Evas_Object *o) {
    edje_object_signal_callback_add(o, "left_click", 
                        "left_click", _left_click_cb, NULL);
    edje_object_signal_callback_add(o, "right_click", 
                        "right_click", _right_click_cb, NULL);
}
</pre></div><p>
O programa terá dois callbacks principais conectados ao Edje, um para o sinal de clique com o botão
esquerdo do mouse e outro para o sinal do botão direito. Estes serão usados para mudar a direção/alinhamento do container.
O segundo e o terceiro parametros dos callbacks precisam bater com os dados emitidos com o sinal do Edje, isto será
visto mais tarde quando vermos o arquivo EDC. O terceiro paramêtro é a função para chamar, e o ultimo, qualquer dado
que desejamos passar pro callback.
</p><div class="example"><a name="id2549282"></a><p class="title"><b>Exemplo 6.17. container_build</b></p><pre class="programlisting">
static void container_build(int align, int direction, int fill_policy) {
    int len = 0;
    int i = 0;
    const char *edjefile = NULL;
    
    container = esmart_container_new(ecore_evas_get(ee));
    evas_object_name_set(container, "the_container");
    esmart_container_direction_set(container, direction);
    esmart_container_alignment_set(container, align);
    esmart_container_padding_set(container, 1, 1, 1, 1);
    esmart_container_spacing_set(container, 1);
    esmart_container_fill_policy_set(container, fill_policy);

    evas_object_layer_set(container, 0);
    edje_object_part_swallow(edje, "container", container);
</pre></div><p>
A função <tt class="function">container_build</tt> criará um container e inicializará nossos elementos de dados no container.
A criação é suficientement fácil com uma chamda à <tt class="function">esmart_container_new</tt> devolvendo o Evas_Object que é
o container. Uma vez criado podemos dar um nome ao container para fazer a referência mais fácil.
</p><p>
O próximo passo, iniciamos a direção, que é CONTAINER_DIRECTION_VERTICAL ou CONTAINER_DIRECTION_HORIZONTAL
[ou neste caso, um int passado pela linha de comando que refere-se a uma das direções sendo 1 e 0 respectivamente].
A direção informa ao container de que maneira os elementos serão desenhados.
</p><p>
Depois da direção iniciamos o alinhamento do container. O alinhamento informa ao container de onde desenhar os elementos.
Os valores possíveis são: ONTAINER_ALIGN_CENTER, CONTAINER_ALIGN_LEFT, CONTAINER_ALIGN_RIGHT, CONTAINER_ALIGN_TOP
e CONTAINER_ALIGN_BOTTOM. Com o layout default, direita e esquerda se aplicam apenas a um container vertical, e acima e abaixo
se aplicam a um container horizontal, enquanto centro se aplica a ambos.
</p><p>
Se desejarmos usar um esquema de layout diferente do default, poderemos fazer por uma chamada
a <tt class="function">esmart_container_layout_plugin_set(container, "name")</tt> onde "name"
é o nome do plugin à usar. A configuração default é o container nomeado "default".
</p><p>
Uma vez inicializado as direções e o alinhamento, o espaçamento e o preenchimento do container são especificados.
O preenchimento especifica o espaço em volta do container passando quatro parâmetros: left, right, top e buttom.
O parâmetro de espaçamento especifica o espaço entre os elementos no container.
</p><p>
Então continuamos e iniciamos a política de preenchimento do container. Isto especifica como os elementos
são posicionados para preencher o espaço no container. Os valores possíveis são:
CONTAINER_FILL_POLICY_NONE, CONTAINER_FILL_POLICY_KEEP_ASPECT, CONTAINER_FILL_POLICY_FILL_X,
CONTAINER_FILL_POLICY_FILL_Y, CONTAINER_FILL_POLICY_FILL e CONTAINER_FILL_POLICY_HOMOGENOUS.
</p><p>
Uma vez que o container é completamente especificado, iniciamos a camada de containers e "tragamos" o container
para dentro do ejde e a parte chamada "container".
</p><div class="example"><a name="id2547844"></a><p class="title"><b>Exemplo 6.18. Añadiendo Elementos al Contenedor</b></p><pre class="programlisting">
    len = (sizeof(str_list) / sizeof(str_list[0]));
    for(i = 0; i &lt; len; i++) {
        Evas_Coord w, h;
        Evas_Object *t = edje_object_add(ecore_evas_get(ee));

        edje_object_file_get(edje, &amp;edjefile, NULL);
        if (edje_object_file_set(t, edjefile, "element")) {
            edje_object_size_min_get(t, &amp;w, &amp;h);
            evas_object_resize(t, (int)w, (int)h);
        
            if (edje_object_part_exists(t, "element.value")) {
                edje_object_part_text_set(t, "element.value", str_list[i]);
                evas_object_show(t);
                int *i_ptr = (int *)malloc(sizeof(int));
                *i_ptr = (i + 1);

                edje_object_signal_callback_add(t, "item_selected", 
                                    "item_selected", _item_selected, i_ptr);
    
                esmart_container_element_append(container, t);
            } else {
                printf("Missing element.value part\n");
                evas_object_del(t);
            }
        } else {
            printf("Missing element part\n");
            evas_object_del(t);
        }
    }
    evas_object_show(container);
    _set_text(align, direction);
}
</pre></div><p>
Agora que temos um container, podemos adicionar alguns elemenos para mostrar. Cada uma das entradas no
array str_list definido no inicio do programa será adicionada no container como uma parte de texto.
</p><p>
Para cada elemento criamos uma novo objeto Edje no Evas. Então necessitamos saber o nome do arquivo
de tema usado para criar nosso Edje principal, chamamos <tt class="function">edje_object_file_get</tt> que
iniciará o arquivo edje para o valor informado.
</p><p>
Então tentamos iniciar o grupo chamado "element" no elemento novamente criado. Se isto falhar
imprimimos um erro e deletamos o objeto.
</p><p>
A medida qe vamos encontrando o grupo "element" podemos capturar a parte para do nosso elemento chamada "element.value". 
Se esta parte existir, ajustamos o valor de texto da parte para nossa string atual e mostramos a parte.
</p><p>
Um callback é criado por intermédio da <tt class="function">edje_object_signal_callback_add</tt> e vinculado ao novo
elemento. Este será chamado se o sinal "item_selected" é enviado pelo Edje. O valor i_ptr
mostra como se pode vincular dados ao elemento, quando o usuário clicar em um elemento seu número será
impresso no console.
</p><p>
Uma vez criado o elemento adicionamos-o ao container.
</p><p>
Por fim, o container é mostrado e fazemos algum trabalho extra para mostrar informação sobre o container no cabeçalho
por meio da chamada <tt class="function">_show_text</tt>.
</p><div class="example"><a name="id2549695"></a><p class="title"><b>Exemplo 6.19. _set_text</b></p><pre class="programlisting">
static void _set_text(int align, int direction) {
    Evas_Object *t = edje_object_add(ecore_evas_get(ee));
    const char *edjefile;

    if (direction == CONTAINER_DIRECTION_VERTICAL)
        edje_object_part_text_set(edje, "header_text_direction", "vertical");
    else
        edje_object_part_text_set(edje, "header_text_direction", "horizontal");

    if (align == CONTAINER_ALIGN_CENTER) 
        edje_object_part_text_set(edje, "header_text_align", "center");
    
    else if (align == CONTAINER_ALIGN_TOP)
        edje_object_part_text_set(edje, "header_text_align", "top");
    
    else if (align == CONTAINER_ALIGN_BOTTOM)
        edje_object_part_text_set(edje, "header_text_align", "bottom");
    
    else if (align == CONTAINER_ALIGN_RIGHT)
        edje_object_part_text_set(edje, "header_text_align", "right");
    
    else if (align == CONTAINER_ALIGN_LEFT)
        edje_object_part_text_set(edje, "header_text_align", "left");
}
</pre></div><p>
A rotina <tt class="function">_set_text</tt> pega a direção e o alinhamento atual do container e coloca algum texto
no cabeçalho do programa. Isto é apenas uma simples comunicação com o usuário da configuração do container atual.
</p><div class="example"><a name="id2549740"></a><p class="title"><b>Exemplo 6.20. _left_click_cb</b></p><pre class="programlisting">
static void _left_click_cb(void* data, Evas_Object* o, const char* emmission,
                                                            const char* source) {
    Container_Direction dir = esmart_container_direction_get(container);
    Container_Direction new_dir = (dir + 1) % 2;
    Container_Alignment align = esmart_container_alignment_get(container);

    esmart_container_direction_set(container, new_dir);

    if (align != CONTAINER_ALIGN_CENTER) {
        if (new_dir == CONTAINER_DIRECTION_HORIZONTAL)
            align = CONTAINER_ALIGN_TOP;
        else
            align = CONTAINER_ALIGN_LEFT;
    }
    esmart_container_alignment_set(container, align);
    _set_text(align, new_dir);
}
</pre></div><p>
Quando o usuário clica com o botão esquerdo do mouse este callback irá ser executado. Nós pegamos a informação
de direção atual do container e mudamos para a outra direção (ex. horizontal se torna vertical e vice-versa).
Também reiniciamos o alinhamento se não estamos atualmente alinhado no centro para certificarmos que tudo é válido
para a nova direção. O texto no cabeçalho é atualizado.
</p><div class="example"><a name="id2549779"></a><p class="title"><b>Exemplo 6.21. _right_click_cb</b></p><pre class="programlisting">
static void _right_click_cb(void* data, Evas_Object* o, const char* emmission,
                                                            const char* source) {
    Container_Direction dir = esmart_container_direction_get(container);
    Container_Alignment align = esmart_container_alignment_get(container);
    
    if (dir == CONTAINER_DIRECTION_HORIZONTAL) {
        if (align == CONTAINER_ALIGN_TOP)
            align = CONTAINER_ALIGN_CENTER;
        
        else if (align == CONTAINER_ALIGN_CENTER)
            align = CONTAINER_ALIGN_BOTTOM;
        
        else
            align = CONTAINER_ALIGN_TOP;
    
    } else {
        if (align == CONTAINER_ALIGN_LEFT)
            align = CONTAINER_ALIGN_CENTER;
        
        else if (align == CONTAINER_ALIGN_CENTER)
            align = CONTAINER_ALIGN_RIGHT;
        
        else
            align = CONTAINER_ALIGN_LEFT;
    }
    esmart_container_alignment_set(container, align);
    _set_text(align, esmart_container_direction_get(container));
}
</pre></div><p>
O calback do clique do botão direito intercalará entre os alinhamentos disponíveis por uma direção dada
quando o usuário clicar com o botão direito do mouse.
</p><div class="example"><a name="id2549818"></a><p class="title"><b>Exemplo 6.22. _item_selected</b></p><pre class="programlisting">
static void _item_selected(void* data, Evas_Object* o, const char* emmission,
                                                            const char* source) {
    printf("You clicked on the item with number %d\n", *((int *)data));
}
</pre></div><p>
Finalmente o callback <tt class="function">_item_selected</tt> será executado quando o usuário clicar no
botão central do mouse sobre o item do container. O dado conterá o número para este elemento na rotina
criada acima.
</p><p>
Este é o fim do código para a aplicação, depois vem a EDC requerida para que tudo seja mostado e funcione corretamente.
</p><div class="example"><a name="id2549858"></a><p class="title"><b>Exemplo 6.23. La Edc</b></p><pre class="programlisting">
fonts {             
    font: "Vera.ttf" "Vera";
}                   
                        
collections {           
    group {         
        name, "container_ex";
        min, 300, 300;
        max, 800, 800;
            
        parts { 
            part {
                name, "bg";
                type, RECT;
                mouse_events, 1;
                    
                description {
                    state, "default" 0.0;
                    color, 0 0 0 255;
                        
                    rel1 {
                        relative, 0.0 0.1;
                        offset, 0 0;
                    }
                    rel2 {
                        relative, 1.0 1.0;
                        offset, 0 0;
                    }
                }   
            }           
                        
            part {      
                name, "header";
                type, RECT;
                mouse_events, 0;

                description {
                    state, "default" 0.0;
                    color, 255 255 255 255;
                
                    rel1 {
                        relative, 0.0 0.0;
                        offset, 0 0; 
                    }

                    rel2 {
                        relative, 1.0 0.1;
                        offset, 0 0;
                    }
                }
            }

            part {
                name, "header_text_direction";
                type, TEXT;
                mouse_events, 0;

                description {
                    state, "default" 0.0;
                    color, 0 0 0 255;

                    rel1 {
                        relative, 0.0 0.0;
                        offset, 0 10;
                        to, "header";
                    }
                    rel2 {
                        relative, 1.0 1.0;
                        offset, 0 0;
                        to, "header";
                    }
                    text {
                        text, "direction";
                        font, "Vera";
                        size, 10;
                    }
                }
            }

            part {
                name, "header_text_align";
                type, TEXT;
                mouse_events, 0;

                description {
                    state, "default" 0.0;
                    color, 0 0 0 255;

                    rel1 {
                        relative, 0.0 0.0;
                        offset, 0 0;
                        to, "header_text_direction";
                    }
                    rel2 {
                        relative, 1.0 1.0;
                        offset, 110 0;
                        to, "header_text_direction";
                    }
                    text {
                        text, "align";
                        font, "Vera";
                        size, 10;
                    }
                }
            }
</pre></div><p>
Este arquivo EDC espera ter a font Vera incorporada dentro dele, como é definido pela seção de fontes no inicio.
Isto quer dizer que quando você compila o edc você necessita do arquivo Vera.ttf no diretório corrente ou dar
ao edje_cc a flag -fd e especificar o diretório para a fonte.
</p><p>
Depois que as fontes são definidas, as coleções principais são definidas. A primeira coleção é a porção principal da
própria aplicação, o grupo "container_ex". Este grupo especifica a janela principal da aplicação. Como
tal ele contêm as partes para o fundo, o cabeçalho e o texto de cabeçalho. Estas partes são bem padrão com algum
(mínimo) alinhamento feito entre elas.
</p><div class="example"><a name="id2549954"></a><p class="title"><b>Exemplo 6.24. A Parte Container</b></p><pre class="programlisting">
            part {
                name, "container";
                type, RECT;
                mouse_events, 1;

                description {
                    state, "default" 0.0;
                    visible, 1;

                    rel1 {
                        relative, 0.0 0.0;
                        offset, 0 0;
                        to, bg;
                    }
                    rel2 {
                        relative, 1.0 1.0;
                        offset, 0 0;
                        to, bg;
                    }
                    color, 0 0 0 0;
                }
            }
        }
        programs {
            program {
                name, "left_click";
                signal, "mouse,clicked,1";
                source, "container";
                action, SIGNAL_EMIT "left_click" "left_click";
            }

            program {
                name, "right_click";
                signal, "mouse,clicked,3";
                source, "container";
                action, SIGNAL_EMIT "right_click" "right_click";
            }
        }
    }
</pre></div><p>
A parte container é então definida. A parte em si é bem siples, apenas posicionada relativamente ao fundo
e iniciada para receber eventos do mouse. Depois de definir as partes especificamos os programas para este
grupo, do qual há dois. O primeiro programa "left_click" espeficia o que vai acontecer em um
evento do primeiro botão do mouse.
</p><p>
A ação é emetir um sinal, os dois parâmetos depois de SIGNAL_EMIT bate com os valores postos no callback
no código da aplicação.
</p><p>
Há um callback similar para o terceiro botão do mouse assim como para o primeiro, só que emitindo um sinal
levemente diferente.
</p><div class="example"><a name="id2550015"></a><p class="title"><b>Exemplo 6.25. O Grupo Elemento</b></p><pre class="programlisting">
    group {
        name, "element";
        min, 80 18;
        max, 800 18;

        parts {
            part {
                name, "element.value";
                type, TEXT;
                mouse_events, 1;
                effect, NONE;

                description {
                    state, "default" 0.0;
                    visible, 1;

                    rel1 {
                        relative, 0.0 0.0;
                        offset, 0 0;
                    }
                    rel2 {
                        relative, 1.0 1.0;
                        offset, 0 0;
                    }
                    color, 255 255 255 255;

                    text {
                        text, "";
                        font, "Vera";
                        size, 10;
                    }
                }
            }
        }
        programs {
            program {
                name, "center_click";
                signal, "mouse,clicked,2";
                source, "element.value";
                action, SIGNAL_EMIT "item_selected" "item_selected";
            }
        }
    }
}
</pre></div><p>
O grupo elemento especifica como cada elemento do container é mostrado. Você notará que os nomes aqui dados
batem com os nomes que se procuram no próprio código da aplicação enquanto se criam os elementos.
</p><p>
Há um programa neste grupo que irá emitir um sinal de "item_selected" quando o botão central do mouse é
pressionado enquanto estivermos sobre um dos elementos na lista.
</p><p>
Este é o final do código EDC. Para compliar o código da aplicação, um makefile similar ao abaixo
pode ser usado.
</p><div class="example"><a name="id2550076"></a><p class="title"><b>Exemplo 6.26. Makefile</b></p><pre class="programlisting">
CFLAGS = `ecore-config --cflags` `evas-config --cflags` `esmart-config --cflags`
LIBS = `ecore-config --libs` `evas-config --libs` `esmart-config --libs` \
            -lesmart_container

container_ex: container/container_ex.c
        gcc -o container/container_ex container/container_ex.c $(CFLAGS) $(LIBS)
</pre></div><p>
E para criar o arquivo EET, um simples 'edje_cc default.edc' deve ser suficiente desde que o
arquivo Vera.ttf esteja no diretório atual.
</p><p>
Uma vez que você tenha compilado, você precisará fazer </p><pre class="screen">./container_ex -t default.edj</pre><p> e tudo
deve funcionar bem.
</p><p>
Então é isto, assumindo que tudo saia como planejado, você deverá ter uma simples aplicação em que clicando
com o botão esquerdo/direito do mouse moverá  o container para diferentes posições da jenela.
Enquanto clicando com o botão central do mouse nos elementos, imprimirá o número do elemento.
</p></div></div><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a name="id2544601"></a>Capítulo 7. Epeg y Epsilon </h2></div></div><div></div></div><div class="toc"><p><b>Índice</b></p><dl><dt><a href="#id2552644">Receita: Thumbnailing simples com Epeg</a></dt><dt><a href="#id2552563">Receta: Thumbnailing simples com Epsilon</a></dt></dl></div><p>
Nesta era moderna de fotografia digital a apresentação de imagens se converte em um problema devido 
ao grande volume de imagens que são criadas. Diferente do passado, quando um filme era 
usado equilibradamente, agora geramos centenas ou milhares de imagens por semana. A solução para este 
problema de apresentação de imagens é "thumbnail", uma imagem em escala reduziada que pode ser indexada
em uma tabela ou por uma aplicação e rápidamente scaneada visualmente para encontrar as imagens 
que deseja. Mas escalonamento de imagem é uma operação muito intensiva, tanto que numa potente 
máquina Athlon escalonar apenas uma fotografia de tamanho 1600x1200 na resolução requerida 
leva-se 1 segundo, se tiver 2000 fotografias levará 30 minutos assumindo que não há 
operação manual num editor de imagens como o Photoshop ou o GIMP. O problema claramente 
pede uma ferramente que pode escalar imagens com uma grande velocidade e eficiência, com tanto 
controle quanto possível. A solução está em duas bibliotecas da EFL : Epeg e Epsilon.
</p><p>
Epeg foi escrita por Raster para exatamente controlar o problema acima descrito com 
sua galeria de imagens em seu site rasterman.com. Epeg é um "thumbnailer" de geração 
automática mais rápido do planeta. Com uma API fácil de usar, pode ser integrado 
em qualquer aplicação que você desejar. O único inconveniente é que ele só 
manipula imagens JPEGs, mas não chega a ser um grande problema se levar em conta 
que todas as câmeras digitais disponíveis no mercado usam o formato JPEG como padrão.
</p><p>
Epsilon foi escrito por Atmos, inspirado pela velocidade da Epeg mas em resposta a uma necessidade 
de capacidade de "thumbnailing" de diversos formatos. Epsilon pode manipular JPEG, PNG, XCF, 
e GIF. Obviamente, já que ela não é uma biblioteca específica para manipular JPEG, não 
manipulará JPEG tão rápido quanto a Epeg, mas pode-se usar a própria Epeg para se ter as 
vantagens de velocidade que esta provê. Epsilon, diferente da Epeg, está em conformidade com
o <a href="http://triq.net/~jens/thumbnail-spec/index.html" target="_top">Thumbnail Managing Standard</a> 
do freedesktop.org. Portanto, ela direciona a saída dos thumbnails para a estrutura 
de diretório definida pela Thumbnail Managing Standard (~/.thumbnails/) ao invéz de um lugar definido 
pelo programador.
</p><p>
Ambas bibliotecas fazem tarefas tão expecíficas que as APIs são muito simples de usar. Epeg tem apenas 
17 funções e Epsilon apenas 9, tornando-as fáceis de aprender para poder utiliza-las rapidamente.
</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2552644"></a>Receita: Thumbnailing simples com Epeg</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Ben</span> <span class="othername">'technikolor'</span> <span class="surname">Rockwood</span></h3></div></div></div><div></div></div><p>
A aplicação mais simplística de thumbnailing que podemos escrever usará apenas dois argumentos, o nome do arquivo 
( imagem ) de entrada e o nome do arquivo ( thumbnail ) de saída. O seguinte exemplo de código usa Epeg 
exatamente para fazer isto.
</p><div class="example"><a name="id2551318"></a><p class="title"><b>Exemplo 7.1. Um simples Thumbnail Epeg</b></p><pre class="programlisting">
#include &lt;Epeg.h&gt;

int main(int argc, char *argv[]){

        Epeg_Image * image;
        int w, h;

        if(argc &lt; 2) {
                printf("Usage: %s input.jpg output.jpg\n", argv[0]);
                return(1);
        }

        image = epeg_file_open(argv[1]);

        epeg_size_get(image, &amp;w, &amp;h);
        printf("%s -  Width: %d, Height: %d\n", argv[1], w, h);
        printf("  Comment: %s", epeg_comment_get(image) );

        epeg_decode_size_set(image, 128, 96);
        epeg_file_output_set(image, argv[2]);
        epeg_encode(image);
        epeg_close(image);

        printf("... Done.\n");
        return(0);
}
</pre></div><p>
Este é um exemplo bastante simplístico, não há checagem para certificar-se que o arquivo de entrada é realmente um JPEG, 
mas mostra adequadamente algumas das características da biblioteca. Ele pode ser compilado da senguinte maneira:
</p><div class="example"><a name="id2552695"></a><p class="title"><b>Exemplo 7.2. </b></p><pre class="programlisting">
gcc `epeg-config --libs --cflags` epeg-test.c -o epeg-test
</pre></div><p>
A função <tt class="function">epeg_file_open</tt> abre um JPEG para ser manipulado, retornando um ponteiro 
para <span class="returnvalue">Epeg_Image</span>. Este ponteiro pode então ser passado para as outras 
funções Epeg para manipulação.
</p><p>
Duas funções diferentes são usadas aqui para pegar algumas informações sobre a imagem de entrada:
<tt class="function">epeg_size_get</tt> e <tt class="function">epeg_comment_get</tt>. Note que os valores 
retornados destas funções não são usadas em nenhuma outra função Epeg, são simplesmente para fins de informação.
Um bom uso para estes valores retornados pode ser para definir o tamanho do thumbnail de saída, ou modificar e 
passar um comentário ao thumbnail de saída.
</p><p>
O conjunto de funções seguinte realmente fazem o trabalho. <tt class="function">epeg_decode_size_set</tt> 
define o tamanho da saída do thumbnail. <tt class="function">epeg_file_output_set</tt> define o nome do
arquivo de saída. E <tt class="function">epeg_encode</tt> faz o verdadeiro trabalho pesado. Observe que enquanto 
não checamos se houve exito aqui, <tt class="function">epeg_encode</tt> retorna um int permitindo-nos checar se 
a operação foi um sucesso.
</p><p>
Uma vez criado o thumbnail, simplesmente chamamos a <tt class="function">epeg_close</tt> para terminar o assunto.
</p><p>
Enquanto este exemplo é bem simples você pode ver como o básico funciona. Epeg tem 
também funções para redução, comentário no thumbnail, habilitar e desabilitar os comentários, 
conversão de espaço de cor e ajustes de qualidade que podem ser usados para conseguir os 
resultados que se deseja.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2552563"></a>Receta: Thumbnailing simples com Epsilon</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Ben</span> <span class="othername">'technikolor'</span> <span class="surname">Rockwood</span></h3></div></div></div><div></div></div><p>
Epsilon cria thumbnails em conformidade com a 
<a href="http://triq.net/~jens/thumbnail-spec/index.html" target="_top">Thumbnail Managing Standard</a> 
da freedesktop.org. Thumbnails podem ser criados para uma variedade de formatos, incluindo suporte 
nativo para PNG, suporte para Epeg ou qualquer formato suportado pela Imlib2. Vejamos uma simples 
aplicação Epsilo, similar ao exemplo Epeg anterior.
</p><div class="example"><a name="id2551542"></a><p class="title"><b>Exemplo 7.3. Um simples Thumbnail Epsilon</b></p><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;Epsilon.h&gt;

int main(int argc, char *argv[]){

        Epsilon * image = NULL;
        Epsilon_Info *info;

        if(argc &lt; 1) {
                printf("Usage: %s input_image\n", argv[0]);
                return(1);
        }

        epsilon_init();

        image = epsilon_new(argv[1]);

        info = epsilon_info_get(image);
        printf("%s -  Width: %d, Height: %d\n", argv[1], info-&gt;w, info-&gt;h);


        if (epsilon_generate(image) == EPSILON_OK) {
                printf("Thumbnail created!\n");
        } else {
                printf("Generation failed\n");
        }
        epsilon_free(image);

        return(0);
}
</pre></div><p>
Pode ser compilado da seguinte maneira:
</p><div class="example"><a name="id2553098"></a><p class="title"><b>Exemplo 7.4. </b></p><pre class="programlisting">
gcc `epsilon-config --libs --cflags` epsilon-simple.c -o epsilon-simple
</pre></div><p>
Notamos quase que imediatamente que não aceita-se nenhum nome de arquivo de saída, nem se usa nenhuma função de saída.
A Thumbnail Managing Standard da reedesktop.org específica que todos os thumbnails são criados no diretório ~/.thumbnail. 
Este repositório cental de thumbnails permite compartilahr os thumbnails entre multiplas aplicações que aderem 
à específicação standard. Antes de compilar e executar o código exemplo, verifique se existe a imagem em ~/.thumbnails/large.
Os thumbnails também se nomeiam de acordo com a específicação standard, renomeando o nome original com um MD5 checksum, 
de forma que o thumbnail não precisa ser refeito se a imagem está renomeada.
</p><p>
No nosso exemplo começamos verificando que obtemos uma imagem de entrada para fazer um thumbnail e então inicializamos o Epsilon usando
a função <tt class="function">epsilon_init</tt>. <tt class="function">epsilon_new</tt> aceita um único argumento, a imagem que quer 
fazer um thumbnail, e retorna um ponteiro epsilon que é usado por outras funções.
</p><p>
Epsilon tem a habilidade de obter algumas informações básicas de suas imagens. No exemplo acima usamos 
<tt class="function">epsilon_info_get</tt> para retornar uma estrutura <span class="returnvalue">Epsilon_Info</span> contendo 
a data ( mtime ) de modificação da imagem de entrada, o lugar ( URI ), largura, altura e o tipo MIME. Aqui simplesmente 
damos a largura e altura da imagem usando os elementos <tt class="varname">w</tt> e <tt class="varname">h</tt> da estrutura info.
</p><p>
<tt class="function">epsilon_generate</tt> é a função peso pesado. Esta função gerará o thumbnail e colocará no lugar apropriado. Seu 
valor de retorno indicando sucesso pode ser verificado usando as definições de macro CPP fornecida pelo header do Epsilon: 
<tt class="varname">EPSILON_FAIL</tt> e <tt class="varname">EPSILON_OK</tt>.
</p><p>
A limpeza é fornecida pela <tt class="function">epsilon_free</tt>.
</p><p>
Epsilon, como visto aqui, é muito simples de usar e integrar com qualquer aplicação que faz uso de thumbnails.
Não só fornece um API simples, mas integração com a reinante definição padrão para thumbnailing sem custo extra.
Para informação adicional sobre Epsilon, veja os documentos Doxygen do Epsilon em Enlightenment.org.
</p></div></div><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a name="id2551783"></a>Capítulo 8. Etox</h2></div></div><div></div></div><div class="toc"><p><b>Índice</b></p><dl><dt><a href="#id2551205">Receta: Perspectiva geral de Etox</a></dt></dl></div><p>
Etox é uma biblioteca avançada de composição e layout de texto baseada no Evas, permitindo maiores e melhores funcionalidades 
que as disponíveis pelo Evas. É capaz de simplificar as tarefas de mostrar, mover, redimencionar, por em camadas e 
recortar texto, bem como alinhamento de texto, ajuste e modificação. Etox pode inteligentemente resolver obstáculos e 
aplicar <span class="emphasis"><em>styles</em></span> predefinidos. Quase qualquer aspecto de nível textual pode ser controlado fácil 
e eficientemente com o Etox.
</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2551205"></a>Receta: Perspectiva geral de Etox</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Ben</span> <span class="othername">'technikolor'</span> <span class="surname">Rockwood</span></h3></div></div></div><div></div></div><p>
Para começar a usar Etox rapidamente é útil um exemplo simples. No seguinte código exemplo criamos uma
Evas X11 usando Ecore_Evas e então colocaremos algum texto Etox nele.
</p><div class="example"><a name="id2550691"></a><p class="title"><b>Exemplo 8.1. Exemplo Etox</b></p><pre class="programlisting">
#include &lt;Ecore_Evas.h&gt;
#include &lt;Ecore.h&gt;
#include &lt;Etox.h&gt;

#define WIDTH 400
#define HEIGHT 200

        Ecore_Evas  *   ee;
        Evas        *   evas;
        Evas_Object *   base_rect;
        Evas_Object *   etox;
        Etox_Context *  context;

int main(){

        ecore_init();

   ee = ecore_evas_software_x11_new(NULL, 0,  0, 0, WIDTH, HEIGHT);
        ecore_evas_title_set(ee, "ETOX Test");
        ecore_evas_borderless_set(ee, 0);
        ecore_evas_show(ee);

   evas = ecore_evas_get(ee);
        evas_font_path_append(evas, ".");

   base_rect = evas_object_rectangle_add(evas);
        evas_object_resize(base_rect, (double)WIDTH, (double)HEIGHT);
        evas_object_color_set(base_rect, 255, 255, 255, 255);
        evas_object_show(base_rect);

   etox = etox_new(evas);
        evas_object_resize(etox, WIDTH, HEIGHT);


   context = etox_get_context(etox);
        etox_context_set_color(context, 0, 0, 0, 255);
        etox_context_set_font(context, "Vera", 32);
        etox_context_set_align(context, ETOX_ALIGN_LEFT);

        etox_set_soft_wrap(etox, 1);
        etox_set_text(etox, "Welcome to the world of Etox!");

        evas_object_show(etox);

        ecore_main_loop_begin();

        return 0;
}
</pre></div><p>
Este exmplo deve ser compilado da seguinte maneira:
</p><div class="example"><a name="id2550712"></a><p class="title"><b>Exemplo 8.2. </b></p><pre class="programlisting">
gcc `etox-config --libs --cflags` `ecore-config --libs --cflags` etox-test.c -o etox-test
</pre></div><p>
A maior parte deste exemplo são funções standard do Ecore_Evas, assim nos concentraremos apenas nas partes
relacionadas com Etox. Observe que usamos a função Evas <tt class="function">evas_font_path_append()</tt> para definir
o cominho de nossas fontes, isto é algo que o Etox não fará por você.
</p><p>
Seu texto Etox será sempre inicializado por adicionar um novo Etox usando a função <tt class="function">etox_new()</tt>
que devolve um Evas_Object. Já que o seu Etox é um objeto Evas, ele pode ser manipulado como tal. As funções de layout
do Etox, como recortar e ajustar, são dependentes do tamanho do próprio Etox, portanto <tt class="function">evas_object_resize()</tt>
necessita ser chamada para definir o tamanho apropriado do Etox. Observer que a área do objeto <span class="emphasis"><em>não</em></span> será
igual por default ao tamanho do próprio Evas.
</p><p>
Etox usa o conceito de contextos. Um <tt class="literal">context</tt> é um conjunto de parâmetros como cor,
fonte, alinhamento, estilo e marcas que são aplicadas a um certo conjunto de texto. Cada objeto Etox tem
pelo menos um contexto associdado à ele que é criado quando se chama a função <tt class="function">etox_new()</tt>.
Por esta razão a função <tt class="function">etox_context_new()</tt> <span class="emphasis"><em>só</em></span>  precisa ser chamada
quando se deseja criar contexto adicionais.
</p><p>
Uma vez usado <tt class="function">etox_new()</tt> para adicionar seu objeto Etox você precisa usar <tt class="function">etox_get_context()</tt>
para devolver um ponteiro à <tt class="varname">Etox_Context</tt> que pode então ser passado a outras funções de contexto para
modificar os atributos do seu texto. No exemplo adicionamos a cor, fonte e o alinhamento de nosso contexto.
</p><p>
Das caracteríscas mais interessantes e simplistas do Etox são sua habilitade de inteligentemente quebrar o texto e
 de interpretar o caracter de nova linha do C ( \n ) como quebra de linha. Essas são duas características que o
 próprio Evas não proporciona, é da responsabilidade do programador certificar que o texto não saia do canvas.
</p><p>
A quebra inteligente de linha vem em duas formas que não são mutuamente exclusivas. A primeira é a quebra suave,
que ajustará o texto quando um caracter exceder a largura do canvas. A segunda é a quebra de palavra,
que irá ajustar o texto quando uma palavra exceder a largura do canvas. Tipicamente a segunda maneira é
desaconselhada de maneira que obtenhamos "Isto é minha (quebra) string" no lugar de "Isto é mi(quebra)nha string".
Note, ademais, que a quebra da palavra não funcionará a menos que a quebra suvae seja habilitada, portanto a quebra de
palavra requer chamar <span class="emphasis"><em>ambas</em></span> funções, <tt class="function">etox_set_soft_wrap()</tt> e
<tt class="function">etox_set_word_wrap()</tt>.
</p><p>
Uma nota final sobre a quebra é que, por default tal ajuste irá inserir um <tt class="literal">marcador de quebra de linha</tt>
na sua string de saída, um sinal "+" por default. Esta marca indica que um ajuste ocorreu e é impresso
como primeiro caracter na linha seguinte. Sua string, portanto, se parecerá como: "Isto é minha (quebra) +string".
Se preferir que o Etox quebre suavemente sem marcador, simplesmente configure o marcador como sendo vazio usando a
função <tt class="function">etox_context_set_wrap_marker()</tt>.
</p><p>
A string de texto Etox se configura usando <tt class="function">etox_set_text()</tt>. É importante saber que a cadeia se
aplica ao próprio Etox e não ao contexto. No há associação direta entre a string e o contexto
que facilite a visualização do texto sem ter que modificar o contexto, ou vice-versa.
</p><p>
Enquanto este é um exemplo muito simples do uso de Etox, muito pode ser feito e como você pode ver a API é simples
e limpa, preenchendo muitas necessidades de controle de texto que o Evas não possui.
</p></div></div><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a name="id2550256"></a>Capítulo 9. Edje</h2></div></div><div></div></div><div class="toc"><p><b>Índice</b></p><dl><dt><a href="#id2550632">Receita: Um template para construir aplicações Edjes</a></dt><dt><a href="#id2553920">Receita: Criando/Disparando callbacks Edje</a></dt><dt><a href="#id2555448">Receita: Trabalhando com arquivos Edje</a></dt><dd><dl><dt><a href="#id2555005">edje_cc</a></dt><dt><a href="#id2556633">edje_decc</a></dt><dt><a href="#id2556670">edje_recc</a></dt><dt><a href="#id2556827">edje_ls</a></dt><dt><a href="#id2556891">edje</a></dt></dl></dd></dl></div><p>
Edje é uma complexa biblioteca de desenho gráfico e layout. Seu propósito é abstrair todo elemento de interface da 
sua aplicação Evas do próprio código.
</p><p>
Uma aplicação Edje consiste em duas partes: O Código C que forma sua aplicação e uma Coleção de Dados Edje ( EDC ) que descreve cada 
elemento da sua interface. Ambas estão conectadas por sinais que são emitidas pelo EDC e recebidas por callbacks no código da sua 
aplicação. Usando este modelo de sinais o código fica completamente desinteressado no aspecto visual da sua 
interface, apenas recebe sinais. E como os sinais são processados por callbacks, no há necessidade que sua interface envie cada 
sinal disponível, fazendo possivel aplicações em grande escala e aplicações de tamanho "demo" com um único binário. Tanto faz se 
sua interface usa botões ou uma drag-bar para enviar dados, isto existe diferença para a sua aplicação.
</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2550632"></a>Receita: Um template para construir aplicações Edjes</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Ben</span> <span class="othername">'technikolor'</span> <span class="surname">Rockwood</span></h3></div></div></div><div></div></div><p>
O seguinte exemplo é um template que pode ser usado para iniciar rápida e fácilmente uma aplicação Edje.
É semelhante ao template econtrado no capítulo sobre Evas, já que este também usa Ecore_Evas.
</p><div class="example"><a name="id2550670"></a><p class="title"><b>Exemplo 9.1. Template Edje</b></p><pre class="programlisting">
#include &lt;Ecore_Evas.h&gt;
#include &lt;Ecore.h&gt;
#include &lt;Edje.h&gt;

#define WIDTH 100
#define HEIGHT 100

int app_signal_exit(void *data, int type, void *event);

        /* GLOBALS */
        Ecore_Evas  *   ee;
        Evas        *   evas;
        Evas_Object *   edje;

        Evas_Coord   edje_w, edje_h;
                                
                                
int main(int argv, char *argc[]){
                                
        ecore_init();           
        ecore_event_handler_add(ECORE_EVENT_SIGNAL_EXIT, app_signal_exit, NULL);
                                
        ecore_evas_init();      
                                
   ee = ecore_evas_software_x11_new(NULL, 0,  0, 0, WIDTH, HEIGHT);
        ecore_evas_title_set(ee, "TITLE");
        ecore_evas_borderless_set(ee, 0);
        ecore_evas_shaped_set(ee, 0);
        ecore_evas_show(ee);    
                                
                                
   evas = ecore_evas_get(ee);   
        evas_font_path_append(evas, "edje/fonts/");
                                
        edje_init();            
   edje = edje_object_add(evas);
        edje_object_file_set(edje, "edje/XXX.eet", "XXX");
        evas_object_move(edje, 0, 0);
        edje_object_size_min_get(edje, &amp;edje_w, &amp;edje_h);
        evas_object_resize(edje, edje_w, edje_h);
        evas_object_show(edje); 
                                
        ecore_evas_resize(ee, (int)edje_w, (int)edje_h);
        ecore_evas_show(ee);    
                                
	/* Insert Objects and callbacks here */
                                
        ecore_main_loop_begin();
                                
        return 0;               
}                               
                                
                                
int app_signal_exit(void *data, int type, void *event){

        printf("DEBUG: Exit called, shutting down\n");
        ecore_main_loop_quit();
        return 1;
}
</pre></div><p>
Compilar este template da seguinte maneira:
</p><pre class="programlisting">
 gcc `edje-config --cflags --libs` `ecore-config --cflags --libs` edje_app.c -o edje_app
</pre><p>
As chamadas importantes para vermos aqui estão localizadas no bloco Edje, seguindo a função <tt class="function">edje_init()</tt>.
</p><p>
<tt class="function">edje_object_file_set()</tt> define que EET Edje é usada assim como o nome da coleção à usar.
</p><p>
O resto das funções Edje/Evas no block Edje são necessárias para redimencionar a janela X11 para acomodar seu Edje.
Começamos movendo a janela Evas e então pegando o tamanho mínimo do próprio Edje usando 
<tt class="function">edje_object_size_min_get()</tt>. Então, usando <tt class="function">evas_object_resize()</tt> podemos
redimencionar o Edje, que é um objeto Evas real, para o tamanho do próprio evas. Adiante podemos mostrar o 
Edje e então redimencionar o próprio Evas (e graças ao Ecore a janela também) usando <tt class="function">ecore_evas_resize()</tt>.
</p><p>
Depois disto callbacks podem ser adicionados para serem conectados à sua interface.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2553920"></a>Receita: Criando/Disparando callbacks Edje</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
As vezes é necessário avisar ao seu programa principal que 
algum evento aconteceu em sua interface de usuário. Mas você 
não quer partes da implementação misturando-se com o desenho 
da interface com o usuário. Isto é fácilmente feito com Edje 
disparando um sinal do seu programa EDC e associando um 
callback ao sinal no programa em C.
</p><div class="example"><a name="id2553715"></a><p class="title"><b>Exemplo 9.2. Programa callback</b></p><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;Ecore.h&gt;
#include &lt;Ecore_Evas.h&gt;
#include &lt;Edje.h&gt;

int exit_cb(void *data, int type, void *ev);
void edje_cb(void *data, Evas_Object *obj,
                    const char *emission, const char *source);

int
main(int argc, char ** argv)

{
    int ret = 0;
    Ecore_Evas *ee = NULL;
    Evas *evas = NULL;
    Evas_Object *edje = NULL;
    Evas_Coord w, h;

    if (!ecore_init()) {
        printf("error setting up ecore\n");
        goto EXIT;
    }
    ecore_app_args_set(argc, (const char **)argv); 
    
    if (!ecore_evas_init()) {
        printf("error setting up ecore_evas\n");
        goto ECORE_SHUTDOWN;
    }

    if (!edje_init()) {
        printf("error setting up edje\n");
        goto ECORE_SHUTDOWN;
    }
    ecore_event_handler_add(ECORE_EVENT_SIGNAL_EXIT, exit_cb, NULL);

    ee = ecore_evas_software_x11_new(NULL, 0, 0, 0, 200, 300);
    ecore_evas_title_set(ee, "Edje CB example");
    ecore_evas_show(ee); 

    evas = ecore_evas_get(ee);
    edje = edje_object_add(evas);
    edje_object_file_set(edje, "default.eet", "main");
    evas_object_move(edje, 0, 0);
    edje_object_size_min_get(edje, &amp;w, &amp;h);
    evas_object_resize(edje, w, h);
    ecore_evas_resize(ee, w, h);
    evas_object_show(edje);

    edje_object_signal_callback_add(edje, "foo", "bar", edje_cb, NULL);

    ecore_main_loop_begin();
    ret = 1;

    edje_shutdown();
ECORE_SHUTDOWN:
    ecore_shutdown();
EXIT:
    return ret;
}

int
exit_cb(void *data, int type, void *ev)
{
    ecore_main_loop_quit();
    return 1;
}

void
edje_cb(void *data, Evas_Object *obj,
                    const char *emission, const char *source)
{
    printf("got emission: %s from source: %s\n", emission, source);
}
</pre></div><p>
A maior parte disto são inicializações padrões para o Ecore, Ecore_Evas e Edje. 
O callback é conectado com 
<tt class="function">edje_object_signal_callback_add(Evas_Object *o, char *emission,
char *source, (void *)func(void *data, Evas_Object *obj, const char
*emission, const char *source), void *user_data)</tt>. O objeto 
<tt class="literal">o</tt> do qual o callback está conectado é um objecto Edje 
que foi criado no nosso arquivo EDC.
</p><p>
Os valores <tt class="literal">emission</tt> e <tt class="literal">source</tt> precisam ser 
strings que coincidam com a chamada emit no programa EDC que será visto 
mais tarde. Outra opção é por "*" em emission ou source. Isto fará com que o 
valor "*" coincida com qualquer coisa. Se deseja receber todas as chamadas que o 
edje emite, você pode colocar um "*" em ambos parâmetros, emission e source.
</p><p>
O <tt class="literal">func</tt> é a função à chamar e finalmente 
<tt class="literal">user_data</tt> é qualquer dado extra que você desejar ser passado 
para a callback.
</p><p>
O callback pode ser visto em <tt class="function">edje_cb</tt>. 
Esta receberá os dados do usuário, o objeto edj que chamou o 
callback, e as strings emission e source.
</p><p>
Para ativar o callback nosso arquivo EDC necessita de um program que 
emitirá os requeridos emission e source.
</p><div class="example"><a name="id2555609"></a><p class="title"><b>Exemplo 9.3. arquivo EDC</b></p><pre class="programlisting">
collections {
    group {
        name: "main";
        min: 200 100;

        parts {
            part {
                name: "bg";
                type: RECT;

                description {
                    rel1 {
                        relative: 0.0 0.0;
                        offset: 0 0;
                    }
                    rel2 {
                        relative: 1.0 1.0;
                        offset: -1 -1;
                    }
                    color: 255 255 255 255;
                }
            }
            part {
                name: "button";
                type: RECT;

                description {
                    rel1 {
                        relative: .4 .4;
                        offset: 0 0;
                    }
                    rel2 {
                        relative: .6 .6;
                        offset: 0 0;
                    }
                    color: 0 0 0 255;
                }
            }
        }
        programs {
            program {
                name: "down";
                signal: "mouse,down,*";
                source: "button";
                action: SIGNAL_EMIT "foo" "bar";
            }
        }
    }
}
</pre></div><p>
A parte de interesse é <tt class="literal">action: SIGNAL_EMIT "foo"
"bar"</tt>, isto fará o edje emitir uma emissão 
de <tt class="literal">foo</tt> com uma fonte de <tt class="literal">bar</tt>. 
</p><div class="example"><a name="id2555687"></a><p class="title"><b>Exemplo 9.4. Compilação</b></p><pre class="screen">
zero@oberon [edje_cb] -&gt; edje_cc default.edc
zero@oberon [edje_cb] -&gt; gcc -o cb main.c `ecore-config --cflags --libs` \
        `edje-config --cflags --libs`
</pre></div><p>
Edje faz isto realmente simples para uma interface completamente abstraida da implementação.
A única coisa que a interface precisa saber é enviar as emission e source corretas 
enquanto os eventos ocorrem.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2555448"></a>Receita: Trabalhando com arquivos Edje</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Quando está trabalho com arquivos .edc e .eet você muitas vezes precisa transformar um arquivo no outro. 
Em ajuda, Edje fornece um grupo de ferramentas para facilitar estas transformações.
</p><p>
Os programas disponíves são:
</p><div class="variablelist"><dl><dt><span class="term">edje_cc</span></dt><dd><p>Compila um arquivo EDC, imagens e fontes, dentro de um arquivo EET</p></dd><dt><span class="term">edje_decc</span></dt><dd><p>Descompila um arquivo EET retornando o arquivo EDC, as imagens e as fontes</p></dd><dt><span class="term">edje_recc</span></dt><dd><p>Recompila um arquivo EET</p></dd><dt><span class="term">edje_ls</span></dt><dd><p>Lista os grupos em um arquivo EET</p></dd><dt><span class="term">edje</span></dt><dd><p>Mostar os grupos em um arquivo EET</p></dd></dl></div><p>
Cada um destes programas são discutidos com mais detalhes abaixo:
</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a name="id2555005"></a>edje_cc</h3></div></div><div></div></div><p>
<tt class="literal">edje_cc</tt> é um dos principais programas Edje que você irá usar.
Ele é responsável pela compilação dos seus arquivos EDC, incluindo imagens e fonts, 
dentro dos arquivos EET correspondentes.
</p><div class="example"><a name="id2555027"></a><p class="title"><b>Exemplo 9.5. Uso do edje_cc</b></p><pre class="screen">
  edje_cc [OPÇÕES] arquivo_de_entrada.edc [arquivo_de_saida.eet]
</pre></div><div class="variablelist"><p class="title"><b>Opções</b></p><dl><dt><span class="term">-id <span class="emphasis"><em>image/directory</em></span></span></dt><dd><p>Adiciona um diretório como path relativo para procurar pelas imagens</p></dd><dt><span class="term">-fd <span class="emphasis"><em>font/directory</em></span></span></dt><dd><p>Adiciona um diretório como path relativo para procurar pelas fontes</p></dd><dt><span class="term">-v</span></dt><dd><p>Saída em modo prolixo (detalhado)</p></dd><dt><span class="term">-no-lossy</span></dt><dd><p>Não permitir imagens com lossy compression
      <sup>[<a name="fnrex1a" href="#ftn.fnrex1a">1</a>]</sup>
    </p></dd><dt><span class="term">-no-comp</span></dt><dd><p>Não permitir que as imagens sejam armazenadas com lossless compression
      <sup>[<a name="fnrex1b" href="#ftn.fnrex1b">2</a>]</sup>
    </p></dd><dt><span class="term">-no-raw</span></dt><dd><p>Não permitir que as imagens sejam armazenadas com zero compressão (imagem crua)</p></dd><dt><span class="term">-min-quality <span class="emphasis"><em>VALOR</em></span></span></dt><dd><p>Não permitir imagens lossy<sup>[<a href="#ftn.fnrex1a">1</a>]</sup> com qualidade &lt; VAL (0-100)</p></dd><dt><span class="term">-max-quality <span class="emphasis"><em>VAL</em></span></span></dt><dd><p>Não permitir imagens lossy<sup>[<a href="#ftn.fnrex1a">1</a>]</sup> com qualidade &gt; VAL (0-100)</p></dd><dt><span class="term">-scale-lossy <span class="emphasis"><em>VAL</em></span></span></dt><dd><p>Escalar image lossy<sup>[<a href="#ftn.fnrex1a">1</a>]</sup> por este fator de porcentagem(0 - 100)</p></dd><dt><span class="term">-scale-comp <span class="emphasis"><em>VAL</em></span></span></dt><dd><p>Escalar imagem lossless<sup>[<a href="#ftn.fnrex1b">2</a>]</sup> por este fator de porcentagem(0 - 100)</p></dd><dt><span class="term">-scale-raw <span class="emphasis"><em>VAL</em></span></span></dt><dd><p>Escalar imagem sem compressão (imagem crua) por este fator de procentagem(0 - 100)</p></dd><dt><span class="term">-D<span class="emphasis"><em>define_val</em></span>=<span class="emphasis"><em>to</em></span></span></dt><dd><p>Definições ao estilo CPP, para definir entrada de macros para o fonte .edc</p></dd></dl></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a name="id2556633"></a>edje_decc</h3></div></div><div></div></div><p>
<tt class="literal">edje_decc</tt> permite descompilar arquivo EET de volta para EDC bem como as imagens e fontes. 
Isto facilita distribuir seu fonte para fazer o arquivo EET sempre que necessitar e o usuário final 
terá acesso ao código e ao produto final.
</p><div class="example"><a name="id2556654"></a><p class="title"><b>Exemplo 9.6. Uso do edje_decc</b></p><pre class="screen">
  edje_decc arquivo_de_entrada.eet
</pre></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a name="id2556670"></a>edje_recc</h3></div></div><div></div></div><p>
<tt class="literal">edje_recc</tt> permite recompilar um arquivo EET sem 
necessariamente descompilar primeiro. Isto lhe permite modificar os parâmetros 
passado pelo <tt class="literal">edje_cc</tt> para modificar o visual e as exigências do tamanho.
</p><div class="example"><a name="id2556697"></a><p class="title"><b>Exemplo 9.7. Uso do edje_recc</b></p><pre class="screen">
  edje_recc [OPÇÕES] arquivo_de_entrada.eet
</pre></div><div class="variablelist"><p class="title"><b>Opções</b></p><dl><dt><span class="term">-v</span></dt><dd><p>Saída em modo prolixo (detalhado)</p></dd><dt><span class="term">-no-lossy</span></dt><dd><p>Não permitir imagens com lossy compression<sup>[<a href="#ftn.fnrex1a">1</a>]</sup></p></dd><dt><span class="term">-no-comp</span></dt><dd><p>Não permitir que as imagens sejam armazenadas com lossless compression<sup>[<a href="#ftn.fnrex1b">2</a>]</sup></p></dd><dt><span class="term">-no-raw</span></dt><dd><p>Não permitir que as imagens sejam armazenadas com zero compressão (imagem crua)</p></dd><dt><span class="term">-min-quality <span class="emphasis"><em>VAL</em></span></span></dt><dd><p>Não permitir imagens lossy<sup>[<a href="#ftn.fnrex1a">1</a>]</sup> com qualidade &lt; VAL (0-100)</p></dd><dt><span class="term">-max-quality <span class="emphasis"><em>VAL</em></span></span></dt><dd><p>Não permitir imagens lossy<sup>[<a href="#ftn.fnrex1a">1</a>]</sup> com qualidade &gt; VAL (0-100)</p></dd></dl></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a name="id2556827"></a>edje_ls</h3></div></div><div></div></div><p>
<tt class="literal">edje_ls</tt> fornece uma listagem de todos os grupos dentro 
de um arquivo EET informado. Este é um jeito rápido de ver o que há disponível no EET informado.
</p><div class="example"><a name="id2556845"></a><p class="title"><b>Exemplo 9.8. Uso do edje_ls</b></p><pre class="screen">
  edje_ls [OPÇÕES] arrquivo_de_entrada.eet ...
</pre></div><div class="variablelist"><p class="title"><b>Opções</b></p><dl><dt><span class="term">-o <span class="emphasis"><em>arquivodesaida.txt</em></span></span></dt><dd><p>Direciona a listagem das coleções para um arquivo</p></dd></dl></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h3 class="title"><a name="id2556891"></a>edje</h3></div></div><div></div></div><p>
<tt class="literal">edje</tt> também é um dos principais programas que você irá usar.
<tt class="literal">edje</tt> permite você ver cada um dos grupos do seu programa. Ele 
permite você ver como os items estão sendo vistos e como eles reagem aos sinais.
</p><div class="example"><a name="id2556937"></a><p class="title"><b>Exemplo 9.9. Uso do edje</b></p><pre class="screen">
  edje file_to_show.eet [OPÇÕES] [que_coleções_mostrar] ...
</pre></div><div class="variablelist"><p class="title"><b>Opções</b></p><dl><dt><span class="term">-gl</span></dt><dd><p>Usa OpenGL para renderizar</p></dd><dt><span class="term">-g <span class="emphasis"><em>W</em></span>x<span class="emphasis"><em>H</em></span></span></dt><dd><p>Ajuste a geometria da janela para WxH (Largura x Altura)</p></dd><dt><span class="term">-fill</span></dt><dd><p>Faz o item ocupar toda a janela</p></dd></dl></div></div><p>
Estas cinco ferramentas simples devem auxiliar na construção e manutenção de 
seus arquivos Edje e EETs. Eles também facilitam a recuperação do fonte 
que compreende um arquivo EET informado, tornando fácil o aprendizado de como 
desempenham trabalhos diferentes.
</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.fnrex1a" href="#fnrex1a">1</a>] </sup>lossy compression é a técnica de compressão que parte dos dados são perdidos, esta técnica tenta elimiar informações redundantes ou desnecessárias causando perda de qualidade</p></div><div class="footnote"><p><sup>[<a name="ftn.fnrex1b" href="#fnrex1b">2</a>] </sup>lossless compression a técnica de compressão que permite que os dados sejam descomprimidos sem nenhuma perda de informações, ou seja os dados reconstruídos são exatamente iguais aos dados originais.</p></div></div></div><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a name="id2552491"></a>Capítulo 10. Edje EDC e Embryo</h2></div></div><div></div></div><div class="toc"><p><b>Índice</b></p><dl><dt><a href="#id2558153">Receita: Comutador Edje/Embryo</a></dt><dt><a href="#id2559323">Receita: Efeito de dilução Edje no texto </a></dt></dl></div><p>
Os arquivos fontes de Coleções de Dados Edje ou Edje Data Collections ( EDC ) permitem uma fácil criação de ricas e potentes interface 
gráfica. Suas aplicações Edje está dividida em duas partes distintas, o código da aplicação ( usando chamdas de <tt class="filename">Edje.h</tt> ) 
e a descrição da interface em EDC. A única conectividade requerida entre sua interface e o código da sua aplicação são os sinais emitidos por 
sua interface que são recebidas por callbacks Edje no código da sua aplicação.
</p><p>
Um EDC está dividio em várias seções maiores descrevendo as imagens e fontes que são usadas 
na interface, descrições de como as várias partes ( <tt class="literal">part</tt> ) da interface 
são dispostas, e descrições de ações ou <tt class="literal">program</tt> que ocorrem quando se interage com sua 
interface. Esta funcionalidade pode ser suplementada usando a linguagem de script Embryo para adicionar 
programabilidade no estilo C na própria EDC Edje.
</p><p>
O resultado final de uma EDC, incluindo todas as fonts e imagens, é um único EET. Já que a interface completa 
é disponível em um único arquivo de "tema" é drásticamente simplificada.
</p><p>
Embora os EDC Edje possam ser vistos como "temas" eles são muito mais que isto. Um "tema" tradicional é um 
arquivo ou grupo de arquivos que incrementam uma interface gráfica existente mudando a cor dos elementos ou 
modificando as imagens que compoem a própria interface. Mas estes métodos são insuficiente para 
realmente mudar o design da interface de uma aplicação, limitando os criadores de temas de modifica-los e 
impossibilitando um redesenho da aplicação em algum ponto para expandir as capacidades da interface 
para uma maior funcionalidade. Uma aplicação GTK sempre terá um aspecto semelhante independente do tema 
que usar. Um exemplo simples é que uma aplicação GTK ou QT sempre terá uma forma retangular e se tem uma 
borda não se pode tirá-la mudando o tema. No entanto, uma aplicação Edje poderá mudar da forma 
retangular para oval com uma simples modificação da EDC, ou poderá remover e rearrajnar todos os elementos da 
interface sem nunca tocar no código. Desta maneira Edje permite uma grande quantidade controle e uma 
flexibilidade maior que qualquer outra solução na comunidade Open Source e permite um modelo Aberto de 
programação para permitir que não programadores ( como muitos criadores de temas são ) contribuam e modifiquem 
as coisas como desejarem.
</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2558153"></a>Receita: Comutador Edje/Embryo</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Corey</span> <span class="othername">'atmos'</span> <span class="surname">Donohoe</span></h3></div></div></div><div></div></div><p>
No início <a href="http://www.rasterman.com" target="_top">Raster</a> fez o Edje, e isto era bom. 
Os homens das cavernas que descobriram o Edje nas paredes das cavernas (#edevelop) ficaram 
maravilhados, mas logo perceberam muitos inconvenientes. Tendo uma quantidade certa de criatividade 
você poderia fazer coisas, comutadores por exemplo, mas precisava-se usar alquimia para fazer 
corretamente. Para fins históricos, é fornecido um comutador Edje sem Embryo. Veja 
<a href="#ex-Edje_no_Embryo" title="Exemplo 10.6. Comutador Edje sem Embryo">Edje sem Embryo</a> mais abaixo.
</p><p>
Você observará que precisa-se falar em sinais com a sua aplicação para determinar o estado do seu comutador. Então, 
sem mais demora, aqui vai um comutador Edje usando Embryo, de uma maneira <span class="emphasis"><em>muito</em></span> mais elegante.
</p><p>
O script Embryo dentro do Ejde, no doravante script EE, te dá variáveis. Você pode ter inteiros, números de 
ponto flutuante e strings. Isto significa basicamente que pode ter alguma lógica de programação nos teus 
edjes. Nada complexo como estruturas mas variáveis simples contidas em um grupo poderiam assemelhar-se
aos membros de estruturas.
</p><p>
A primeira parte do EE é escolher as suas variáveis. Neste simples exemplo só temos uma variável, e 
você envolveu-a em um group edje declarando um bloco <span class="emphasis"><em>script { ... }</em></span>. 
<span class="emphasis"><em>button_toggle_state</em></span> é implicitamente um inteiro, e será usando como vaiável 
boolena para permitirnos saber se o botão de comutação está ativado ou desativado. A parte legal 
desta variável é que podemos usá-la como uma forma de comunicação entre nossa aplicação e nosso 
edje. Ademais você pode tranquilizar-se sabendo (assumindo que você fez isto corretamente) que 
nenhuma artimanha do ejde lançará sua aplicação ao limbo.
</p><p>
</p><div class="example"><a name="id2559565"></a><p class="title"><b>Exemplo 10.1. Criando a variável</b></p><pre class="programlisting">
collections {
    group {
        name: "Toggler";
	script {
	    public button_toggle_state;
	}
	parts {
	    part {
		...
	    }
	}
	programs {
	    program {
		...
	    }
	}
    }
}
</pre></div><p>
</p><p>
A segunda aprte do escript EE é inicializar as variáveis. Na maioria das vezes 
pode-se assumir que estas variáveis serão inicializadas com zero, mas é um bom costume você mesmo inicializa-las.
O Edje emite um sinal "load" quando o grupo é carregado na memória, esta é a sua oportunidade de 
iniciar as variáveis embryo.

</p><div class="example"><a name="id2559592"></a><p class="title"><b>Exemplo 10.2. Inicializando variáveis</b></p><pre class="programlisting">
program {
    name: "group_loaded";
    signal: "load";
    source: "";
    script {
	set_int(button_toggle_state, 0);
    }
}
</pre></div><p>
</p><p>
A terceira parte é propriamente dar um aspecto ao seu edje. Para este exemplo
é usado retângulos, mas imagens e textos também funcionam corretamente.
Há um objecto de background para consistência, e há um retângulo chamado "toggler" (comutador).
toggler tem dois estados, o estado default ( implicitamente desabilitado ) e um habilitado. Quando
toggler é clicado deverá mudar para o outro estado. off -&gt; on, on -&gt; off. toggler terá uma
cor vermelha quando desabilitado e quando habilitado será azul, de modo que possa  ser
facilmente diferênciado. O background será branco porque não pode ser vermelho e nem  azul :D
</p><p>
</p><div class="example"><a name="id2559638"></a><p class="title"><b>Exemplo 10.3. O botão toggler</b></p><pre class="programlisting">
collections {
    group {
        name: "Toggler";
        script {
            public button_toggle_state;
        }
        parts {
            part {
                name: "background";
                type: RECT;
                mouse_events: 0;
                description {
		    state: "default" 0.0;
                    color: 255 255 255 255;
                    rel1 { relative: 0.0 0.0; offset: 0 0; }
                    rel2 { relative: 1.0 1.0; offset: 0 0; }
                }
            }
            part {
                name: "toggle";
                type: RECT;
                mouse_events: 1;
                description {
                    state: "default" 0.0;
                    color: 255 0 0 255;
                    rel1 { relative: 0.0 0.0; offset: 10 10; }
                    rel2 { relative: 1.0 1.0; offset: -10 -10; }
                }
                description {
                    state: "on" 0.0;
                    color: 0 0 255 255;
                    rel1 { relative: 0.0 0.0; offset: 10 10; }
                    rel2 { relative: 1.0 1.0; offset: -10 -10; }
                }
            }
        }
        programs {
            program {
                name: "group_loaded";
                signal: "load";
                source: "";
                script {
                    set_int(button_toggle_state, 0);
                }
            }
        }
    }
}
</pre></div><p>
</p><p>
A quarta parta está conectando-se aos eventos de mouse para disparar a comutação.
Não apenas mudando a variável Embryo, mas também mudando a aparência do nosso ejde.
Este exemplo usa o click normal do botão esquerdo do mouse para mudar o estado do comutador,
nos termos do edje "mouse,clicked,1". Este exemplo não usa a chamada a função incorporada no Embryo
<span class="emphasis"><em>set_state</em></span>, mas emite sinais que são recebidas por outros programas. A razão por
trás disto é nos permitir transições visuais suaves entre os dois estados. A chamada à função Embryo set_state
é uma mudança de estado imediato, e não tem um aspecto tão agradável como a transição SINUSOIDAL usada nos seguintes
framentos.
</p><p>
</p><div class="example"><a name="id2559708"></a><p class="title"><b>Exemplo 10.4. Conectando-se com os eventos de mouse</b></p><pre class="programlisting">
collections {
    group {
        name: "Toggler";
        script {
            public button_toggle_state;
        }
        parts {
            part {
                 ...
            }
	}
	programs {
	    program {
                name: "toggle_icon_mouse_clicked";
                signal: "mouse,clicked,1";
                source: "toggle";
                script {
		    if(get_int(button_toggle_state) == 0) {
			set_int(button_toggle_state, 1);
                        emit("toggle,on", "");
                    }
                    else {
                        set_int(button_toggle_state, 0);
			emit("toggle,off", "");
		    }
		}
            }
            program {
                name: "toggle_on";
                signal: "toggle,on";
                source: "";
                action: STATE_SET "on" 0.0;
                target: "toggle";
		transition: SINUSOIDAL 0.5;
            }
	    program {
		name: "toggle_off";
                signal: "toggle,off";
                source: "";
                action: STATE_SET "default" 0.0;
                target: "toggle";
                transition: SINUSOIDAL 0.5;
             }
         }
     }
 }
</pre></div><p>
</p><p>
A quinta parte esta ponderando o senário apresentado. Isto é apenas a ponta da iceberg no que diz respeito
a scripts EE. Você pode adicionar mais variávels para elevar o estado interno que não está completamente
relacionado com sua aplicação. Há nuances entre isto e o uso prático das variávels Embryo, ademais,
entendendo estes blocos de contrução será mais simples escrever ou trabalhar com aplicações scripts EE.
</p><p>
 </p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>O que há de errado com a técnica aqui apresentada?</p></li><li style="list-style-type: disc"><p>O que acontece se a aplicação quer o comutador "on" por default?</p></li></ul></div><p>
</p><p>
Você pode usar um script similar abaixo para construir este exemplo.
</p><div class="example"><a name="id2559365"></a><p class="title"><b>Exemplo 10.5. Contruir o script</b></p><pre class="programlisting">
#!/bin/sh -e
THEME="default"
APPNAME=""
edje_cc -v $THEME.edc $THEME.eet
if [ $? = "0" ]; then
    if [ "$APPNAME" = "" ]; then
	echo "Build was successful"
    else
	PREFIX=`dirname \`which $APPNAME\` | sed 's/bin//'`
	sudo cp $THEME.eet $PREFIX"share/$APPNAME/themes/"
	echo -n "Installed theme to "
	echo $PREFIX"share/$APPNAME/themes/"
    fi
else
    echo "Building failed"
fi
</pre></div><p>
</p><p>
</p><div class="example"><a name="ex-Edje_no_Embryo"></a><p class="title"><b>Exemplo 10.6. Comutador Edje sem Embryo</b></p><pre class="programlisting">
images { }

collections {
    group {
        name, "Rephorm";
        min, 50 50;
        max, 75 75;
        parts {
            part {
                name, "Clip";
                type, RECT;
                mouse_events, 0;
                description {
                    state, "default" 0.0;
                    visible, 1;
                    rel1 { relative, 0.0 0.0; offset, 5 5; } 
		    rel2 { relative, 1.0 1.0; offset, -5 -5; }
                    color, 255 255 255 255;
                }
                description {
                    state, "hidden" 0.0;
                    visible, 1; 
		    rel1 { relative, 0.0 0.0; offset, 5 5; } 
		    rel2 { relative, 1.0 1.0; offset, -5 -5; }
                    color, 255 255 255 128;
                }
            }
            part {
                name, "On";
                type, RECT;
                mouse_events, 1;
                clip_to, "Clip";
                description {
                    state, "default" 0.0;
                    visible, 0;
                    rel1 { relative, 0.0 0.0; offset, 5 5; } 
		    rel2 { relative, 1.0 1.0; offset, -5 -5; }
                    color, 255 0 0 0;
                }
                description {
                    state, "visible" 0.0;
                    visible, 1;
                    rel1 { relative, 0.0 0.0; offset, 5 5; } 
		    rel2 { relative, 1.0 1.0; offset, -5 -5; }
                    color, 255 0 0 255;
                }
            }
            part {
                name, "Off";
                type, RECT;
                mouse_events, 1;
                clip_to, "Clip";
                description {
                    state, "default" 0.0;
                    visible, 1;
                    rel1 { relative, 0.0 0.0; offset, 5 5; } 
		    rel2 { relative, 1.0 1.0; offset, -5 -5; }
                    color, 0 0 255 255;
                }
                description {
                    state, "visible" 0.0;
                    visible, 0;
                    rel1 { relative, 0.0 0.0; offset, 5 5; } 
		    rel2 { relative, 1.0 1.0; offset, -5 -5; }
                    color, 0 0 255 0;
                }
            }
            part {
                name, "Grabber";
                type, RECT;
                mouse_events, 1;
                repeat_events, 1;
                clip_to, "Clip";
                description {
                    state, "default" 0.0;
                    visible, 1;
                    rel1 { relative, 0.0 0.0; offset, 5 5; } 
		    rel2 { relative, 1.0 1.0; offset, -5 -5; }
                    color, 255 255 255 0;
                }
            }
        }
        programs {
            program {
                name, "ToggleOn";
                signal, "mouse,clicked,1";
                source, "Off";
                action, STATE_SET "visible" 0.0;
                target, "Off";
                target, "On";
                transition, SINUSOIDAL 0.5;
            }
            program {
                name, "ToggleOff";
                signal, "mouse,clicked,1";
                source, "On";
                action, STATE_SET "default" 0.0;
                target, "Off";
                target, "On";
                transition, SINUSOIDAL 0.5;
            }
            program {
                name, "GrabberIn";
                signal, "mouse,in";
                source, "Grabber";
                action, STATE_SET "default" 0.0;
                target, "Clip";
                transition, SINUSOIDAL 0.5;
            }
            program {
		    name, "GrabberOut";
                signal, "mouse,out";
                source, "Grabber";
                action, STATE_SET "hidden" 0.0;
                target, "Clip";
                transition, SINUSOIDAL 0.5;
	    }
        }
    }
}
</pre></div><p>
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2559323"></a>Receita: Efeito de dilução Edje no texto </h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Os efeitos de texto podem dar uma aparência legal ao seu programa. Mas e 
se caso você desejar incorporar nestes efeitos um efetio de diluição? Edje faz isto 
possível e relativalmente simples.
</p><p>
Todo o que você precisa fazer é incorporar o atributo <tt class="literal">color3</tt> conforme 
vai diluindo o atributo <tt class="literal">color</tt> do texto. 
<tt class="literal">color3</tt> mudará os valores de cor do efeito.
</p><p>
Isto é ilustrado no seguinte exemplo:
</p><div class="example"><a name="id2560463"></a><p class="title"><b>Exemplo 10.7. Diluindo efeito com texto</b></p><pre class="programlisting">
collections {
    group {
        name, "Main";
        min, 30 30;

        parts {
            part {
                name, "foo";
                type, TEXT;
                effect, SOFT_SHADOW; 
                mouse_events, 1;

                description {
                    state, "default" 0.0;
                    rel1 {
                        relative, 0 0;
                        offset, 0 0;
                    }
                    rel2 {
                        relative, 1.0 1.0;
                        offset, -1 -1;
                    }

                    text {
                        text, "foo text";
                        font, "Vera";
                        size, 22;
                    }
                    color, 255 255 255 255;
                    color3, 0 0 0 255;
                }
                description {
                    state, "out" 0.0;
                    rel1 {
                        relative, 0 0;
                        offset, 0 0;
                    }
                    rel2 {
                        relative, 1.0 1.0;
                        offset, -1 -1;
                    }

                    text {
                        text, "foo text";
                        font, "Vera";
                        size, 22;
                    }
                    color, 0 0 0 0;
                    color3, 255 255 255 0;
                }
            }
        }
        programs {
            program {
                name, "foo";
                signal, "mouse,in";
                source, "foo";
                action, STATE_SET "out" 0.0;
                transition, SINUSOIDAL 2.0;
                target, "foo";
            }
            program {
                name, "foo";
                signal, "mouse,out";
                source, "foo";
                action, STATE_SET "default" 0.0;
                transition, SINUSOIDAL 2.0;
                target, "foo";
            }
        }
    }
}
</pre></div><p>
Este exemplo pode ser compilado para dentro de um <tt class="literal">.eet</tt> 
com o seguinte comando.
</p><div class="example"><a name="id2560528"></a><p class="title"><b>Exemplo 10.8. Compliação</b></p><pre class="screen">
zero@oberon[edje_text] -&gt; edje_cc text.edc
</pre></div><p>
Por alterar o valor de <tt class="literal">color3</tt> com o valor de <tt class="literal">color</tt> 
você será capaz de alterar a aparância dos seus efeitos com seu texto.
</p></div></div><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a name="id2559205"></a>Capítulo 11. EWL</h2></div></div><div></div></div><div class="toc"><p><b>Índice</b></p><dl><dt><a href="#id2559267">Receta: Introducción a EWL</a></dt></dl></div><p>
A Enlightened Widget Library (EWL) é um conjunto de ferramentas (toolkit) de widget desenvolvidas sobre
as outras outras bibliotecas da EFL. Ewl usa Evas como backend de renderização e
sua aparência é abstraída para ser controlada pelo Edje.
</p><p>
EWL é similar a muitos outros toolkits entre eles o GTK, QT e MOTIF. As APIs se diferem, mas os 
conceitos são os mesmos.
</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2559267"></a>Receta: Introducción a EWL</h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Mediante o uso da Enlightened Widget Library (EWL), uma porção maior de potência pode ser posta nas mãos dos programadores com
pouco esforço.
</p><p>
Esta introdução á EWL mostrará como criar uma simples aplicação para visualização de texto com uma barra de menu
e um dialogo de arquivo. A área de texto terá barras de rolagem e permitirá também rolar usando as teclas do teclado ou
a roda do mouse.
</p><div class="example"><a name="id2559260"></a><p class="title"><b>Exemplo 11.1. Includes e declarações</b></p><pre class="programlisting">
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;Ewl.h&gt;

#define PROG    "EWL Text Viewer"

/* globals */
static Ewl_Widget *main_win = NULL;
static Ewl_Widget *fd_win = NULL;

/* pre-declarations */
static void destroy_cb(Ewl_Widget *, void *, void *);
static void destroy_filedialog_cb(Ewl_Widget *, void *, void *);
static void open_file_cb(Ewl_Widget *, void *, void *);
static void home_cb(Ewl_Widget *win, void *ev, void *data);
static void file_menu_open_cb(Ewl_Widget *, void *, void *);
static void key_up_cb(Ewl_Widget *, void *, void *);

static char *read_file(char *);
static void mk_gui(void);
</pre></div><p>
O include necessário para escrever uma aplicação Ewl é &lt;Ewl.h&gt;.
Declaramos a janela principal e o dialogo de arquivo como globais para facilitar o acesso nas funções de callback.
Elas não precisam ser globais, mais para o propósito desta exemplo é mais simples que sejam.
</p><div class="example"><a name="id2559321"></a><p class="title"><b>Exemplo 11.2. main</b></p><pre class="programlisting">
/* lets go */
int main(int argc, char ** argv) {
    ewl_init(&amp;argc, argv);
    mk_gui();
    ewl_main();
    return 0;
}
</pre></div><p>
A função principal para nosso visualizador de texto é muito simples. Começamos inicializando o ewl mediante
a chamada <tt class="function">ewl_init()</tt>. Ewl pega argc e argv para ler alguns parâmetros de linha de comando.
Isto inclue coisas como iniciar o tema que vai usar ( --ewl-theme ) ou iniciar o motor de renderização
( --ewl-software-x11, --ewl-gl-x11, etc. ).
</p><p>

<tt class="function">ewl_init()</tt> se encarrega de todo o trabalho de inicializar as outras bibliotecas requeridas,
abstraindo isto do programador em uma interface simples.
</p><p>
A chamada a mk_gui inicializará a janela principal e qualquer conteúdo requerido.
</p><p>
A chamada a <tt class="function">ewl_main()</tt> inicia o laço principal de processo, e ao terminar controla
toda a finalização requida pela aplicação, assim sendo, não há chamada de finalização na nossa rotina principal.
</p><div class="example"><a name="id2561692"></a><p class="title"><b>Exemplo 11.3. mk_gui: Criar a janela</b></p><pre class="programlisting">
/* build the main gui */
static void mk_gui(void) {
    Ewl_Widget *box = NULL, *menu_bar = NULL;
    Ewl_Widget *text_area = NULL, *scroll = NULL;

    /* create the main window */
    main_win = ewl_window_new();
    ewl_window_title_set(EWL_WINDOW(main_win), PROG);
    ewl_window_name_set(EWL_WINDOW(main_win), PROG);
    ewl_window_class_set(EWL_WINDOW(main_win), PROG);

    ewl_object_size_request(EWL_OBJECT(main_win), 200, 300);
    ewl_object_fill_policy_set(EWL_OBJECT(main_win), EWL_FLAG_FILL_FILL);

    ewl_callback_append(main_win, EWL_CALLBACK_DELETE_WINDOW, destroy_cb, NULL);
    ewl_widget_show(main_win);
</pre></div><p>
A primeira coisa que precisamos fazer para executar nossa aplicação é criar a janela principal da aplicação.
Isto é feito por meio da chamada a <tt class="function">ewl_window_new()</tt>.
Uma vez com a janela continuamos informando o título
 (como aparecerá na barra de título da janela do Gerenciador de Janelas), o nome e a classe da janela.
</p><p>
Uma vez informada as informações principais da janela, solicitamos o tamanho default da janela de 200x300 por meio
da chamada <tt class="function">ewl_object_size_request</tt>. Junto com o tamanho default, podemos
informar o tamanho máximo e mínimo da janela atravéz da chamada <tt class="function">ewl_object_minimum_size_set</tt>
e <tt class="function">ewl_object_maximum_size_set</tt>. Mas como isto não é necessário para esta aplicação eles ficarão de fora.
</p><p>
A configuração final da janela é feita selecionando a politica de preenchimento com <tt class="function">ewl_object_fill_policy_set</tt>.
Isto ajusta a forma como o Ewl empacotará os widgets na janela, com um dos possíveis valores:
</p><div class="variablelist"><dl><dt><span class="term">EWL_FLAG_FILL_NONE</span></dt><dd><p>Não preencher ou encolher em nenhuma direção</p></dd><dt><span class="term">EWL_FLAG_FILL_HSHRINK</span></dt><dd><p>Encolher horizontalmente</p></dd><dt><span class="term">EWL_FLAG_FILL_VSHRINK</span></dt><dd><p>Encolher verticalmente</p></dd><dt><span class="term">EWL_FLAG_FILL_SHRINK</span></dt><dd><p>Encolher tanto horizontal como verticalmente</p></dd><dt><span class="term">EWL_FLAG_FILL_HFILL</span></dt><dd><p>Preencher horizontalmente</p></dd><dt><span class="term">EWL_FLAG_FILL_VFILL</span></dt><dd><p>Preencher verticalmente</p></dd><dt><span class="term">EWL_FLAG_FILL_FILL</span></dt><dd><p>Preencher tanto horizontal como verticalmente</p></dd><dt><span class="term">EWL_FLAG_FILL_ALL</span></dt><dd><p>Encolher e Preencher de uma vez</p></dd></dl></div><p>
Após definir todas as propriedades da janela anexa-se um callback para capturar a destruição da janela principal com
<tt class="function">ewl_callback_append()</tt>. A função <tt class="function">destroy_cb()</tt> será chamada caso alguém
requeira que a janela seja destruida de alguma maneira.
</p><p>
Mostramos a janela principal com uma chamada a <tt class="function">ewl_widget_show()</tt>. Se <tt class="function">ewl_widget_show()</tt>
não for chamada nada aparecerá na tela. Todos os widgets estão invisíveis até que explicatamente solicitemos mostra-los. Em oposição a isto
é a <tt class="function">ewl_widget_hide()</tt> que removerá um widget da tela.
</p><div class="example"><a name="id2561962"></a><p class="title"><b>Exemplo 11.4. O container principal</b></p><pre class="programlisting">
    /* create the main container */
    box = ewl_vbox_new();
    ewl_container_child_append(EWL_CONTAINER(main_win), box);
    ewl_object_fill_policy_set(EWL_OBJECT(box), EWL_FLAG_FILL_FILL);
    ewl_widget_show(box);
</pre></div><p>
Podemos empacotar todos nossos widgets na própria janela principal, mas isto pode causar problemas se desejarmos
mudar as coisas facilmente, então criaremos uma caixa dentro da janela principal para que mantenha
todos os nossos widgets.
</p><p>
Isto é feito criando uma caixa vertical com <tt class="function">ewl_vbox_new()</tt>.
Então se toma a caixa e acrescenta a lista de filhos da janela principal com <tt class="function">ewl_container_child_append()</tt>.
Depois de anexar a janela selecionamos uma politica de preenchimento para preencher tanto na horizontal como na vertical com
<tt class="function">ewl_object_fill_policy_set</tt>, e mostramos o widget com <tt class="function">ewl_widget_show()</tt>.
</p><p>
A ordem em que vai se pondo os widgets no container afetará a maneira como se mostra a aplicação.
O primeiro widget empacotado será o primeiro widget a ser mostrado. Como especificamos uma caixa vertical
empacotaremos os widgets começando do topo até o fundo da nossa tela.
</p><div class="example"><a name="id2562037"></a><p class="title"><b>Exemplo 11.5. Criar a barra de menu</b></p><pre class="programlisting">
    /* create the menu bar */
    menu_bar = ewl_hbox_new();
    ewl_container_child_append(EWL_CONTAINER(box), menu_bar);
    ewl_object_fill_policy_set(EWL_OBJECT(menu_bar), EWL_FLAG_FILL_HSHRINK);
    ewl_object_alignment_set(EWL_OBJECT(menu_bar), EWL_FLAG_ALIGN_LEFT);
    ewl_box_spacing_set(EWL_BOX(menu_bar), 4);
    ewl_object_padding_set(EWL_OBJECT(menu_bar), 5, 5, 5, 5);
    ewl_widget_show(menu_bar);
</pre></div><p>
O primeiro widget que adicionamos é a barra de menu. Colocaremos o próprio conteudo do menu mais tarde,
depois que os outros widgets tenham sido criados, mas precisamos adicionar a barra de menu primeiro.
</p><p>
As chamadas são as mesmas que vismos acima,  adicionar container pai, iniciar a politica de preenchimento, mostrar o widget.
As que não foram vitas antes incluem <tt class="function">ewl_object_alignment_set()</tt>, que informa como o widget será alinhado
dentro do container. Neste caso estamos usando EWL_FLAG_ALIGN_LEFT, mas podemos usar qualquer outro dos alinhamentos incluindo:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_CENTER</p></li><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_LEFT</p></li><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_RIGHT</p></li><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_TOP</p></li><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_BOTTOM</p></li></ul></div><p>
Assim o menu irá alinhar com o lado esquerdo da caixa principal.
</p><p>
Então especificamos o espaçamento dos itens do menu. Isto dará um pouco mais de espaço
entre os nossos itens de menu, isto é feito com <tt class="function">ewl_box_spacing_set()</tt>.
Depois de mudar o espaço mudamos o preenchimento ao redor da caixa como um todo com uma chamada à
<tt class="function">ewl_object_padding_set()</tt>, isto incrementará uma quantidade de espaço em volta do widget.
</p><div class="example"><a name="id2562149"></a><p class="title"><b>Exemplo 11.6. Criar o painel de rolagem</b></p><pre class="programlisting">
    /* create the scrollpane */
    scroll = ewl_scrollpane_new();
    ewl_container_child_append(EWL_CONTAINER(box), scroll);
    ewl_object_fill_policy_set(EWL_OBJECT(scroll), EWL_FLAG_FILL_FILL);
    ewl_scrollpane_hscrollbar_flag_set(EWL_SCROLLPANE(scroll), 
                                        EWL_SCROLLBAR_FLAG_AUTO_VISIBLE);
    ewl_scrollpane_vscrollbar_flag_set(EWL_SCROLLPANE(scroll), 
                                        EWL_SCROLLBAR_FLAG_AUTO_VISIBLE);
    ewl_widget_show(scroll);
</pre></div><p>
O painel de rolagem vai ser o pai do nosso objeto texto. O painel de rolagem nos dá toda a mágica para 
controlar as barras de rolagem e a sua própria rolagem.
</p><p>
O painel de rolagem é criado com uma chamada à <tt class="function">ewl_scrollpane_new()</tt>, e então anexamos 
o painel de rolagem na caixa principal e selecionamos a sua política de preenchimento.
</p><p>
As chamadas à ewl_scrollpane_[hv]scrollbar_flag_set() dizem ao Ewl como deverão compartar-se as barras de rolagem. 
Os valores possíveis são:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_SCROLLBAR_FLAG_NONE</p></li><li style="list-style-type: disc"><p>EWL_SCROLLBAR_FLAG_AUTO_VISIBLE</p></li><li style="list-style-type: disc"><p>EWL_SCROLLBAR_FLAG_ALWAYS_HIDDEN</p></li></ul></div><p>
Uma vez que as barras de rolagem tenham sido iniciadas pedimos ao Ewl que mostre o widget.
</p><div class="example"><a name="id2562228"></a><p class="title"><b>Exemplo 11.7. Criar a área de texto</b></p><pre class="programlisting">
    /* create the text area */
    text_area = ewl_text_new("");
    ewl_container_child_append(EWL_CONTAINER(scroll), text_area);
    ewl_object_padding_set(EWL_OBJECT(text_area), 1, 1, 1, 1);
    ewl_widget_show(text_area);
</pre></div><p>
A área de texto será responsável em manter o texto no nosso visualizador. O widget é criado com uma 
simples chamada à <tt class="function">ewl_text_new()</tt>. Isto causará a criação da área de texto, mas com um texto em branco. 
Como na barra de menu, incrementamos o preenchimento ao redor da área de texto para dar um pouco 
de espaço entre o texto e os outros elementos.
</p><div class="example"><a name="id2562267"></a><p class="title"><b>Exemplo 11.8. Criar o conteúdo do menu</b></p><pre class="programlisting">
    /* create the menu */
    {
        Ewl_Widget *file_menu = NULL, *item = NULL;
   
        /* create the file menu */ 
        file_menu = ewl_imenu_new(NULL, "file");
        ewl_container_child_append(EWL_CONTAINER(menu_bar), file_menu);
        ewl_widget_show(file_menu);
   
        /* add the open entry to the file menu */ 
        item = ewl_menu_item_new(NULL, "open");
        ewl_container_child_append(EWL_CONTAINER(file_menu), item);
        ewl_callback_append(item, EWL_CALLBACK_SELECT, file_menu_open_cb, 
                                                                text_area);
        ewl_widget_show(item);
   
        /* add the quit entry to the file menu */ 
        item = ewl_menu_item_new(NULL, "quit");
        ewl_container_child_append(EWL_CONTAINER(file_menu), item);
        ewl_callback_append(item, EWL_CALLBACK_SELECT, destroy_cb, NULL);
        ewl_widget_show(item); 
    }
</pre></div><p>
Agora que a área de texto foi criada podemos continuar por criar as entradas do menu. Fiz isto dentro do seu próprio bloco
para limitar o número de declarações no início da função, isto não é requerido por nenhuma razão.
</p><p>
O menu é criado com uma chamada à <tt class="function">ewl_imenu_new()</tt>. Esta função pega dois parâmetros, o primeiro é a 
imagen para mostrar com este menu, neste casso NULL, sou seja, sem imagem. O segundo parâmetro é o nome do menu tal 
como aparecerá na barra de menu.
</p><p>
Uma vez criado o menu, pode continuar por adicionar os itens do menu por meio da uma chamada à 
<tt class="function">ewl_menu_item_new()</tt>. Esta novamente pega dois parâmetros, o ícone para mostrar 
junto com esta entrada no menu, e o nome que aparecerá no menu.
</p><p>
Ao passo que os elementos são adicionados no menu fazemos uma chamada à <tt class="function">ewl_callback_append()</tt> para 
conectar à chamada EWL_CALLBACK_SELECT. A função dada será executada quando o usuário clicar no item de menu. No caso de
"open" tivemos que passar a área de texto ao callback de open para permitirmos modificar facilmente seu conteúdo.
</p><p>
Outros menus poderão ser adicionados da mesma maneira, mas para esta aplicação apenas um menu é necessário.
</p><div class="example"><a name="id2562411"></a><p class="title"><b>Exemplo 11.9. Vincular callbacks</b></p><pre class="programlisting">
    ewl_callback_append(main_win, EWL_CALLBACK_KEY_UP, key_up_cb, scroll);
}
</pre></div><p>
Uma vez que tudo está iniciado na janela principal, adicionamos os callbacks que desejamos receber. Neste caso 
estamos vinculando-nos ao callback EWL_CALLBACK_KEY_UP. Não necessitamos fazer nada para que a roda do mouse deslize 
o painel de rolagem pois isto é configurado no próprio painel de rolagem.
</p><div class="example"><a name="id2562440"></a><p class="title"><b>Exemplo 11.10. callback de finalização</b></p><pre class="programlisting">
/* destroy the app */
static void destroy_cb(Ewl_Widget *win, void *ev, void *data) {
    ewl_widget_destroy(win);
    ewl_main_quit();
}
</pre></div><p>
Quando a janela principal é fechada, destruímos o widget que está nela mediante uma chamada à <tt class="function">ewl_widget_destroy()</tt>.
Depois que a janela é destruída solicitamos ao Ewl que desejamos saír chamando a <tt class="function">ewl_main_quit()</tt>. 
Isto fará com que o Ewl pare o loop de processamento principal e retornará da chamada prévia à <tt class="function">ewl_main()</tt>.
</p><div class="example"><a name="id2562487"></a><p class="title"><b>Exemplo 11.11. Callback do item open do menu file</b></p><pre class="programlisting">
/* the file menu open button callback */
static void file_menu_open_cb(Ewl_Widget *win, void *ev, void *data) {
    Ewl_Widget *fd = NULL;
    Ewl_Widget *box = NULL;
    Ewl_Widget *home = NULL;

    /* create the file dialog window */
    fd_win = ewl_window_new();
    ewl_window_title_set(EWL_WINDOW(fd_win), PROG " -- file dialog");
    ewl_window_name_set(EWL_WINDOW(fd_win), PROG " -- file dialog");
    ewl_window_class_set(EWL_WINDOW(fd_win), PROG " -- file dialog");
    ewl_object_size_request(EWL_OBJECT(fd_win), 500, 400);
    ewl_object_fill_policy_set(EWL_OBJECT(fd_win),
                EWL_FLAG_FILL_FILL | EWL_FLAG_FILL_SHRINK);
    ewl_callback_append(fd_win, EWL_CALLBACK_DELETE_WINDOW, 
                                destroy_filedialog_cb, NULL);
    ewl_widget_show(fd_win);

    /* fd win container */
    box = ewl_vbox_new();
    ewl_container_child_append(EWL_CONTAINER(fd_win), box);
    ewl_object_fill_policy_set(EWL_OBJECT(box),
                EWL_FLAG_FILL_FILL | EWL_FLAG_FILL_SHRINK);
    ewl_widget_show(box);

    /* the file dialog */
    fd = ewl_filedialog_new(EWL_FILEDIALOG_TYPE_OPEN);
    ewl_callback_append(fd, EWL_CALLBACK_VALUE_CHANGED, open_file_cb, data);
    ewl_container_child_append(EWL_CONTAINER(box), fd);

    /* add a home button */
    home = ewl_button_new("Home");
    ewl_callback_append(home, EWL_CALLBACK_CLICKED, home_cb, fd);
    ewl_object_fill_policy_set(EWL_OBJECT(home), EWL_FLAG_FILL_HFILL);
    ewl_container_child_append(EWL_CONTAINER(fd), home);
    ewl_widget_show(home);

    ewl_widget_show(fd);
}
</pre></div><p>
Se um usuário clicar no ítem "Open" do menu "File" a função <tt class="function">file_menu_open_cb()</tt> será executada. 
Quando isto ocorrer necessitamos criar o diálogo de arquivo para que o usuário selecione o arquivo para ver.
</p><p>
Da mesma forma que na janela principal, criamos uma janela para conter o diálogo de arquivo e informamos um título, 
tamanho e classe. Solicitamos um tamanho default, selecionamos sua política de preenchimento e adicionamos um callback para controlar 
a destruição da própria janela. Então adicionamos uma caixa simples dentro da janela para conter o diálogo de aquivo.
</p><p>
Uma vez configurada a janela, fazemos uma chamada para criar o diálogo de arquivo. Isto é feito com uma chamda à 
<tt class="function">ewl_filedialog_new()</tt>, especificando o tipo de diálogo de arquivo que queremos cirar. Neste caso 
queremos um diálogo que nos possíbilite abrir um diretório, então especificamos EWL_FILEDIALOG_TYPE_OPEN. Poderemos 
especificar EWL_FILEDIALOG_TYPE_SAVE se desejarmos usar o diálogo para salvar o arquivo ao invéz de abri-lo.
</p><p>
Então continuamos criando um botão extra para permitir o usuário que navegue no seu diretório pessoal com um simples click. 
Isto é feito chamando <tt class="function">ewl_button_new()</tt> e condicionando o botão no próprio diálogo de arquivo.
</p><div class="example"><a name="id2562599"></a><p class="title"><b>Exemplo 11.12. Callback de finalização do diálogo de arquivo</b></p><pre class="programlisting">
/* close the file dialog */
static void destroy_filedialog_cb(Ewl_Widget *win, void *ev, void *data) {
    ewl_widget_hide(win);
    ewl_widget_destroy(win);
}
</pre></div><p>
Quando precisamos nos livrar do diálogo de arquivo, eliminamos o widget da tela com uma chamada à 
<tt class="function">ewl_widget_hide()</tt>, e uma vez que não é mais mostrado destruímos o widget com uma chamada 
à <tt class="function">ewl_widget_destroy()</tt>.
</p><div class="example"><a name="id2562639"></a><p class="title"><b>Exemplo 11.13. Callback do botão open do diálogo de arquivo</b></p><pre class="programlisting">
/* the file dialog open button callback */
static void open_file_cb(Ewl_Widget *win, void *ev, void *data) {
    char *text = NULL;
    text = read_file((char *)ev);
    
    if (text) {
        ewl_text_text_set(EWL_TEXT(data), text);
        free(text);
    }           
    text = NULL;

    ewl_widget_hide(fd_win);
}
</pre></div><p>
Este callback será executando quando o usuário clicar no botão "Open" no diálogo de arquivo, 
ou quando o usuário der um duplo clique em um arquivo no diretório. O evento passado (o parâmetro ev) será o 
caminho completo do arquivo que o usuário selecionou.
</p><p>
No nosso caso, tomamos esse arquivo e o passamos à função para ler o arquivo e devolver o texto do arquivo. Então 
usando este texto como está, chamamos a função <tt class="function">ewl_text_text_set()</tt> que colocará o 
texto no objeto de texto dado.
</p><p>
Já que o usuário terminou sua seleção, o diálogo de arquivo é escondido.
</p><div class="example"><a name="id2561477"></a><p class="title"><b>Exemplo 11.14. Callback do botão home do diálogo de aquivo</b></p><pre class="programlisting">
/* the fd home button is clicked */
static void home_cb(Ewl_Widget *win, void *ev, void *data) {
    char *home = NULL;
    Ewl_Filedialog *fd = (Ewl_Filedialog *)data;
    
    home = getenv("HOME");
    if (home)
        ewl_filedialog_set_directory(fd, home);
}   
</pre></div><p>
Se o usuário clicar no botão "Home" no diálogo de aquivo queremos mostrar o conteúdo do seu diretório pessoal. 
Colocamos o diálogo de arquivo como dado do callback, assim o pegamos no callback e capturamos o diretório pessoal da 
variável de ambiente. A chamada para <tt class="function">ewl_filedialog_set_directory()</tt> muda o diretório atual que está 
mostrando no diálogo de arquivo para ser o diretório pessoal do usuário.
</p><div class="example"><a name="id2561520"></a><p class="title"><b>Exemplo 11.15. Ler o arquivo de texto</b></p><pre class="programlisting">
/* read a file */
static char *read_file(char *file) {
    char *text = NULL;
    FILE *f = NULL;
    int read = 0, st_ret = 0;
    struct stat s;
    
    f = fopen(file, "r");
    st_ret = stat(file, &amp;s);

    if (st_ret != 0) {
        if (st_ret == ENOENT)
            printf("not a file %s\n", file); 
        return NULL;
    }

    text = (char *)malloc(s.st_size * sizeof(char));
    read = fread(text, sizeof(char), s.st_size, f); 
         
    fclose(f);
    return text;
}
</pre></div><p>
Esta é uma rotina simples para tomar o arquivo dado, abrir-lo e ler seu conteúdo na memoria. 
Provavelmente não é a melhor ideia para uma aplicação real, mas é o suficiente para este 
programa exemplo.
</p><div class="example"><a name="id2561567"></a><p class="title"><b>Exemplo 11.16. Callback de teclado</b></p><pre class="programlisting">
/* a key was pressed */
static void key_up_cb(Ewl_Widget *win, void *ev, void *data) {
    Ewl_Event_Key_Down *e = (Ewl_Event_Key_Down *)ev;
    Ewl_ScrollPane *scroll = (Ewl_ScrollPane *)data;

    if (!strcmp(e-&gt;keyname, "q")) {
        destroy_cb(win, ev, data);

    } else if (!strcmp(e-&gt;keyname, "Left")) {
        double val = ewl_scrollpane_hscrollbar_value_get(EWL_SCROLLPANE(scroll));
        double step = ewl_scrollpane_hscrollbar_step_get(EWL_SCROLLPANE(scroll));

        if (val != 0)
            ewl_scrollpane_hscrollbar_value_set(EWL_SCROLLPANE(scroll), 
                                                                val - step);

    } else if (!strcmp(e-&gt;keyname, "Right")) {
        double val = ewl_scrollpane_hscrollbar_value_get(EWL_SCROLLPANE(scroll));
        double step = ewl_scrollpane_hscrollbar_step_get(EWL_SCROLLPANE(scroll));

        if (val != 1)
            ewl_scrollpane_vscrollbar_value_set(EWL_SCROLLPANE(scroll), 
                                                                val + step);

    } else if (!strcmp(e-&gt;keyname, "Up")) {
        double val = ewl_scrollpane_vscrollbar_value_get(EWL_SCROLLPANE(scroll));
        double step = ewl_scrollpane_vscrollbar_step_get(EWL_SCROLLPANE(scroll));

        if (val != 0)
            ewl_scrollpane_vscrollbar_value_set(EWL_SCROLLPANE(scroll), 
                                                                val - step);
    
    } else if (!strcmp(e-&gt;keyname, "Down")) {
        double val = ewl_scrollpane_vscrollbar_value_get(EWL_SCROLLPANE(scroll));
        double step = ewl_scrollpane_vscrollbar_step_get(EWL_SCROLLPANE(scroll));
    
        if (val != 1)
            ewl_scrollpane_vscrollbar_value_set(EWL_SCROLLPANE(scroll), 
                                                                val + step);
    } 
}       
</pre></div><p>
<tt class="function">key_up_cb()</tt> será chamda quando o usuário solta uma tecla do teclado. 
O callback receberá uma estrutura de evento Ewl_Event_Key_Down contendo a informação da própria tecla pressionada.
No nosso caso só necessitamos da entrada keyname que é o nome da tecla pressionada.
</p><p>
Se o usuário pressinar a tecla "q" simplesmente chama o callback destroy e terminamos com isto.
</p><p>
"Left", "Right", "Up" e "Down" são as teclas de cursor do teclado. 
Se alguma destas teclas forem pressionadas froçamos o painel de rolagem a rolar na direção especificada.
</p><p>
Para controlar o painel de rolagem necessitamos saber onde ele está atualmente no arquivo e a distância que 
deverá rolar cada incremento/decremento. Por sorte Ewl torna isto fácil. A chamada à ewl_scrollpane_[hv]scrollbar_value_get() 
devolverá o valor atual da barra de rolagem. Este é um valor do tipo double com limites [0, 1] inclusivo. Um valor de 0 significa 
que a barra de rolagem está no topo e um valor de 1 que está no fundo. Esquerda e direita funcionam da mesma forma, com 0 
sendo esquerda absoluta e 1 direita absoluta.
</p><p>
A segunda parte da informação é obtida mediante a chamda à ewl_scrollpane_[hv]scrollbar_step_get(). O passo (step) é a distância 
que rolará o painel de rolamento com uma interação. Usando estes dois valores podemos então mover a barra de rolagem da direção correta com 
a chamada à ewl_scrollpane_[hv]scrollbar_value_set().
</p><div class="example"><a name="id2563069"></a><p class="title"><b>Exemplo 11.17. Compilação</b></p><pre class="screen">
zero@oberon [ewl_intro] -&lt; gcc -Wall -o ewl_text main.c \
 `ewl-config --cflags --libs`

</pre></div><p>
Compilar uma aplicação Ewl é tão simples como chamar ewl-config e obter os --cflags e --libs.
</p><p>
Então é isto. Com este exemplo você deverá ter uma aplicação Ewl funcionando plenamente, incluindo menus, um diálogo de arquivo e uma 
área de texto com barras de rolagem horizontais e verticais. Este exemplo apenas arranha a superfície da pontência contida dentro 
do conjunto de ferramentes Ewl com muitos outros tipo de widget disponiveis para usar.
</p></div></div><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a name="id2564397"></a>Capítulo 12. Evoak</h2></div></div><div></div></div><div class="toc"><p><b>Índice</b></p><dl><dt><a href="#id2557825">Receita: Cliente Evoak hello </a></dt></dl></div><p>
Evoak é um servidor de canvas. Similiar a um servidor X que serve um 
display e operações gráficas. Evoak server um único canvas para ser 
compartilhado por várias aplicações ( clientes ) permitindo que cada uma delas manipule 
seu próprio conjunto de objetos no canvas.
</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2557825"></a>Receita: Cliente Evoak hello </h2></div><div><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div></div></div><p>
Esta receita é uma introdução muito simples ao mundo da programação 
Evoak. Seguindo a grande tradição, esta receita mostrará a versão 
canadense de "Hello World" num canvas evoak.
</p><div class="example"><a name="id2564442"></a><p class="title"><b>Exemplo 12.1. Includes e pré-declarações</b></p><pre class="programlisting">
#include &lt;Evoak.h&gt;
#include &lt;Ecore.h&gt;

static unsigned int setup_called = 0;

static int canvas_info_cb(void *, int, void *);
static int disconnect_cb(void *, int, void *);
static void setup(Evoak *);
</pre></div><p>
Obviamente precisamos incluir o header Evoak, e o header Ecore é necessário para acessar as funções de callback.
</p><div class="example"><a name="id2565767"></a><p class="title"><b>Exemplo 12.2. main</b></p><pre class="programlisting">
int main(int argc, char ** argv) {
    Evoak *ev = NULL;

    if (!evoak_init()) {
        fprintf(stderr, "evoak_init failed");
        return 1;
    }

    ecore_event_handler_add(EVOAK_EVENT_CANVAS_INFO, canvas_info_cb, NULL);
    ecore_event_handler_add(EVOAK_EVENT_DISCONNECT, disconnect_cb, NULL);

    ev = evoak_connect(NULL, "evoak_intro", "custom");

    if (ev) {
        ecore_main_loop_begin();
        evoak_disconnect(ev);
    }

    evoak_shutdown();
    return 0;
}
</pre></div><p>
Evoak precisa ser iniciado com uma chamada à <tt class="function">evoak_init</tt>. Isto iniciará todas 
as bibliotecas internas e os requerimentos para a Evoak.
</p><p>
Assim que o Evoak iniciar corretamente, conectaremos dois callbacks, o primeiro é para informação de canvas e o 
segundo é caso formos desconectados do servidor Evoak. Isto será discutido depois quando os próprios callbacks
forem mostrados.
</p><p>
Uma vez que os callbacks estão em seus lugares precisamos conectar ao servidor de canvas Evoak. 
Esto é feito mediante a chamada para <tt class="function">evoak_connect</tt>. Os parâmetros para 
<tt class="function">evoak_connect</tt> são: o servidor para conectar, o nome do cliente e a classe do cliente. Se o primeiro 
argumento for NULL, como no exemplo, o servidor Evoak default é coenctado. O segundo arqumento da  <tt class="function">evoak_connect</tt> 
é o nome do cliente, este valor deverá ser únido já que isto será usado para distinguir um cliente do outro. O argumento final, a classe,
é o tipo do cliente, alguns dos possíveis valores são: "background", "panel", "application" ou "custom".
</p><p>
Se a chamada para <tt class="function">evoak_connect</tt> falhar um valor NULL será retornado. 
Assim, sempre que recebemos um objeto Evoak, iniciamos o loop principal ecore. Quando ecore 
termina, chamamos <tt class="function">evoak_disconnect</tt> para disconectarmos do servidor Evoak.
</p><p>
Terminamos por chamar a função <tt class="function">evoak_shutdown</tt> para a limpeza final.
</p><div class="example"><a name="id2565894"></a><p class="title"><b>Exemplo 12.3. Callback de informação de canvas</b></p><pre class="programlisting">
static int canvas_info_cb(void *data, int type, void *ev) {
    Evoak_Event_Canvas_Info *e = (Evoak_Event_Canvas_Info *)ev;

    if (!setup_called) {
        setup_called = 1;
        setup(e-&gt;evoak);
    }
    return 1;
}
</pre></div><p>
Um callback de informação de canvas será chamado quando nosso cliente recebe informação do servidor de canvas Evoak.
Com esta informação podemos fazer a inicialização do conteúdo dos nossos clientes. Isto está contido dentro da 
flag setup_called já que só queremos inicializar uma vez.
</p><div class="example"><a name="id2565926"></a><p class="title"><b>Exemplo 12.4. Callback de desconexão</b></p><pre class="programlisting">
static int disconnect_cb(void *data, int type, void *ev) {
    printf("disconnected\n");
    ecore_main_loop_quit();
    return 1;
}
</pre></div><p>
A callback de desconexão será chamado quando o cliente for desconectado do 
servidor Evoak. Neste caso, uma simples solução de sair é usado.
</p><div class="example"><a name="id2565952"></a><p class="title"><b>Exemplo 12.5. rotina de setup</b></p><pre class="programlisting">
static void setup(Evoak *ev) {
    Evoak_Object *o = NULL;

    evoak_freeze(ev);

    o = evoak_object_text_add(ev);
    evoak_object_text_font_set(o, "Vera", 12);
    evoak_object_color_set(o, 255, 0, 0, 255);
    evoak_object_text_text_set(o, "Hello Evoak, eh.");
    evoak_object_show(o);

    evoak_thaw(ev);
}
</pre></div><p>
A rotina de setup será chamada uma vez para inciar a janela de nosso cliente. Para este exemplo, o 
cliente apenas desenha o texto 'Hello Evoak, eh'. 
</p><p>
A primeira coisa que fazemos é chamar <tt class="function">evoak_freeze</tt>, isto deve nos proteger de ficar recebendo 
qualquer callback não solicitado enquanto iniciamos nossa interface. Ao final da função chamamos a recíproca 
<tt class="function">evoak_thaw</tt> para "descongelar".
</p><p>
Então continuamos criando um objeto de texto com <tt class="function">evoak_object_text_add</tt> e com este objeto de texto, 
iniciamos a fonte, cor e conteúdo do texto com chamadas para <tt class="function">evoak_object_text_font_set</tt>,
<tt class="function">evoak_object_color_set</tt> e <tt class="function">evoak_object_text_text_set</tt> respectivamente.
</p><div class="example"><a name="id2566060"></a><p class="title"><b>Exemplo 12.6. Compilação</b></p><pre class="screen">
zero@oberon [evoak_intro] -&gt; gcc -o hello_evoak main.c \
 `evoak-config --cflags --libs`
</pre></div><p>
Como com tantas outras bibliotecas baseada en EFL, compilar uma aplicação Evoak é tão simples como chamar o 
programa evoak_config e obter os conteúdos de --cflags e --libs.
</p><p>
Isto é tudo, foi uma introdução à Evoak realmente simples e a superfície permanece sem nenhum 
arranhão referente ao potêncial disponível para aplicações cliente.
</p></div></div><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a name="id2565653"></a>Capítulo 13. Emotion</h2></div></div><div></div></div><div class="toc"><p><b>Índice</b></p><dl><dt><a href="#id2565714">Receita: Player DVD com Emotion</a></dt><dt><a href="#id2564387">Receita: Player de midia expandido com Emotion</a></dt></dl></div><p>
Emotion é uma biblioteca de objetos de vídeo e mídia desenhada para interagir com Evas e 
Ecore fornecendo de forma autonoma objetos de "video" e "audio" que podem ser movidos, 
redimensionados e posicionados como qualquer outro objeto normal, mas podem reproduzir 
video e audio e podem ser controlados atravéz uma API de controle de alto nível permitindo 
ao programdor montar rápidamente um sistema multimídia com um mínimo trabalho. Emotion 
fornece um sistema de camadas de decodificadores modular onde um módulo decodificador pode 
ser plugado separadamente para prover recursos de decodificação. Emotion atualmente tem 1 módulo
decodificardor que usa XINE como decodificador, permitindo-o reproduzir DVD's, MPEG's, AVI's, 
MOV's, WMV's e muito mais. Este programa teste é um útil reprodutor de DVD 
( sem uma interface bonita ) que pode reproduzir várias fontes de vídeo 
com semi-translucência entre outras coisas.
</p><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2565714"></a>Receita: Player DVD com Emotion</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Carsten</span> <span class="othername">'rasterman'</span> <span class="surname">Haitzler</span></h3></div></div></div><div></div></div><p>
Para mostrar como o Emotion fácilmente pôe um arquivo de vídeo, DVD, VCD ou outro conteúdo de midia em 
um canvas dê uma olhada no seguinte programa. É um reprodutor de DVD completo, mas muito simples. Possui um 
controle por mouse limitado, não controla as mudanças relacionadas ao aspcto e etc. 
Tudo em 55 linhas de código C.
</p><p>
Todo o código nesta e na próxima receita pode ser compilado usando:
</p><div class="example"><a name="id2566948"></a><p class="title"><b>Exemplo 13.1. Compilação</b></p><pre class="screen">
$ gcc player.c -o player `emotion-config --cflags --libs`
</pre></div><p>
</p><p>
</p><div class="example"><a name="id2566970"></a><p class="title"><b>Exemplo 13.2. Reprodutor de DVD em 55 linhas de código</b></p><pre class="programlisting">
#include &lt;Evas.h&gt;
#include &lt;Ecore.h&gt;
#include &lt;Ecore_Evas.h&gt;
#include &lt;Emotion.h&gt;

Evas_Object *video;

/* if the window manager requests a delete - quit cleanly */
static void
canvas_delete_request(Ecore_Evas *ee)
{
    ecore_main_loop_quit();
}

/* if the canvas is resized - resize the video too */
static void
canvas_resize(Ecore_Evas *ee)
{
    Evas_Coord w, h;

    evas_output_viewport_get(ecore_evas_get(ee), NULL, NULL, &amp;w, &amp;h);
    evas_object_move(video, 0, 0);
    evas_object_resize(video, w, h);
}

/* the main function of the program */
int main(int argc, char **argv)
{
    Ecore_Evas *ee;

    /* create a canvas, display it, set a title, callbacks to call on resize */
    /* or if the window manager asks it to be deleted */
    ecore_evas_init();
    ee = ecore_evas_software_x11_new(NULL, 0, 0, 0, 800, 600);
    ecore_evas_callback_delete_request_set(ee, canvas_delete_request);
    ecore_evas_callback_resize_set(ee, canvas_resize);   
    ecore_evas_title_set(ee, "My DVD Player");
    ecore_evas_name_class_set(ee, "my_dvd_player", "My_DVD_Player");
    ecore_evas_show(ee);

    /* create a video object */
    video = emotion_object_add(ecore_evas_get(ee));
    emotion_object_file_set(video, "dvd:/");
    emotion_object_play_set(video, 1);
    evas_object_show(video);

    /* force an initial resize */
    canvas_resize(ee);

    /* run the main loop of the program - playing, drawing, handling events */
    ecore_main_loop_begin();

    /* if we exit the main loop we will shut down */
    ecore_evas_shutdown();
}
</pre></div><p>
</p><p>
Agora temos uma introdução muito simples ao Emotion. Este fragmento de código 
pode ser facilmente expandido para trabalhar com qualquer formato 
de midia suportado pelo Emotion, bem como tratar relações do aspecto, navegação pelo teclado, e mais.
</p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2564387"></a>Receita: Player de midia expandido com Emotion</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Carsten</span> <span class="othername">'rasterman'</span> <span class="surname">Haitzler</span></h3></div></div></div><div></div></div><p>
Expandindo nossa receita anterior, podemos fazer o emotion 
redimencionar apropriadamente (mantendo a relação de aspecto).
</p><p>
</p><div class="example"><a name="id2564072"></a><p class="title"><b>Exemplo 13.3. Reprodutor de midia Emotion</b></p><pre class="programlisting">
#include &lt;Evas.h&gt;
#include &lt;Ecore.h&gt;
#include &lt;Ecore_Evas.h&gt;
#include &lt;Emotion.h&gt;

Evas_Object *video;

/* if the window manager requests a delete - quit cleanly */
static void
canvas_delete_request(Ecore_Evas *ee)
{
    ecore_main_loop_quit();
}

/* if the canvas is resized - resize the video too */
static void
canvas_resize(Ecore_Evas *ee)
{
    Evas_Coord w, h;

    evas_output_viewport_get(ecore_evas_get(ee), NULL, NULL, &amp;w, &amp;h);
    evas_object_move(video, 0, 0);
    evas_object_resize(video, w, h);
}

/* the main function of the program */
int main(int argc, char **argv)
{
    Ecore_Evas *ee;

    /* create a canvas, display it, set a title, callbacks to call on resize */
    /* or if the window manager asks it to be deleted */
    ecore_evas_init();
    ee = ecore_evas_software_x11_new(NULL, 0, 0, 0, 800, 600);
    ecore_evas_callback_delete_request_set(ee, canvas_delete_request);
    ecore_evas_callback_resize_set(ee, canvas_resize);   
    ecore_evas_title_set(ee, "My DVD Player");
    ecore_evas_name_class_set(ee, "my_dvd_player", "My_DVD_Player");
    ecore_evas_show(ee);

    /* create a video object */
    video = emotion_object_add(ecore_evas_get(ee));
    emotion_object_file_set(video, "dvd:/");
    emotion_object_play_set(video, 1);
    evas_object_show(video);

    /* force an initial resize */
    canvas_resize(ee);

    /* run the main loop of the program - playing, drawing, handling events */
    ecore_main_loop_begin();

    /* if we exit the main loop we will shut down */
    ecore_evas_shutdown();
}
</pre></div><p>
</p><p>
</p></div></div></div></body></html>
