<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Application development with Edje</title>
<meta name="author" content="Andres Blanc" />
<meta name="date" content="2008/04/03" />
<meta name="copyright" content="This book is distributed under the terms of the &quot;Attribution&quot; Creative Commons license. See: http://creativecommons.org/licenses/by/3.0/." />
<style type="text/css">

/*  Margenes y Padding.
    Ver: http://leftjustified.net/journal/2004/10/19/global-ws-reset/ */
* 
    {
    padding:0;
    margin:0;
    }

h1, h2, h3, h4, h5, h6, p, pre, blockquote, label, ul, ol, dl, fieldset, address 
    {
    margin:1em 5%;
    }

li, dd
    {
    margin-left:5%;
    }

fieldset 
    {
    padding: .5em;
    }
</style>
</head>
<body>
<div class="document" id="application-development-with-edje">
<h1 class="title">Application development with Edje</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="field"><th class="docinfo-name">Title:</th><td class="field-body">Application development with Edje</td>
</tr>
<tr class="field"><th class="docinfo-name">Subtitle:</th><td class="field-body">From the very basics</td>
</tr>
<tr><th class="docinfo-name">Author:</th>
<td>Andres Blanc</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference" href="mailto:andresblanc&#37;&#52;&#48;gmail&#46;com">andresblanc<span>&#64;</span>gmail<span>&#46;</span>com</a></td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>1.0</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2008/04/03</td></tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>This book is distributed under the terms of the &quot;Attribution&quot;
Creative Commons license. See: <a class="reference" href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</a>.</td></tr>
</tbody>
</table>
<div class="abstract topic">
<p class="topic-title first">Abstract</p>
<p>An introduction to GUI based application development. Starts from
the most basic concepts and introduces the EFL libraries that deal
with each of them. It covers Edje, Ecore, Evas and EWL. This book
is intended to cover all the concepts needed by a novice programmer
to create a full blown Edje based application.</p>
</div>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#book-overview" id="id1" name="id1">Book overview</a></li>
<li><a class="reference" href="#about-graphical-user-interfaces" id="id2" name="id2">About Graphical User Interfaces</a><ul>
<li><a class="reference" href="#decomposing-the-frontend" id="id3" name="id3">Decomposing the frontend</a></li>
<li><a class="reference" href="#introduction-to-edje" id="id4" name="id4">Introduction to Edje</a></li>
<li><a class="reference" href="#the-foundations" id="id5" name="id5">The foundations</a></li>
<li><a class="reference" href="#convenient-libraries" id="id6" name="id6">Convenient libraries</a></li>
</ul>
</li>
<li><a class="reference" href="#the-foundations-in-practice" id="id7" name="id7">The foundations in practice</a><ul>
<li><a class="reference" href="#working-with-the-canvas" id="id8" name="id8">Working with the canvas</a></li>
<li><a class="reference" href="#interacting-with-the-objects" id="id9" name="id9">Interacting with the objects</a></li>
<li><a class="reference" href="#building-a-framework" id="id10" name="id10">Building a framework</a><ul>
<li><a class="reference" href="#simpler-library-intialization" id="id11" name="id11">Simpler library intialization</a></li>
<li><a class="reference" href="#simpler-window-setup" id="id12" name="id12">Simpler window setup</a></li>
<li><a class="reference" href="#simpler-theme-management" id="id13" name="id13">Simpler theme management</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#introduction-to-widgets" id="id14" name="id14">Introduction to widgets</a><ul>
<li><a class="reference" href="#widgets-with-edje" id="id15" name="id15">Widgets with Edje</a></li>
<li><a class="reference" href="#the-ewl-as-a-shortcut" id="id16" name="id16">The Ewl as a shortcut</a></li>
<li><a class="reference" href="#implementing-widgets-with-edje" id="id17" name="id17">Implementing widgets with Edje</a><ul>
<li><a class="reference" href="#introduction-to-smart-objects" id="id18" name="id18">Introduction to Smart Objects</a></li>
<li><a class="reference" href="#the-foundations-of-a-smart-object" id="id19" name="id19">The foundations of a Smart Object</a></li>
</ul>
</li>
<li><a class="reference" href="#laying-out-widgets" id="id20" name="id20">Laying out widgets</a></li>
<li><a class="reference" href="#creating-list-based-widgets" id="id21" name="id21">Creating list based widgets</a></li>
</ul>
</li>
<li><a class="reference" href="#widgets-by-example" id="id22" name="id22">Widgets by Example</a><ul>
<li><a class="reference" href="#the-text-entry" id="id23" name="id23">The text entry</a></li>
<li><a class="reference" href="#the-combox" id="id24" name="id24">The combox</a></li>
<li><a class="reference" href="#the-kinetic-list" id="id25" name="id25">The kinetic list</a></li>
<li><a class="reference" href="#the-media-viewport" id="id26" name="id26">The media viewport</a></li>
<li><a class="reference" href="#flexible-toolbars" id="id27" name="id27">Flexible toolbars</a></li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id1" id="book-overview" name="book-overview">Book overview</a></h1>
<ul>
<li><p class="first"><a class="reference" href="#about-graphical-user-interfaces">About Graphical User Interfaces</a>.
If we look through the code of some of the many open source applications
available, we can find most of them share a common structure. This chapter
introduces the reader to said structure, to the concept of an Event loop and
how does it deal with the interaction between form and function.</p>
<ul class="simple">
<li><a class="reference" href="#decomposing-the-frontend">Decomposing the frontend</a>.
There are different approaches to the creation of Graphical User Interfaces,
some provide flexibility while others shorter development time. In the end, the
rest of the application will have to go through the same mechanism to deal
with the interface.</li>
<li><a class="reference" href="#introduction-to-edje">Introduction to Edje</a>.
Edje is a compromise between flexibility and development time. Comparing it to
a plain canvas or a fully featured toolkit can show us how it fits in the
middle ground and provides advantages for designers and developers alike.</li>
<li><a class="reference" href="#the-foundations">The foundations</a>.
Edje allows low level control of the interface without forcing the developer
through a low level API. The interface objects are implemented as Evas objects,
but through a completely new language friendly to designers and independent
from the application code.</li>
<li><a class="reference" href="#convenient-libraries">Convenient libraries</a>
To load an Edje interface the application needs to setup an Evas canvas first.
This would look as a burden for the developer, dealing with issues specific to
the underlying system. Thankfully Evas is supported by an additional library
that resolve most of these issues, Ecore.</li>
</ul>
</li>
<li><p class="first"><a class="reference" href="#the-foundations-in-practice">The foundations in practice</a>.
Practical examples of the Englighenment Foundation Libraries required for a
common Edje application.</p>
<ul>
<li><p class="first"><a class="reference" href="#working-with-the-canvas">Working with the canvas</a>.
Including new Edje objects inside the previously setup canvas can be explained
with this simple example.</p>
</li>
<li><p class="first"><a class="reference" href="#interacting-with-the-objects">Interacting with the objects</a>.
There are different channels for the application to interact with the
interface. For the sake of brevity I will include an example of each one to
serve as an introduction for the practical examples to come in the next
chapters.</p>
</li>
<li><p class="first"><a class="reference" href="#building-a-framework">Building a framework</a>.
Hopefully the reader's mind won't be filled already with preconceptions about
this subject. In any case, only the foundations of what could be used to
form a complex framework are going to be reviewed in this chapter.</p>
<blockquote>
<ul class="simple">
<li><a class="reference" href="#simpler-library-intialization">Simpler library intialization</a>.
We have seen why and how to initialize the necessary EFL libraries. This
chapter introduces the implementation of a convenience function to do it in one
call along with control and intialization of configuration and theme files.</li>
<li><a class="reference" href="#simpler-window-setup">Simpler window setup</a>.
Altought setting up a window is not a complex task there is no reason for not
using a standarized method that automates some aspects of window creation. Some
other aspects are left for the designer to manipulate, the end result is less
code which often means less bugs.</li>
<li><a class="reference" href="#simpler-theme-management">Simpler theme management</a>.
The EFL are programmed in a incredible flexible way and they cover many uses
and platforms. The functions explained in this section makes some assumptions
about the programmer's intentions. If they match with yours, using them can
mean simpler application code, less development time and less bugs.</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p class="first"><a class="reference" href="#introduction-to-widgets">Introduction to widgets</a>.
Interfaces need to resolve two problems, presenting information to users and
taking orders from them. The past chapters presented enough information to
solve the first. In the following chapters we will review the second.</p>
<ul class="simple">
<li><a class="reference" href="#widgets-with-edje">Widgets with Edje</a>.
Since this is a book about Edje it might be a good idea to detail the way Edje
simplifies custom widget creation by reviewing the list of tasks presented in
the previous chapter and how Edje helps with each task.</li>
<li><a class="reference" href="#the-ewl-as-a-shortcut">The Ewl as a shortcut</a>.
The Enlightened Widget Library is a piece of software older than Edje itself.
But almost as soon as Edje was made aviable the library developers started
using it as their theme engine. Since widget's from this library can be
included as another Edje object we can use it as a shortcut for the most
complex widgets.</li>
<li><a class="reference" href="#implementing-widgets-with-edje">Implementing widgets with Edje</a>.
It is possible to fully implement widgets using the Edje library alone. But
this approach grows more unmanageable as the widget becomes more complex. In
this chapter we will review a simple widget, written using Edje alone and a
more complex widget that shares the same foundations with Edje objects.<ul>
<li><a class="reference" href="#introduction-to-smart-objects">Introduction to Smart Objects</a>.
We have seen Smart Objects in the previous chapters and we know they are used
to implement Edje objects. In this chapters we will analyze the surface code
of a Smart Object based widget, the minimap.</li>
<li><a class="reference" href="#the-foundations-of-a-smart-object">The foundations of a Smart Object</a>.
If you felt that basing Edje widgets in Smart Objects seems simple enough, I
hope that impression does not fade away because of the amount of code presented
in this chapter. Altought at a first look it might seem complex creating an
Smart Object is quite simple and logical.</li>
</ul>
</li>
<li><a class="reference" href="#laying-out-widgets">Laying out widgets</a>.
TODO.</li>
<li><a class="reference" href="#creating-list-based-widgets">Creating list based widgets</a>.
TODO.</li>
</ul>
</li>
<li><p class="first"><a class="reference" href="#widgets-by-example">Widgets by Example</a>.
TODO,</p>
<ul class="simple">
<li><a class="reference" href="#the-text-entry">The text entry</a>.
TODO</li>
<li><a class="reference" href="#the-combox">The combox</a>.
TODO.</li>
<li><a class="reference" href="#the-kinetic-list">The kinetic list</a>.
TODO.</li>
<li><a class="reference" href="#the-media-viewport">The media viewport</a>.
TODO.</li>
<li><a class="reference" href="#flexible-toolbars">Flexible toolbars</a>.
TODO.</li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id2" id="about-graphical-user-interfaces" name="about-graphical-user-interfaces">About Graphical User Interfaces</a></h1>
<p>So... you want to create a GUI application? I assume so since you choosed this
book as instructive, or at least bathroom, material. You could google &quot;GUI&quot; and
&quot;library&quot; to feel overwhelmed by the large number of development libraries
available. As you look through the source of your (open source) favorites you
will realize that all of them, and the applications that use them, share a
common structure. In this chapter we will review that structure.</p>
<p>At this point it is convenient to note that the concepts seen in this book and
the applications resulting from them translate painlessly to special purpose
computers or embed devices running under alternative architectures like ARM or
PPC. Edje and related libraries are not only efficient but portable.</p>
<p>The structure of the averange graphical application is built around a concept
known as event (or signal) driven execution. Event driven applications are
persistent and depend on a gate guardian to call the appropriate functions in
the appropriate moment. This gate guardian is known as the Event loop (or main
loop).</p>
<div align="center" class="align-center"><img alt="img/graphical_application_components.png" class="align-center" src="img/graphical_application_components.png" style="width: 1813.05px; height: 1360.0px;" /></div>
<p>The functions that form a event driven application (with a GUI) can be split
among two groups. The first group is known as the backend, these functions deal
with the actual purpose of the application, crunching numbers, decoding media
files and so on. The second group is known as the frontend, the prupose of
these functions is to present the results from the backend to their human
overlords and to receive orders from them.</p>
<p>Between the backend and the frontend is where the Event loop lives, its mission
is to connect both ends of the application. Not only between them but also with
their environment. The Event loop mantains a list of signals to look out for
and functions related to them. When a signal is received, the Event loop looks
it up in a list and executes the corresponding function or functions.</p>
<p>For the application to work, the Event loop needs to be aware of events in the
interface, thus it is  usually provided by the same library that provides the
GUI elements. It also needs to be aware of events in the system where the
application is running. Even when the concept is simple, creating a portable
and properly abstracted event loop is no simple task.</p>
<div class="section">
<h2><a class="toc-backref" href="#id3" id="decomposing-the-frontend" name="decomposing-the-frontend">Decomposing the frontend</a></h2>
<p>There are many libraries that aid creation of a GUI. From a plain canvas
consisting of primitive design objects, like a line or a rectangle, to complex
layout schemes and predefined interface elements, the latter known as &quot;toolkit&quot;
or widget library. As opposed to the first, in a toolkit the canvas is just
another widget.</p>
<p>Regardless of the method of choice, the resulting GUI has to provide the same
resources to the rest of the application. A mechanism to present information
to the user, a mechanism to know when the user interacts with the interface and
a mechanism to retrieve information that resulted from said interaction.</p>
<p>In the case of the plain canvas the application developer must assemble the
interface elements, know as widgets, using primitive objects. A very simple
text entry widget could consist of a rectangle and a string of text. Besides
assembling the widget, the developer has to instruct the Event loop  to call a
given function on a given interface event on either primitive object. It is
possible to discriminate between, for example, a click in the rectangle from a
click in the string.</p>
<p>In the case of a toolkit library the application developer would simply include
a predefined &quot;text entry&quot; widget. The events from this object would be dealt
with in terms of the object as a whole. It wouldn't seem that there is much
difference between using a canvas or using a toolkit library until we consider
all the possibilities, like focus, overflowing text, copying, pasting,
selecting, etc.</p>
<p>Deciding which approach to use is, of course, up to the developer to decide as
each one provide capabilities useful for different types of applications. But
as we will find out further ahead in this book, these examples only represent
opposite extremes and there is an alternative approach that sits quite
comfortably in the middle. Edje.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id4" id="introduction-to-edje" name="introduction-to-edje">Introduction to Edje</a></h2>
<p>Allow me to begin this chapter with a quote from the introduction of Edje's API
Reference. After all, I cannot expect to give Edje a better introduction than
its creator:</p>
<blockquote>
<p>Edje is a complex graphical design and layout library. [..]</p>
<p>[..] Edje should serve all the purposes of creating visual elements
(borders of windows, scrollbars, etc.) and allow the designer the ability
to animate, layout and control the look and feel of any program using Edje
as its basic GUI constructor. This library allows for multiple collections
of Layouts in one file, sharing the same image database and thus allowing a
whole theme to be conveniently packaged into 1 file and shipped around.</p>
<p>Edje [..] separates the layout and behavior logic. Edje files ship with an
image database, used by all the parts in all the collections to source
graphical data. [..] Each part collection consists of a list of visual
parts, as well as a list of programs. A program is a conditionally run
program that if a particular event occurs (a button is pressed, a mouse
enters or leaves a part) will trigger an action that may affect other
parts. In this way a part collection can be &quot;programmed&quot; via its file as to
hilight buttons when the mouse passes over them or show hidden parts when a
button is clicked somewhere etc. The actions performed in changing from one
state to another are also allowed to transition over a period of time,
allowing animation.</p>
<p>[..] This separation and simplistic event driven style of programming can
produce almost any look and feel one could want for basic visual elements.
Anything more complex is likely the domain of an application or widget set
that may use Edje as a convenient way of being able to configure parts of
the display.</p>
</blockquote>
<p>As we have seen in the past chapters, there are roughly two methods for
creating Graphical User Interfaces. In both cases it had to be implemented
through a programming language. In one case, an API was used by the application
developer to assemble interface elements from more primitive objects, in the
other case the API was used to include objects already defined by a library.
Any changes to an nterface object beyond simplistic style modifications had to
be submitted by the designer to the developer. Layout changes were only
slightly less difficult than behavior changes. The idea of working on the
interface objects and their composition in a live environment, like a web
developer does, was pretty much unthinkable.</p>
<p>This is where the Edje library fits in, it liberates the designer and the
developer from eachother. The artists uses the Edje Data Collection language to
manipulate primitive objects. EDC is in some ways comparable to Cascading Style
Sheets but its free of the framework that markup imposes. From the other side,
the developer only has to include the resulting object and setup the callbacks
(by the main loop) to the backend functions.</p>
<div align="center" class="align-center"><img alt="img/workflow.png" class="align-center" src="img/workflow.png" style="width: 1813.05px; height: 1360.0px;" /></div>
<p>Except for the usage of nested blocks, the sintax of an EDC file is similar to
CSS. What really sets them apart is that with EDC the designer it's free to
create and layout design elements as he sees fit. With CSS the designer is
limited to applying style and layout properties to a structure of objects
defined by the markup. With Edje each design object, know as &quot;part&quot;, is created
by the designer and the final interface object composed by those parts, known
as &quot;group&quot;, is used by the developer. The resulting theme file can consist of
multiple groups representing multiple interface object.</p>
<p>The application developer will find out that the Edje API is small, since the
developer is not expected to alter the composition of a group. The API focus on
high level manipulation of groups, like forcing a maximum size, but provides
some functions to alter the content of a part when it's necessary to transmit
information, like altering a paragraph of text with a message.</p>
<p>If we compare Edje to both extremes of GUI development we can see it provides
the flexibility of developing your own interface objects from a plain canvas,
yet remain almost as simple as including a predefined object from a toolkit. Of
course Edje has shortcomings of its own and we will explore them in this book
as well.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id5" id="the-foundations" name="the-foundations">The foundations</a></h2>
<p>From a developer's point of view, we cannot expect to understand how Edje works
without going through a brief introduction about the Evas first. Luckily for
this writer, an excellent introduction to Evas has already been written in the
API Reference.</p>
<blockquote>
<p>Evas is a clean display canvas API for several target display systems that
can draw anti-aliased text, smooth super and sub-sampled scaled images,
alpha-blend objects much and more.</p>
<p>It abstracts any need to know much about what the characteristics of your
display system are or what graphics calls are used to draw them and how. It
deals on an object level where all you do is create and manipulate objects
in a canvas, set their properties, and the rest is done for you.</p>
<p>Evas optimises the rendering pipeline to minimise effort in redrawing
changes made to the canvas and so takes this work out of the programmers
hand, saving a lot of time and energy.</p>
<p>It's small and lean, designed to work on embedded systems all the way to
large and powerful multi-cpu workstations. It can be compiled to only have
the features you need for your target platform if you so wish, thus keeping
it small and lean. It has several display back-ends, letting it display on
several display systems, making it portable for cross-device and
cross-platform development.</p>
</blockquote>
<p>When using the Evas API directly, the developer uses function calls n the format
object_line_add and object_image_add to include the different primitives in our
canvas. Each of these primitives would be included in the form of an &quot;Evas
object&quot;.</p>
<p>But Evas is not limited to simply rendering primitive objects. The most common
use for a canvas is to assemble multiple primitives like lines or rectangles
into figures like charts or diagrams. In order to maintain coherency among all
the primitives the developer was forced to implement functions that abstracted
manipulation of the figure from the manipulation of its components. One of
these &quot;workarounds&quot; is now known as Evas Smart Objects.</p>
<p>Smart objects are implemented by the developer to create new Evas object types.
Functions like add, del, hide, show are implemented using the regular Evas API
to affect each primitive. This collection of functions is grouped into a new
Evas Smart Class structure that consist of a list of pointers to the functions,
the object type name and version. The instances resulting from these classes
would be manipulated by the canvas in the same way it does for any other
object.</p>
<p>Edje is implemented as a more abstract type of smart object. The list of
primitives to manipulate is not hard coded into the functions forming the Smart
Class. Edje has functions that analyze the structure of a compiled theme file
and get the list of primitives and their properties from a given &quot;group&quot; inside
the file.</p>
<p>In the end Edje interfaces can be seen as an illustration over a canvas. Space
they can share with other primitive and smart objects. Without an Evas canvas
there is no Edje theme.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id6" id="convenient-libraries" name="convenient-libraries">Convenient libraries</a></h2>
<p>The normal process to get a canvas up and running can be bothersome. Evas
supports multiple rendering engines, like the software, xrender and opengl
flavors of X11 and framebuffer devices. But before any rendering can be done
the developer has to complete an Evas_Engine_Info structure with the required
information about the target engine. This forces the developer to research the
different functions to get that information for each target. Alternatively he
can use a shortcut available for most of them.</p>
<p>As you might have realized by at this point, I intend to quote the official API
reference at every chance I get. This one comes straight from the &quot;The Ecore
Main Loop&quot; page:</p>
<blockquote>
<p>Ecore is a clean and tiny event loop library with many modules to do lots
of convenient things for a programmer, to save time and effort.</p>
<p>It's small and lean, designed to work on embedded systems all the way to
large and powerful multi-cpu workstations. It serializes all system
signals, events etc. into a single event queue, that is easily processed
without needing to worry about concurrency. A properly written,
event-driven program using this kind of programming doesn't need threads,
nor has to worry about concurrency. It turns a program into a state
machine, and makes it very robust and easy to follow.</p>
</blockquote>
<p>At the beginning of its life, the Ecore library was used as a Event loop and
loop management is still one of the modules that composes Ecore.</p>
<div align="center" class="align-center"><img alt="img/required_libraries.png" class="align-center" src="img/required_libraries.png" style="width: 1756.95px; height: 1306.45px;" /></div>
<p>Today, Ecore encompasses a long list of modules properly namespaced and
prefixed with &quot;Ecore_&quot;. From what we have seen in the previous chapters, there
are two modules that jump right out of the list. The first Ecore_Evas and
second named Ecore. The first provides convenient functions to setup the Evas
canvas and the later provides the loop management functionality described
above.</p>
<p>The developer needs an Evas canvas to render the Edje interface and Ecore_Evas
is the simplest way to get an Evas canvas up and running. This wrapper is
intended to support every backend that Evas supports with its respective (and
sometimes unique) attributes. It trivializes initialization to a couple of
lines and multiple engine support to an application reload.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id7" id="the-foundations-in-practice" name="the-foundations-in-practice">The foundations in practice</a></h1>
<p>By pointing out that the Enlightenment Foundation Libraries are designed in a
Object Oriented manner I wish not to raise the wrath of OO purists but to
simplify the reader's mental image of how the EFL C Application Programming
Interface is structured.</p>
<p>Now that the pitchforks are back in the barn and torchs have been put off,
allow me to put it in more clear terms using a simple example:</p>
<pre class="literal-block">
Evas_Object *button = NULL;
button = edje_object_add(evascanvas);
edje_object_file_set(button, &quot;theme.edj&quot;, &quot;button&quot;);
</pre>
<p>This is a simple C snippet that could be translated into a more (sintactically
speaking) OO language like Python as:</p>
<pre class="literal-block">
button = Evas_Object()
button.file_set(&quot;theme.edj&quot;,&quot;button&quot;)
</pre>
<p>The differences between the code snippets could be written off as &quot;sintactic
sugar&quot; but it serves to demonstrate the structure which the EFL C API follows.
If we dissected the last function call we could split it into three groups.
First, the class of the object to manipulate, <tt class="docutils literal"><span class="pre">edje_object</span></tt>, second, the
method to call <tt class="docutils literal"><span class="pre">file_set</span></tt> and third the pointer to the object instance
<tt class="docutils literal"><span class="pre">(button,</span></tt> along with the parameters <tt class="docutils literal"><span class="pre">&quot;theme.edj&quot;,&quot;button&quot;)</span></tt> or generically
speaking, <tt class="docutils literal"><span class="pre">class_method(instance,parameters)</span></tt>.</p>
<p>The first source snippet in the following tutorial is, of course, the first
exception. The following function calls deal with the library itself. Anyway,
displaying a simple Edje object in a window is a task with a few well defined
steps that begin by initializing the necessary libraries:</p>
<pre class="literal-block">
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;Evas.h&gt;
#include &lt;Ecore.h&gt;
#include &lt;Ecore_Evas.h&gt;

int main() {
    if (!ecore_init()) return EXIT_FAILURE;
    if (!ecore_evas_init()) return EXIT_FAILURE;
    ...
</pre>
<p>All initialize-able Enlightenment Foundation Libraries do so in the format
<tt class="docutils literal"><span class="pre">library_name_init()</span></tt>. Both Ecore and Ecore_Evas need to be initialized
before being used and both will return success or failure using standard C
values (0 is failure, any other number is success), hence the <tt class="docutils literal"><span class="pre">if</span></tt>.</p>
<p>This would be a good moment to note that the assembled, and commented, version
of the source code of these examples can be found in CVS repository of the
Enlightenment project: <tt class="docutils literal"><span class="pre">docs/devwithedje/src</span></tt></p>
<p>In order to render a canvas its necessary to create a canvas wrapper that will
host it and to store a pointer to it for future reference:</p>
<pre class="literal-block">
...
Ecore_Evas  *ecore_evas = NULL;
...
ecore_evas = ecore_evas_software_x11_new(NULL, 0, 0, 0, 800, 600);
if (!ecore_evas) return EXIT_FAILURE;
...
</pre>
<p>While the software_x11 engine is being used in this example, its possible to
use any other supported engine by simply changing the second line to
<tt class="docutils literal"><span class="pre">ecore_evas_enginename_new()</span></tt>. A list of supported engines and their
parameters can be found in the Official API reference.</p>
<p>Once the canvas wrapper has been setup we need to change its state to visible:</p>
<pre class="literal-block">
...
ecore_evas_title_set(ecore_evas, &quot;Example Application&quot;);
ecore_evas_name_class_set(ecore_evas, &quot;testapp&quot;, &quot;Testapp&quot;);
ecore_evas_show(ecore_evas);
...
</pre>
<p>While the first two lines are optional, it is useful to see the way we set the
title name and class of the window that will host our canvas. The third
function sets the given canvas wrapper to visible, this can be reversed later
with <tt class="docutils literal"><span class="pre">ecore_evas_hide()</span></tt>.</p>
<p>The canvas wrapper is ready to go, but the actual canvas that will be use to
draw our Edje objects is nowhere to be found:</p>
<pre class="literal-block">
...
Evas *evas = NULL;
...
evas = ecore_evas_get(ecore_evas);
...
</pre>
<p>The function ecore_evas_get() returns a pointer to the canvas housed in the
canvas wrapper, this is the pointer we need in order to include our Edje
objects later.</p>
<p>The execution loop for the program can also be conveniently handled by Ecore:</p>
<pre class="literal-block">
...
ecore_main_loop_begin();
...
</pre>
<p>Once ecore_main_loop_begin(..) has been called, both the canvas wrapper and
the canvas itself will be drawn in their current state (a 800x600px empty
window in this case). Ecore will continue to loop until an event handled by it
occurs.</p>
<p>Once the execution of the main loop has finished it's a good practice to shut
down any library we initiated:</p>
<pre class="literal-block">
    ...
    ecore_evas_shutdown();
    ecore_shutdown();
}
...
</pre>
<div class="section">
<h2><a class="toc-backref" href="#id8" id="working-with-the-canvas" name="working-with-the-canvas">Working with the canvas</a></h2>
<p>Now that we know how to setup the environment to display the Edje objects we
will review how to include and interact with the objects themselves. The
following code is platform independent and can be merged with the example code
provided before or with the equivalent for any other platform.</p>
<p>Just like the last time we begin by including the necessary header files and
initializing the libraries:</p>
<pre class="literal-block">
...
#include &lt;Edje.h&gt;
...
int main() {
    ...
    if (!edje_init()) return EXIT_FAILURE;
    ...
</pre>
<p>After a pointer to the canvas has been acquired, we need a pointer to a valid
Evas object to insert our Edje object:</p>
<pre class="literal-block">
...
Evas_Object *edje = NULL;
...
edje = edje_object_add(evas);
edje_object_file_set(edje, &quot;testfile.edj&quot;, &quot;testgroup&quot;);
...
</pre>
<p>Both functions are specific to Edje, in the first case we use edje_object_add
to create a pointer to an Evas object and edje_object_file_set to add the
contents represented by &quot;testgroup&quot; in &quot;testfile.edj&quot;.</p>
<p>As with any other Evas object we need to instruct Evas to make it visible, but
not before adjusting the object inside the canvas or since we are only showing
one object, adjust the canvas to the size of our object:</p>
<pre class="literal-block">
...
Evas_Coord width, height;
...
evas_object_move(edje, 0, 0);
edje_object_size_min_get(edje, &amp;amp;width, &amp;amp;height);
evas_object_resize(edje, width, height);
ecore_evas_resize(ecore_evas, width, height);
evas_object_show(edje);
...
</pre>
<p>First we use evas_object_move to move our Edje object to the left-most, up-most
corner of the canvas. The function edje_object_size_min_get, returns the
minimal possible size of the object and evas_object_resize changes the current
size of the object to those values.</p>
<p>Before the end, we resize the canvas to the same values the object has with
ecore_evas_resize and (finally) instruct Evas to show the object.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id9" id="interacting-with-the-objects" name="interacting-with-the-objects">Interacting with the objects</a></h2>
<p>To understand how to interact with Edje or any other Evas based object we need
to review the basics of how the main loop manager handles events. Ecore
maintains a list of pointers to functions to be called when a signal of a given
type is received. These functions are known as signal &quot;handlers&quot;.</p>
<p>By default, Ecore awareness is limited to system singals like HUP or KILL.
Additional libraries or modules like Ecore_Evas register new signal types for
the event loop to be aware of. In the specific case of Evas the new signal
types deal with the interaction between the user and the Evas objects displayed
in the canvas.</p>
<p>The developer can manipulate the list of handlers as well as creating new
signal types. The latter among other subjects like timers and pollers exceed
the scope of this book and are properly documented by the API reference and the
EFL Cookbook.</p>
<p>We will begin by setting up a simple signal handler that will be called any
time the application is closed:</p>
<pre class="literal-block">
Ecore_Event_Handler* close = NULL;
...
int
good_bye(void *data, int type, void *event)
{
    //Removing handler for no reason other than API showoff
    if (ecore_event_handler_del(close))
        printf(&quot;Handler deleted\n&quot;);

    printf(&quot;Good bye! \n&quot;);
    ecore_main_loop_quit();
    ecore_evas_shutdown();
    ecore_shutdown();
    edje_shutdown();
}
...
int main() {
...
    close = ecore_event_handler_add(ECORE_EVENT_SIGNAL_EXIT,
                                    good_bye,&quot;data&quot;);
    ...
    ecore_main_loop_begin();
    ...
</pre>
<p>This example moves the library shutdown procedure from the main function to the
&quot;good_bye&quot; function. Then before the main loop is initiated we add the handler
for this signal type. The last parameter it's a pointer to any kind of data you
want to pass to the handler function, in this case is just a string containing
&quot;data&quot;.</p>
<p>Interaction with the interface works in a similar way. The Edje library
registers its own handler function in the Ecore loop. This handler will be
called for every signal coming from the interface. Therefore, in order to react
to interface events we need to register our functions as &quot;callbacks&quot; in this
handler's list:</p>
<pre class="literal-block">
...
void
colorize(void *data, Evas_Object *o, const char *emission,
         const char *source)
{
    Evas_Coord x,y;
    evas_pointer_canvas_xy_get(evas,&amp;amp;x,&amp;amp;y);
    if(x &gt; 255) x = 255;
    if(y &gt; 255) y = 255;             //R,   G,   B,   A,
    edje_color_class_set(&quot;main color&quot;, 190, x,   y,   255,
                                       255, 255, 255, 255,
                                       255, 255, 255, 255);
}
...
int main() {
    ...
    edje_object_signal_callback_add(edje, &quot;mouse,move&quot;, &quot;*&quot;,
                                    colorize,&quot;data&quot;);
    ...
    ecore_main_loop_begin();
    ...
</pre>
<p>The resulting application changes the color of every part using the &quot;main
color&quot; color class every time the mouse moves inside the interface. If you use
the EDC theme included in the assembled example the result will be a small
rectangle in the middle of the canvas that changes of color as we move our
mouse around.</p>
<p>The function that produces this effect is our handler, or callback, <tt class="docutils literal"><span class="pre">colorize</span></tt>.
We call functions from the Evas API <tt class="docutils literal"><span class="pre">evas_pointer_canvas_xy_get</span></tt> and the Edje
API <tt class="docutils literal"><span class="pre">edje_color_class_set</span></tt>. The first call gets the current coordinates of
the mouse pointer position. The second call uses those values to alter the
color class &quot;main color&quot;.</p>
<p>Before the main loop begins we use <tt class="docutils literal"><span class="pre">edje_object_signal_callback_add</span></tt> to
register our callback. The real handler keeps its own list of functions to call.
This list's index is a combination of the signal identification and the name of
the source that emitted it. In this particular case, the function <tt class="docutils literal"><span class="pre">colorize</span></tt>
will be called when the signal &quot;mouse,move&quot; is emitted by any object in the
interface. Edje string matching supports wildcards for both the name and source
of the signal.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id10" id="building-a-framework" name="building-a-framework">Building a framework</a></h2>
<p>Hopefully the reader has not been introduced to the concept of software
frameworks by web based monsters like Ruby on Rails. Personally I think RoR is
great and my point is that a framework does not necessarily mean large software
libraries. A framework can be seen as library of functions determined by the
similarity in the profile of the applications that use it. In a framework,
shorter development time means either more specific profiles or more complex
library code.</p>
<p>In this section and the following subsections we will develop an application
framework for applications with a specific profile: &quot;A X11 desktop application
that doesn't require any exotic manipulation of its theme or configuration
files&quot;. A list of the tasks the framework must perform follow:</p>
<ul>
<li><dl class="first docutils">
<dt>Configuration (Using Ecore_Config).</dt>
<dd><ul class="first last simple">
<li>Initialization and shutdown of the necessary services.</li>
<li>Saving configuration changes on exit.</li>
<li>Recall the previously saved values on initialzation.</li>
<li>Control that the necessary configuration and theme files exist.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Interface Management</dt>
<dd><ul class="first last simple">
<li>Create windows with their properties lifted from a given Edje object.</li>
<li>Allocate, load and display Edje objects from a &quot;current&quot; theme file, set
by the user or a &quot;default&quot; theme file setup by the application developer.</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>The example application using this framework will be an Edje group viewer, this
application will receive a filename and a group name, it will display them
inside a viewport managed with a minimap. The last signal emitted by the object
is going to be printed to a given text string. Without further ado, here it is,
the main file:</p>
<pre class="literal-block">
#include &quot;../lib/framework.c&quot;
#include &quot;../lib/viewport.c&quot;
#include &quot;../lib/minimap.c&quot;
#include &lt;string.h&gt;
#include &lt;limits.h&gt;

int arguments_parse(char path[], char group[], int argc, char **argv);

int main(int argc, char **argv) {

    Ecore_Evas  *mainWindow = NULL;
    Evas        *mainCanvas = NULL;
    Evas_Coord   width, height;
    Evas_Object *mainLayout, *toView, *viewport, *minimap;
    char         path[PATH_MAX],group[100];

    application_name_set(&quot;Plain Edje Viewer&quot;);
    if (!simpler_init())
        return EXIT_FAILURE;

    if(!arguments_parse(path, group, argc, argv))
        return EXIT_FAILURE;

    mainWindow = simpler_window_new(&quot;window/main&quot;,NULL);
    if (!mainWindow)
        return EXIT_FAILURE;
    mainCanvas = ecore_evas_get(mainWindow);
    mainLayout = ecore_evas_data_get(mainWindow,&quot;layout&quot;);
</pre>
<p>The precedeing code snippet shows two of the three shortcuts our framework
provides. The first function <tt class="docutils literal"><span class="pre">simpler_init</span></tt> is used to group all the library
intialization functions along with the configuration initialzation functions.
Following the library initialzation comes <tt class="docutils literal"><span class="pre">simpler_window_new</span></tt> which is used
to create a window based on values provided by a given Edje group. The group
itself is saved inside the Ecore_Evas canvas wrapper as a data pointer and can
be retrieved with <tt class="docutils literal"><span class="pre">ecore_evas_data_get</span></tt>. As you might notice we use of a
function named <tt class="docutils literal"><span class="pre">arguments_parse</span></tt> to get the path of the requested file and
group from the array of arguments.</p>
<p>Notice that the call to <tt class="docutils literal"><span class="pre">simpler_window_new</span></tt> does not have any filename
attached to it. But how does the application know where to look this group up?
This is the work of Ecore_Config and we will review how is it used in the next
section of the book. In any case, the following code snippet show a little more
Edje related action:</p>
<pre class="literal-block">
    toView = edje_object_add(mainCanvas);
    edje_object_file_set(toView, path, group);
    edje_object_size_min_calc(toView, &amp;width, &amp;height);
    if(width &lt;= 0)
        ecore_evas_geometry_get(mainWindow, NULL, NULL, &amp;width, NULL);
    if(height &lt;= 0)
        ecore_evas_geometry_get(mainWindow, NULL, NULL, NULL, &amp;height);
    evas_object_resize(toView, width, height);
    evas_object_move(toView,0,0);
    evas_object_show(toView);

    viewport = viewport_add(mainCanvas);
    viewport_theme_set(viewport, simpler_object_add(mainCanvas, &quot;widget.minimap&quot;));
    viewport_target_set(viewport,toView);
    edje_object_part_swallow(mainLayout,&quot;swallow.viewport&quot;, viewport);

    minimap = minimap_add(mainCanvas);
    minimap_theme_set(minimap, simpler_object_add(mainCanvas, &quot;widget.minimap&quot;));
    edje_object_part_swallow(mainLayout,&quot;swallow.minimap&quot;, minimap);
    minimap_viewport_set(minimap,viewport);

    ecore_main_loop_begin();
}
</pre>
<p>You might notice the code snippet is split in three bigger sections. In
these sections we include an Edje object to view, we setup the viewport for the
object and the minimap for the viewport respectively. Since the application is
going to display a
group of an arbitrary name from an arbitrary file we don't use the shortcut
functions to load and display the target. But among these know functions
<tt class="docutils literal"><span class="pre">ecore_evas_geometry_get</span></tt> stands out. This function is used to load the
current size of the window as the object width or height in case it does not
have either one.</p>
<p>The following two code sections setup each widget, we won't review the
internals of these yet. We will explore the function <tt class="docutils literal"><span class="pre">simpler_object_add</span></tt>
that is used to load the theme groups for these widgets. In order to mantain
our santity (and to save some trees) some additional functions or pieces have
been left out of the book. The complete, commented sources for this framework
and the &quot;Plain Edje Viewer&quot; application can be found in the CVS repository of
the Enlightenment proyect under <tt class="docutils literal"><span class="pre">e17/docs/devwithedje/src</span></tt>. Rest assured the
omitted functions wont add much to your knowledege about Edje.</p>
<div class="section">
<h3><a class="toc-backref" href="#id11" id="simpler-library-intialization" name="simpler-library-intialization">Simpler library intialization</a></h3>
<p>We have seen initialization functions previously in this chapter and other that
an increased level of verbosity there is nothing special about the use we have
give them here:</p>
<pre class="literal-block">
Evas_Bool
simpler_init()
{
    char *path;

    if (ApplicationName == NULL)
    {
        fprintf(stderr, &quot;Error: The application's name was not set.\n&quot;);
        return FALSE;
    }

    if (!evas_init())
    {
        fprintf(stderr, &quot;Error: Evas failed to initialize.\n&quot;);
        return FALSE;
    }
    ...
</pre>
<p>The rest of the initialization functions can be found in the CVS repository, I
decided to show this particular piece because it shows a characteristic of the
framework that can become a problem. Having an application's name setup is a
requeriment of Ecore_Config. It uses that name to search for or create a
configuration directory and file. Unless it was explicitly altered by the
developer the default location of the configuration file will be
<tt class="docutils literal"><span class="pre">$HOME/.e/apps/ApplicationName/config.eet</span></tt>. Once the application's name has
been set, we are safe to work with Ecore_Config:</p>
<pre class="literal-block">
    ...
    ecore_config_theme_default(&quot;theme/default&quot;, &quot;default&quot;);
    ecore_config_theme_default(&quot;theme/current&quot;, &quot;default&quot;);
    if (ecore_config_load() != ECORE_CONFIG_ERR_SUCC)
    {
        fprintf(stderr,&quot;Warning: Could not load config from ~/.e/apps/%s/config.eet\n&quot;, ApplicationName);
    }
    path = ecore_config_theme_with_path_get(&quot;theme/default&quot;);
    if (path == NULL)
    {
        fprintf(stderr,&quot;Error: The default theme, '%s.edj', was not found in the PATH='%s'.\n&quot;, ecore_config_theme_get(&quot;theme/default&quot;), ecore_config_theme_default_path_get());
        return FALSE;
    }
    return TRUE;
}
</pre>
<p>An excellent introduction to Ecore_Config already exists in the EFL Cookbook
and I won't replicate here. But I will resume the functions used in this code
sample. The first function called is <tt class="docutils literal"><span class="pre">ecore_config_theme_default</span></tt> and it's
used to setup the default value for a given theme configuration item, don't
worry, the specifics of &quot;theme configuration items&quot; are explained further down
this book. In any case, setting up a default value is useful to ensure a valid
value in case the configuration file is non-existent or incomplete.</p>
<p>Right after setting some default values we use <tt class="docutils literal"><span class="pre">ecore_config_load</span></tt> to load
the configuration file found in the default location mentioned earlier. It is
a good practice to not use custom file locations for configuration files
because it eases portability of the application. The user will also apreciate
the additional feeling of certainlity of how an application is going to behave.
Still, the alternative function <tt class="docutils literal"><span class="pre">ecore_config_file_load</span></tt> could have been used
to load a configuration file from a custom location.</p>
<p>Before finishing successfully we will have to control that at least the default
theme file can be found somewhere. Finding at least one theme file is pretty
much mandatory for any Edje based application.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id12" id="simpler-window-setup" name="simpler-window-setup">Simpler window setup</a></h3>
<p>Setting up a window isn't complex by itself, but why would we manually setup
these properties, copy and paste these big blocks of code and manually
replace the parameters for them to adjust to our new application when we can
use an automated method that also gives more freedom to the designer?</p>
<p>In this example all the properties for the window including the maximum and
minimum sizes, name and class are setup by a &quot;group&quot; in an Edje theme file.
It's up to the developer's personal taste to decide how much control a designer
will have, thus altering the behaviour of this function was left as an
excercice for the reader:</p>
<pre class="literal-block">
Ecore_Evas*
simpler_window_new(const char *groupName, Ecore_Evas *parent)
{
    Ecore_Evas         *window;
    Evas               *canvas;
    Evas_Object        *layout;
    Window_Properties  *prop;
    Evas_Coord         width, height;

    if (parent == NULL)
    {
        window = ecore_evas_software_x11_new(NULL, 0, 0, 0, 0, 0);
        ecore_evas_data_set(window, &quot;is_main&quot;, &quot;yes&quot;);
    }
    else
    {
        window = ecore_evas_software_x11_new(NULL, ecore_evas_software_x11_window_get(parent), 0, 0, 0, 0);
        ecore_evas_data_set(window, &quot;is_main&quot;, &quot;no&quot;);
    }

    if (window == NULL)
    {
        fprintf(stderr, &quot;Error: Couldn't initiate the canvas wrapper.\n&quot;);
        return NULL;
    }

    canvas = ecore_evas_get(window);
    if (canvas == NULL)
    {
        fprintf(stderr,&quot;Error: There is no canvas in the window.\n&quot;);
        return NULL;
    }

    layout = simpler_object_add(canvas, groupName);
    if (layout == NULL)
    {
        fprintf(stderr, &quot;Error: Couldn't load the layout object.\n&quot;);
        return NULL;
    }
    ecore_evas_data_set(window,&quot;layout&quot;,layout);
    ...
</pre>
<p>By now you might be wondering if there is a real reason to abstract functions
as simple and wildly known such as these? There is no simple answer other than
that these function set properties that could cause unexpected behaviour later
in the application. I spent an hour of my life trying to figure out why the
size calculation of the canvas didn't reflect the size changes that occurred in
this very initalization function.</p>
<p>Now that I have justified the first part of the function we might as well
analyze it! Most of these function have been seen before except for two. The
first function is <tt class="docutils literal"><span class="pre">simpler_object_add</span></tt>, it is a part of the framework that
acts as a wrapper for <tt class="docutils literal"><span class="pre">edje_object_add</span></tt> and <tt class="docutils literal"><span class="pre">edje_file_set</span></tt>. The specifics
of this function are going to be explained in the next chapters. The second
function is <tt class="docutils literal"><span class="pre">ecore_evas_data_set</span></tt>, it is a standard Ecore_Evas function and
it's used to attach pointers to arbitrary data to a given key, in this case
we save the layout Edje object in the &quot;layout&quot; data pointer. The next functions
will probably be altered by most application developers, and it can be split
in three big sections of code:</p>
<pre class="literal-block">
    ...
    prop = _window_prop_get(layout);
    ecore_evas_title_set(window, prop-&gt;title);
    ecore_evas_name_class_set(window, prop-&gt;name, prop-&gt;class);
    ecore_evas_size_min_set(window, prop-&gt;minw, prop-&gt;minh);
    ecore_evas_size_max_set(window, prop-&gt;maxw, prop-&gt;maxh);

    evas_object_move(layout, 0, 0);
    edje_object_size_min_get(layout, &amp;width, &amp;height);
    evas_object_resize(layout, width, height);
    ecore_evas_resize(window,  width, height);
    evas_output_size_set(ecore_evas_get(window), width, height);

    ecore_evas_callback_resize_set(window, _resize_window);
    ecore_evas_callback_delete_request_set(window, _close_window);
    ecore_evas_callback_destroy_set(window, _close_window);
    ecore_event_handler_add(ECORE_EVENT_SIGNAL_EXIT, _close_application, window);

    ecore_evas_show(window);
    return window;
}
</pre>
<p>We can begin our analysis with the first section of code. There we setup the
various properties of the window, including titile, name, class, maximum and
minimum size. Some of these properties could have been setup before
with <tt class="docutils literal"><span class="pre">ecore_evas_software_x11_new</span></tt> if we wanted them to be hard coded in the
framework. In this case we needed to load an Edje object to memory and a canvas
is needed to initialize the objects.</p>
<p>The second section of code looks quite familiar since it is basically a carbon
copy of code written in &quot;The foundations at practice&quot;, this section is used to
synchronize the sizes of the window and the Edje group used as a layout object.</p>
<p>In the last section we set a couple of callbacks. The first callback resizes
the layout object along with the window, thus all the inserted objects that are
relative to the layout are going to be resized when the window is resized. The
rest of the callbacks are used to shutdown the application in different
situations. The function, <tt class="docutils literal"><span class="pre">_close_window</span></tt> is quite simple, and will calle
<tt class="docutils literal"><span class="pre">_close_application</span></tt> when the user closes the main window. A main window is
any window without a parent, the framework assumes you will only create one
parentless window per application.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id13" id="simpler-theme-management" name="simpler-theme-management">Simpler theme management</a></h3>
<p>In the previous section we have seen how to create a window based on parameters
lifted from a given Edje object referred to as the layout object. If you take
a look you will see that the layout object was acquired differently than the
common Edje object, the function is names <tt class="docutils literal"><span class="pre">simple_object_add</span></tt> and its used
in the main function to load the themes for the viewport widget and the minimap
widget as well.</p>
<p>In this chapter we will review all the functions called to make this simpler
method of acquiring Edje objects possible:</p>
<pre class="literal-block">
Evas_Object *
simpler_object_add(Evas *canvas, const char *group)
{
    Evas_Object *o;
    o = edje_object_add(canvas);
    if(simpler_object_file_set(o, ecore_config_theme_with_path_get(&quot;theme/current&quot;), group))
    {
        return o;
    }
    else
    {
        if(simpler_object_file_set(o, ecore_config_theme_with_path_get(&quot;theme/default&quot;), group))
        {
            return o;
        }
    }
    return NULL;
}
</pre>
<p>We begin by the most popular <tt class="docutils literal"><span class="pre">simpler_object_add</span></tt>. All this function really
does is to allocate and initate the object in the chosen canvas with
<tt class="docutils literal"><span class="pre">edje_object_add</span></tt>. The rest of the work is done by <tt class="docutils literal"><span class="pre">simpler_object_file_set</span></tt>
and <tt class="docutils literal"><span class="pre">ecore_config_theme_with_path_get</span></tt>.</p>
<p>As I have said earlier we are going to use Ecore_Config to manage the
application's settings. An introduction to Ecore_Config can be found in the
&quot;EFL Cookbook&quot; downloaded for free in the Enlightenment project website. This
particular setting is used to manage a theme file name. Altought this sounds
like basically managing a string the function``ecore_config_theme_with_path_get``
show us how it actually work, better expressed in pseudocode:</p>
<pre class="literal-block">
ecore_config_theme_with_path_get(key):
    theme_file_name = search_config_file_for(key)
    possible_paths = ecore_config_theme_search_path_get()
    for each path in possible_paths:
        if theme_file_name in path:
            return path + theme_file_name
        else
            continue
</pre>
<p>What this means is that a <tt class="docutils literal"><span class="pre">ecore_config_theme_*</span></tt> property is quite more
advanced than a simple path in the form of a string. Now that we have that
cleared up lets hit the next function in the calling stack:</p>
<pre class="literal-block">
Evas_Bool
simpler_object_file_set(Evas_Object *o, const char *path, const char *group)
{
    if(path != NULL)
    {
        if(!ecore_file_exists(path))
        {
            fprintf(stderr, &quot;Warning: Failed to find the theme file '%s'.\n&quot;, path);
            return FALSE;
        }
        else
        {
            if(!edje_file_group_exists(path, group))
            {
                fprintf(stderr, &quot;Warning: Failed to find group '%s' in theme file '%s'.\n&quot;, group, path);
                return FALSE;
            }
            else
            {
                edje_object_file_set(o, path, group);
                evas_object_show(o);
                return TRUE;
            }
        }
    }
    else
        return FALSE;
}
</pre>
<p>This function is also quite simple. It basically calls <cite>edje_object_file_set</cite>
after running some checks to see if the parameters are valid. After that, it
sets the object to be displayed with <tt class="docutils literal"><span class="pre">evas_object_show</span></tt> mainly because the
default value hides the object and it will not be used as often by the callers
of this function.</p>
<p>These, and a couple of more functions are used by every application fitting the
profile of this framework. I wrote this code expecting you will want to modify
it, learning a lot in the process, so I commented and structured the full
source in Enlightenment's CVS server exactly for this prupose.</p>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id14" id="introduction-to-widgets" name="introduction-to-widgets">Introduction to widgets</a></h1>
<p>Graphical User Interfaces do not only to display information, they convey
information. Interface elements have a meaning of their own and this meaning
alters the user's perception on the information displayed, for better or for
worse. A flexible interface design system means the designer can add more
meaning to the information. Features like multiple states and transitions
extend this capacity to the point where the designer's creativity is the limit.</p>
<p>As the application matures the number of elments in the interface will grow.
These elements will be grouped by some common property or prupose. Functions to
deal with these groups as a unit are also going to be created. This is not an
unique process and anyone creating a GUI from scratch would go through it.
These groups and the functions that deal with them is what is commonly know as
&quot;widgets&quot;. Widgets work as a small application inside our own.</p>
<p>In order to work a widget needs access to the drawing device to request that
the primitive objects that conform it be drawn. Most widgets will want to
interact with their environment, thus they need to be familiar with the Event
loop managing the application. As we would do with a plain interface, the
widget will register callbacks for its own functions that deal with events in
the primitive objects that conform it.</p>
<div align="center" class="align-center"><img alt="img/graphical_application_components_widget.png" class="align-center" src="img/graphical_application_components_widget.png" style="width: 1761.2px; height: 1307.3px;" /></div>
<p>In order to be possible for the rest of the application to interact effectively
with a widget it has to provide the Event loop with new signal types
representing abstracted version of its interface signals. It basically
intercepts what would be otherwise normal interface signals and (sometimes)
replace them with its own abstracted versions.</p>
<p>In general terms, a developer implementing a widget from the scratch would have
to program functions to:</p>
<ul class="simple">
<li>Manipulate the canvas primitives to draw the widget.</li>
<li>Register new signal types to emit as a widget.</li>
<li>Display information and retrieve changes.</li>
<li>Handle events ocurring in the environment that affect it.</li>
<li>Handle events ocurring on its primitives.</li>
</ul>
<p>Depending on the complexity of the widgets, the amount of functions represented
by the last item can become quite large.</p>
<div class="section">
<h2><a class="toc-backref" href="#id15" id="widgets-with-edje" name="widgets-with-edje">Widgets with Edje</a></h2>
<p>We have seen there are roughly 5 kinds of functions that have to be implemented
in order to create a widget from scratch. Although the way groups are split
might not seem to correspond with the amount of work each one might entail, the
divisions concord with the shortcuts Edje provides. For the cases where
the number of functions in one group seems to clearly outweighs the others,
Edje provides additional shortcuts not directly related to the design concepts
and design elements we have seen in the previous chapters.</p>
<p>I will begin with <strong>Manipulate the canvas primitives to draw the widget</strong> since
it's the easiest to explain. With a plain canvas approach to widget creation,
this would mean the developer must manually create each rect, line, etc. that
form its widget. Instead, Edje draws the primitive objects based on the
designer's  specifications in the Edje Data Collection file, not a single
primitive has to be created or manipulated by the application developer.</p>
<p>Addressing the task <strong>Handle events occurring on its primitives</strong> using
Edje can be done with two different, but compatible, approaches. The first
approach is also available in the other low level libraries. To intercept all
the signals coming from the primitive objects that form the widget, filter the
signals and (sometimes) emit a new kind of signal. This approach is useful in
many situations and that's why it is possible to use it in Edje even when it
provides an alternative, not available among its low level cousins. With Edje
designer can write small &quot;programs&quot; in his EDC files. An Edje program is
not as complex as the name might make us think. Unless the designer uses a
script block (rare) the average Edje program would look like this:</p>
<pre class="literal-block">
program {
    name:       &quot;playthemusic&quot;;
    signal:     &quot;mouse,down,1&quot;;
    source:     &quot;*&quot;;
    action:      action: SIGNAL_EMIT &quot;PLAY&quot; &quot;button&quot;;
}
</pre>
<p>There is more to Edje programs than just this, but this example will be enough
to illustrate the point. Since Edje programs are limited to their own group,
this program is limited to a hypothetical &quot;button&quot; group. What the program does
is to emit the signal &quot;PLAY&quot; when the left button is pressed over any part that
forms the &quot;button&quot; group. The application only has to listen for the PLAY
signal. When and why that signal will be emitted is completely up to the
designer to decide. He could change &quot;mouse,down,1&quot; to &quot;mouse,wheel,*&quot; and cause
the music to play when the user uses the mouse wheel over any part of the
button.</p>
<p>The previously illustrated program shows that <strong>Register new signal types to
emit as a widget</strong> will not be as common as it would with another canvas
library. Most of the time, it will be designer who implements new signal types.
Sadly, there is little that Edje can provide concerning <strong>Handle events
occurring in the environment that affect it</strong>.</p>
<p>To <strong>Display information and retrieve changes</strong> is quite simple. As with any
other low level library, the developer will have to alter some primitive in
order to display the requested information. Most of the time this means
changing a string of characters, complex diagrams and similar objects go
beyond the scope of Edje and enter the realm of Evas programming. Plain Evas
objects, of course, integrate perfectly with Edje interfaces.</p>
<p>A difference between a regular canvas lib and Edje concerns conveying subtle
information by changing the &quot;state&quot; of the interface. Designers can implement
any arbitrary number of states for any part or group and change them using
simple Edje programs. The same programs can also be triggered by the
application. For example, to disable a button in a plain canvas the developer
would have to call functions that gray out the background and text. With Edje
the developer just emits the signal &quot;DISABLED&quot; to the button and lets the
designer implement this however he wants.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id16" id="the-ewl-as-a-shortcut" name="the-ewl-as-a-shortcut">The Ewl as a shortcut</a></h2>
<p>Creating custom widgets even with the facilities Edje provides can become a
very complex task with more advanced widgets. Thankfully for us a working
widget library for those specially-hard widgets already exists. Altought the
goal of the Enlightened Widget Library are not exactly in synch with the goals
of plain Edje application development, hard work has been done by the EWL
developers to make including their widgets in a plain Edje interface possible.</p>
<p>But before we go into further implementation details it might be a good idea to
quote the introduction to the Ewl API reference:</p>
<blockquote>
<p>The Enlightened Widget Library (Ewl) is a high level toolkit providing all
of the widgets you'll need to create your application. Ewl is built on the
Enlightenment Foundataion Libraries and makes heavy use of the provided
technologies. The goal of Ewl is to abstract the use of these backends and
to present an easy to use object model to the end programmer. The expansive
object oriented style API provides tools to easily extend widgets and
containers for new situations.</p>
<p>Overall, Ewl is similar in design and functionality to other common
toolkits such as GTK+ and QT. The APIs differ, but the overall concepts and
ideas are similar. If you are familiar with these other toolkits getting
into Ewl should be relatively simple.</p>
</blockquote>
<p>Simply put, the goal of the Ewl developers is to abstract Edje as on of many
rendering backends. This is not a bad thing on its own, but for developers
wanting to use Edje capabilities to the max the Ewl can become limiting. Great
care is taken by the Ewl developers to not limit theme designers and this has
resulted in a library that does <em>not</em> limit the themer more often than it does.</p>
<p>In any case, the Enlightened Widget Library provides an special type of
container know as the &quot;embed&quot; container. Widgets included in this container can
be swallowed into a SWALLOW part in a common Edje interface. Once the widget
has been included its appearance can be altered in a per-theme basis in order
for the widget to fit the rest of the application as cleanly as possible.</p>
<p>You might not want to use Ewl to create simple interface objects like buttons
and check boxes. But it can become an invaluable time saver for complex widgets
like trees and file management dialogs. A great resource to learn how to
include Ewl widgets into an Edje interface is the source code ewl_embed_test.c
which is logically divided and toroughly commented.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id17" id="implementing-widgets-with-edje" name="implementing-widgets-with-edje">Implementing widgets with Edje</a></h2>
<div class="section">
<h3><a class="toc-backref" href="#id18" id="introduction-to-smart-objects" name="introduction-to-smart-objects">Introduction to Smart Objects</a></h3>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id19" id="the-foundations-of-a-smart-object" name="the-foundations-of-a-smart-object">The foundations of a Smart Object</a></h3>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id20" id="laying-out-widgets" name="laying-out-widgets">Laying out widgets</a></h2>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id21" id="creating-list-based-widgets" name="creating-list-based-widgets">Creating list based widgets</a></h2>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id22" id="widgets-by-example" name="widgets-by-example">Widgets by Example</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id23" id="the-text-entry" name="the-text-entry">The text entry</a></h2>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id24" id="the-combox" name="the-combox">The combox</a></h2>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id25" id="the-kinetic-list" name="the-kinetic-list">The kinetic list</a></h2>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id26" id="the-media-viewport" name="the-media-viewport">The media viewport</a></h2>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id27" id="flexible-toolbars" name="flexible-toolbars">Flexible toolbars</a></h2>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
This will be at the top of every page.
</div>
</body>
</html>
