From 56bb1613be9004ca2a8ac87096c58d68c476c01e Mon Sep 17 00:00:00 2001
From: Carsten Haitzler (Raster <raster@rasterman.com>
Date: Wed, 29 Oct 2008 21:34:38 +1100
Subject: [PATCH] sysvinit: add the openmoko upstream changes to use exquisite as splash

This just contains the upstream changes from openmoko to use exquisite as
the bootsplash.
---
 packages/sysvinit/sysvinit/openmoko/rc          |  181 +++++++++++++++++++++++
 packages/sysvinit/sysvinit/openmoko/rcS-default |   25 +++
 2 files changed, 206 insertions(+), 0 deletions(-)
 create mode 100644 packages/sysvinit/sysvinit/openmoko/rc
 create mode 100644 packages/sysvinit/sysvinit/openmoko/rcS-default

diff --git a/packages/sysvinit/sysvinit/openmoko/rc b/packages/sysvinit/sysvinit/openmoko/rc
new file mode 100644
index 0000000..9d28a68
--- /dev/null
+++ b/packages/sysvinit/sysvinit/openmoko/rc
@@ -0,0 +1,181 @@
+#!/bin/sh
+#
+# rc		This file is responsible for starting/stopping
+#		services when the runlevel changes.
+#
+#		Optimization feature:
+#		A startup script is _not_ run when the service was
+#		running in the previous runlevel and it wasn't stopped
+#		in the runlevel transition (most Debian services don't
+#		have K?? links in rc{1,2,3,4,5} )
+#
+# Author:	Miquel van Smoorenburg <miquels@cistron.nl>
+#		Bruce Perens <Bruce@Pixar.com>
+#
+# Version:	@(#)rc  2.78  07-Nov-1999  miquels@cistron.nl
+#
+
+. /etc/default/rcS
+export VERBOSE
+
+startup_progress() {
+    step=$(($step + $step_change))
+    if [ "$num_steps" != "0" ]; then
+        progress=$((($step * $progress_size / $num_steps) + $first_step))
+    else
+        progress=$progress_size
+    fi
+    #echo "PROGRESS is $progress $runlevel $first_step + ($step of $num_steps) $step_change $progress_size"
+# FIXME: this should be virtualised and come from a generic boot splash script
+# provided by some generic splash handler - be it psplash, exquisite or
+# whatever else soa  simple install of one splash instead of another works
+    if type exquisite-write >/dev/null 2>&1; then
+         EXQUISITE_IPC=/mnt/.exquisite/exquisite exquisite-write "PROGRESS $progress" || true
+    fi
+}
+
+
+#
+# Start script or program.
+#
+startup() {
+  # Handle verbosity
+  [ "$VERBOSE" = very ] && echo "INIT: Running $@..."
+
+  case "$1" in
+	*.sh)
+		# Source shell script for speed.
+		(
+			trap - INT QUIT TSTP
+			scriptname=$1
+			shift
+			. $scriptname
+		)
+		;;
+	*)
+		"$@"
+		;;
+  esac
+  startup_progress
+}
+
+  # Ignore CTRL-C only in this shell, so we can interrupt subprocesses.
+  trap ":" INT QUIT TSTP
+
+  # Set onlcr to avoid staircase effect.
+  stty onlcr 0>&1
+
+  # Now find out what the current and what the previous runlevel are.
+
+  runlevel=$RUNLEVEL
+  # Get first argument. Set new runlevel to this argument.
+  [ "$1" != "" ] && runlevel=$1
+  if [ "$runlevel" = "" ]
+  then
+	echo "Usage: $0 <runlevel>" >&2
+	exit 1
+  fi
+  previous=$PREVLEVEL
+  [ "$previous" = "" ] && previous=N
+
+  export runlevel previous
+
+  # Is there an rc directory for this new runlevel?
+  if [ -d /etc/rc$runlevel.d ]
+  then
+	# Find out where in the progress bar the initramfs got to.
+	PROGRESS_STATE=0
+	#if [ -f /dev/.initramfs/progress_state ]; then
+	#    . /dev/.initramfs/progress_state
+	#fi
+
+	# Split the remaining portion of the progress bar into thirds
+	progress_size=$(((100 - $PROGRESS_STATE) / 3))
+
+	case "$runlevel" in
+		0|6)
+			# Count down from -100 to 0 and use the entire bar
+			first_step=-100
+			progress_size=100
+			step_change=1
+			;;
+	        S)
+			# Begin where the initramfs left off and use 2/3
+			# of the remaining space
+			first_step=$PROGRESS_STATE
+			progress_size=$(($progress_size * 2))
+			step_change=1
+			;;
+		*)
+			# Begin where rcS left off and use the final 1/3 of
+			# the space (by leaving progress_size unchanged)
+			first_step=$(($progress_size * 2 + $PROGRESS_STATE))
+			step_change=1
+			;;
+	esac
+
+	num_steps=0
+	for s in /etc/rc$runlevel.d/[SK]*; do
+            case "${s##/etc/rc$runlevel.d/S??}" in
+                gdm|xdm|kdm|reboot|halt)
+                    break
+                    ;;
+            esac
+            num_steps=$(($num_steps + 1))
+        done
+        step=0
+
+	# First, run the KILL scripts.
+	if [ $previous != N ]
+	then
+		for i in /etc/rc$runlevel.d/K[0-9][0-9]*
+		do
+			# Check if the script is there.
+			[ ! -f $i ] && continue
+
+			# Stop the service.
+			startup $i stop
+		done
+	fi
+
+	# Now run the START scripts for this runlevel.
+	for i in /etc/rc$runlevel.d/S*
+	do
+		[ ! -f $i ] && continue
+
+		if [ $previous != N ] && [ $previous != S ]
+		then
+			#
+			# Find start script in previous runlevel and
+			# stop script in this runlevel.
+			#
+			suffix=${i#/etc/rc$runlevel.d/S[0-9][0-9]}
+			stop=/etc/rc$runlevel.d/K[0-9][0-9]$suffix
+			previous_start=/etc/rc$previous.d/S[0-9][0-9]$suffix
+			#
+			# If there is a start script in the previous level
+			# and _no_ stop script in this level, we don't
+			# have to re-start the service.
+			#
+			[ -f $previous_start ] && [ ! -f $stop ] && continue
+		fi
+		case "$runlevel" in
+			0|6)
+				startup $i stop
+				;;
+			*)
+				startup $i start
+				;;
+		esac
+	done
+  fi
+
+  # FIXME: this should be virtualised and come from a generic boot splash script
+  # provided by some generic splash handler - be it psplash, exquisite or
+  # whatever else soa  simple install of one splash instead of another works
+  if [ "x$runlevel" != "xS" ]; then
+	if type exquisite-write >/dev/null 2>&1; then
+		EXQUISITE_IPC=/mnt/.exquisite/exquisite exquisite-write "QUIT" || true
+		umount /mnt/.exquisite
+	fi
+  fi
diff --git a/packages/sysvinit/sysvinit/openmoko/rcS-default b/packages/sysvinit/sysvinit/openmoko/rcS-default
new file mode 100644
index 0000000..5bb57ef
--- /dev/null
+++ b/packages/sysvinit/sysvinit/openmoko/rcS-default
@@ -0,0 +1,25 @@
+#
+#	Defaults for the boot scripts in /etc/rcS.d
+#
+
+# Time files in /tmp are kept in days.
+TMPTIME=0
+# Set to yes if you want sulogin to be spawned on bootup
+SULOGIN=no
+# Set to no if you want to be able to login over telnet/rlogin
+# before system startup is complete (as soon as inetd is started)
+DELAYLOGIN=no
+# Set UTC=yes if your system clock is set to UTC (GMT), and UTC=no if not.
+UTC=yes
+# Set VERBOSE to "no" if you would like a more quiet bootup.
+VERBOSE=no
+# Set EDITMOTD to "no" if you don't want /etc/motd to be editted automatically
+EDITMOTD=no
+# Whether to fsck root on boot
+ENABLE_ROOTFS_FSCK=no
+# Set FSCKFIX to "yes" if you want to add "-y" to the fsck at startup.
+FSCKFIX=yes
+# Set TICKADJ to the correct tick value for this specific machine
+#TICKADJ=10000
+# Enable caching in populate-volatile.sh
+VOLATILE_ENABLE_CACHE=yes
-- 
1.5.4.3

