#! @PERL@ -w

#
# Copyright (C) 2000, 2001 Christian Kreibich <cK@whoop.org>.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software and its documentation and acknowledgment shall be
# given in the documentation and software packages that this Software was
# used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

use strict;

# Globals
#___________________________________________________________________________
my $magic_file;
my $db_file;

# Efsd Constants
#___________________________________________________________________________
my $EFSD_MAGIC_8       = 0;
my $EFSD_MAGIC_16      = 1;
my $EFSD_MAGIC_32      = 2;
my $EFSD_MAGIC_STRING  = 3;

my $EFSD_MAGIC_TEST_EQUAL     = 0;
my $EFSD_MAGIC_TEST_NOTEQUAL  = 1;
my $EFSD_MAGIC_TEST_SMALLER   = 2;
my $EFSD_MAGIC_TEST_LARGER    = 3;
my $EFSD_MAGIC_TEST_MASK      = 4;
my $EFSD_MAGIC_TEST_NOTMASK   = 5;
my $EFSD_MAGIC_TEST_SUBST     = 6;

my $EFSD_BYTEORDER_HOST       = 0;
my $EFSD_BYTEORDER_BIG        = 1;
my $EFSD_BYTEORDER_SMALL      = 2;


# Prototypes
#___________________________________________________________________________

sub e_db_command_add;
sub e_db_command_add_remaining;
sub e_db_int_set;
sub e_db_str_set;
sub e_db_data_set;
sub to_dec;
sub write_magic;
sub do_it;

{
  my @command;

  sub e_db_command_add {
    
    if (scalar(@command) == 0)
      {
	@command = ("@EDB_ED@", $db_file, @_);
      }
    else
      {
	my $i;

	for ($i = 0; $i < 4; $i++)
	  {
	    push (@command, $_[$i]);
	  }
      }
    
    if (scalar(@command) > 4000)
      {
	system(@command) == 0
	  or die "edb_ed call failed: $?";

	@command = ();
      }
  }

  sub e_db_command_add_remaining {

    system(@command) == 0
      or die "edb_ed call failed: $?";
    
    @command = ();
  }
}

sub e_db_int_set {
  
  my ($key, $val) = @_;

  e_db_command_add("add", $key, "int", $val);  
}

sub e_db_str_set {

  my ($key, $val) = @_;

  e_db_command_add("add", $key, "str", $val);  
}


sub e_db_data_set {

  my ($key, $val) = @_;

  e_db_command_add("add", $key, "data", $val);  
}


sub to_dec {
 
  my $value = $_[0];

  if (substr($value, 0, 1) eq "0")
    {
      if (substr($value, -1) eq "L")
	{
	  $value = oct(substr($value,0,-1));
	}
      else
	{
	  $value = oct($value);
	}
    }
  
  $value;
}

sub write_magic {

  my $indices_ptr = $_[0];
  my $level       = $_[1];
  my $magic_ptr   = $_[2];
  my $s;
  my $key;
  my $i;

  for ($i = 0, $s = "/"; $i <= $level; $i++)
    {
      $s = $s . $$indices_ptr[$i] . "/";
    }
  
  if (defined($$magic_ptr{"offset"}))
    {
      $key = $s . "offset";
      e_db_int_set($key, $$magic_ptr{"offset"});
    }
  if (defined($$magic_ptr{"byteorder"}))
    {
      $key = $s . "byteorder";
      e_db_int_set($key, $$magic_ptr{"byteorder"});
    }
  if (defined($$magic_ptr{"type"}))
    {
      $key = $s . "type";
      e_db_int_set($key, $$magic_ptr{"type"});
    }
  if (defined($$magic_ptr{"mask"}))
    {
      $key = $s . "mask";
      e_db_int_set($key, $$magic_ptr{"mask"});
    }
  if (defined($$magic_ptr{"test"}))
    {
      $key = $s . "test";
      e_db_int_set($key, $$magic_ptr{"test"});
    }
  if (defined($$magic_ptr{"value"}))
    {
      $key = $s . "value";

      if ($$magic_ptr{"type"} == $EFSD_MAGIC_STRING)
	{
	  e_db_data_set($key, $$magic_ptr{"value"});
	}
      else
	{
	  e_db_int_set($key, $$magic_ptr{"value"});
	}
    }
  if (defined($$magic_ptr{"filetype"}))
    {
      $key = $s . "filetype";
      e_db_str_set($key, $$magic_ptr{"filetype"});
    }
}


sub do_it {

  my @indices;
  my $line;
  my $level;
  my $old_level = -1;
  my $i;
  my $item;
  my %magic;
  my $dropped_level;
  my $value_prefix = "";
  my $num_tests = 0;

  open (MAGIC, $magic_file)
    or die "Can't open magic file $magic_file: ";

  $dropped_level = 1000000;

  # Make stdout unbuffered:
  select(STDOUT);
  $| = 1; 

  while ($line = <MAGIC>)
    {     
      unless (($line =~ /^#.*/m) || ($line =~ /^$/m))
	{

	 # clear hash:
	 undef(%magic);

	 # clear prefix
	 $value_prefix = "";

	 # Okay -- it's a magic definition -- parse it.

#	 print "$line";
	 
	 if ($line =~ /^(>*)                                     # level of the test
	                ((?:0x)??[0-9a-fA-F]+)\s+               # numerical offset
	                (be|le)??(byte|short|long|string)        # endianness and type, no date
                        (&(?:0x)??[0-9a-fA-F]+)??\s+               # possibly, a mask for the value
	                ([!<>&\^=]?)((?:0x)??[0-9a-fA-F]+?|      # test for either a num. value
                        (?:\\\s+|\S)+|\.)\s+                  # or a string
#                        (?:\\\s+|\S)+\S|[^x]{1}) \s+            # or a string
	                (\S.*)\s+$/x)                            # and finally, the comment.
#	                (\S+\s*)+$/x)                            # and finally, the comment.
	   {
	     $level = length($1);

	     if ($level > $dropped_level)
	       {
		 next;
	       }
	     else
	       {
		 $dropped_level = 1000000;
	       }

	     if ($level > $old_level)
	       {
		 $indices[$level] = 0;
	       }
	     else
	       {
		 $indices[$level]++;
	       }
	
	     $old_level = $level;

	     # Write offset:
	     $item = $2;
	     $magic{"offset"} = to_dec($item);

	     # Write byteorder:
	     if (defined ($3))
	       {
		 $item = $3;
		 if ($item eq "be")
		   {
		     $magic{"byteorder"} = $EFSD_BYTEORDER_BIG;
		   }
		 elsif ($item eq "le")
		   {
		     $magic{"byteorder"} = $EFSD_BYTEORDER_SMALL;
		   }
		 else
		   {
		     $magic{"byteorder"} = $EFSD_BYTEORDER_HOST;
		   }
	       }
	     else
	       {
		 $magic{"byteorder"} = $EFSD_BYTEORDER_HOST;
	       }

	     # Write type:
	     $item = $4;

	     if ($item eq "byte")
	       {
		 $magic{"type"} = $EFSD_MAGIC_8;
	       }
	     elsif ($item eq "short")
	       {
		 $magic{"type"} = $EFSD_MAGIC_16;
	       }
	     elsif ($item eq "long")
	       {
		 $magic{"type"} = $EFSD_MAGIC_32;
	       }
	     else
	       {
		 $magic{"type"} = $EFSD_MAGIC_STRING;
	       }

	     # Write mask:
	     if (defined ($5))
	       {
		 $item = substr($5,1);
		 $magic{"mask"} = to_dec($item);
	       }

	     # Write test-type:
	     if (defined ($6))
	       {
		 $item = $6;

		 if ($item eq "<")
		   {
		     $magic{"test"} = $EFSD_MAGIC_TEST_SMALLER;
		   }
		 elsif ($item eq ">")
		   {
		     $magic{"test"} = $EFSD_MAGIC_TEST_LARGER;
		   }
		 elsif ($item eq "&")
		   {
		     if ($magic{"type"} == $EFSD_MAGIC_STRING)
		       {
			 $value_prefix = "&";
			 $magic{"test"} = $EFSD_MAGIC_TEST_EQUAL;
		       }
		     else
		       {
			 $magic{"test"} = $EFSD_MAGIC_TEST_MASK;
		       }
		   }
		 elsif ($item eq "^")
		   {
		     if ($magic{"type"} == $EFSD_MAGIC_STRING)
		       {
			 $value_prefix = "^";
			 $magic{"test"} = $EFSD_MAGIC_TEST_EQUAL;
		       }
		     else
		       {
			 $magic{"test"} = $EFSD_MAGIC_TEST_NOTMASK;
		       }
		   }
		 elsif ($item eq "!")
		   {
		     if ($magic{"type"} == $EFSD_MAGIC_STRING)
		       {
			 $value_prefix = "!";
			 $magic{"test"} = $EFSD_MAGIC_TEST_EQUAL;
		       }
		     else
		       {
			 $magic{"test"} = $EFSD_MAGIC_TEST_NOTEQUAL;
		       }
		   }
		 else
		   {
		     if ($7 eq ".")
		       {
			 $magic{"test"} = $EFSD_MAGIC_TEST_SUBST;
		       }
		     else
		       {
			 $magic{"test"} = $EFSD_MAGIC_TEST_EQUAL;
		       }
		   }
	       }
	     else
	       {
		 $magic{"test"} = $EFSD_MAGIC_TEST_EQUAL;
	       }

	     # Write value:
	     $item = $7;
	     if ($item eq ".")
	       {
		 $magic{"value"} = $item;
	       }
	     elsif ($magic{"type"} == $EFSD_MAGIC_STRING)
	       {		 
		 if ($item eq "\"\"")
		   {
		     $item = "";
		   }

		 $item =~ s/\\$/\\ /;    # replace a backslash at the end with "\ ".
		 $magic{"value"} = $value_prefix . $item;
	       }
	     else
	       {
		 $magic{"value"} = to_dec($item);
	       }

	     # Write description:

	     # Let's make a bunch of passes on the comment to get
	     # rid of all kind of weird formatting stuff.

	     $item = $8;

	     #$item =~ s/%.//g;           # get rid of print formatters
	     $item =~ s/\\.//g;            # get rid of anything escaped
	     $item =~ s/[^\+\-\/\w%\.]/-/g;  # replace anything non-alpha, not "/" and not print formatter with dashes
	     $item =~ s/-+/-/g;            # replace multiple dashes with single one.
	     $item =~ s/^(-+)//;           # remove any dashes at beginning
	     $item =~ s/(-+)$//;           # remove any dashes at end
	     $item = lc($item);

	     if (length($item) > 0)
	       {
		 $item = $item . "/";
	       }

	     $item =~ s/-+/-/g;
	     $item =~ s/\/+/\//g;
	     $magic{"filetype"} = $item;

	     write_magic(\@indices, $level, \%magic);
	     $num_tests++;
	     if (($num_tests % 100) == 0)
	       {
		 print ".";
	       }

	   }
	 else
	   {
	     print "Dropped line: $line";
	     $dropped_level = $level;
	   } 
	}
     }

  e_db_command_add_remaining();

  print "\n" . $num_tests . " tests written to db.\n";
}


# MAIN PROGRAM
#___________________________________________________________________________


if (@ARGV < 2)
  {
    print "USAGE: $0 <magic file> <db file>.\n";
    exit;
  }

$magic_file = shift(@ARGV);
$db_file = shift(@ARGV);

do_it();
