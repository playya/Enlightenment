/** 
@file
@brief Entrance/Entranced JeopardE will change the title :)
 
*/

/**

@mainpage Entrance Developers and Themers Documentation
@image html entrance.png
@version 1.0.0
@author Ibukun Olumuyiwa <ibukun@computer.org>
@author Corey Donohoe <atmos@atmos.org>
@date 2003










@section intro What is Entrance?
Entrance <I>[en-'trans]</I>, v.<BR>
1 : to carry away with delight, wonder, or rapture<BR>
2 : to put into a trance<BR>

Entrance is the Enlightenment Display Manager. And like Enlightenment,
it takes beauty and customization to levels that KDM and GDM can only
dream about, without the bloat.  It allows users to log in and out of
the different Xsession types available on the system. 


@section requirements What does Entrance require?

The only distribution we're currently aware of supporting Entrance is <A
HREF="http://www.gentoo.org/">Gentoo</A>.  You can compile it from cvs
using the following libraries if you're brave.

Entrance relies on a lot of libraries most notably
  - Edb (library)
  - Evas (library)
  - Edje (library)
  - Esmart (library)
  - Ecore (library)
  - Ecore_Evas (library)

There is no need to reinvent the wheel all the time.

@verbatim
1. You need Edb from cvs

  cvs co e17/libs/edb
  cd e17/libs/edb
  ./autogen.sh
  ./configure
  make
  sudo make install
  cd

2. You need Evas from cvs

  cvs co e17/libs/evas
  cd e17/libs/evas
  ./autogen.sh
  ./configure \
  --enable-software-x11 \
  --enable-gl-x11 \
  --enable-image-loader-png \
  --enable-image-loader-jpeg \
  --enable-image-loader-eet \
  --enable-cpu-c \
  --enable-cpu-mmx \
  --enable-cpu-p2-only \
  --enable-scale-smooth \
  --enable-scale-sample \
  --enable-convert-8-rgb-332 \
  --enable-convert-8-rgb-666 \
  --enable-convert-8-rgb-232 \
  --enable-convert-8-rgb-222 \
  --enable-convert-8-rgb-221 \
  --enable-convert-8-rgb-121 \
  --enable-convert-8-rgb-111 \
  --enable-convert-16-rgb-565 \
  --enable-convert-16-rgb-555 \
  --enable-convert-16-rgb-rot-0 \
  --enable-convert-16-rgb-rot-90 \
  --enable-convert-16-rgb-rot-270 \
  --enable-convert-32-rgb-8888 \
  --enable-convert-32-rgbx-8888 \
  --enable-convert-32-bgr-8888 \
  --enable-convert-32-bgrx-8888 \
  --enable-convert-32-rgb-rot-0 \
  --enable-convert-32-rgb-rot-90 \
  --enable-convert-32-rgb-rot-270
  make
  sudo make install
  cd
  
3. You need Ecore from cvs

  cvs co e17/libs/ecore
  cd e17/libs/ecore
  ./autogen.sh
  ./configure \
  --enable-ecore-x \
  --enable-ecore-evas \
  --enable-ecore-evas-gl \
  --enable-ecore-job \
  --enable-ecore-con \
  --enable-ecore-ipc
  make
  sudo make install
  cd

4. You need Edje from cvs

  cvs co e17/libs/edje
  cd e17/libs/edje
  ./autogen.sh
  make
  sudo make install
  cd

5. You need Esmart from cvs

  cvs co e17/proto/esmart
  cd e17/proto/esmart
  ./autogen.sh
  make
  sudo make install
  cd

7. You need entice from cvs

  cvs co e17/apps/entrance
  cd e17/apps/entrance
  ./autogen.sh
  make
  sudo make install
  cd

@endverbatim


@section example1 Example One 
You'll need to get comfortable with Edje.  This is not an intro to Edje,
perhaps you'll need to look at examples, or possibly
http://www.cuddletech.com/edje/ but if you don't get Edje, sorry come
back later.  That being said, let's get a barebones entrance theme up
and running.  

@verbatim
$ cd
$ mkdir mytheme
$ cd mytheme
$ mkdir images
$ vim cg
# cg contains the following info
#!/bin/sh -e
if [ -f ./mytheme.eet ]; then
    rm -f mytheme.eet
fi
edje_cc -v -id ./image mytheme.edc mytheme.eet
if [ -f ./mytheme.eet ]; then
    edje mytheme.eet
fi
$ chmod +x cg
$ vim mytheme.edc # your favorite editor will suffice here
// This is the contents of your basic theme.
images { }
collections {
    group {
	name, "Main";
	parts {
	    part {
		name, "bg";
		type, RECT;
		mouse_events, 0;
		description {
		    state, "default" 0.0;
		    visible, 1;
		    rel1 { 
			relative, 0.0 0.0;
			offset, 0 0;
		    } rel2 {
			relative, 1.0 1.0;
			offset, 0 0;
		    }
		    color, 0 0 0 255;
		}
	    }
	    part {
		name, "EntranceUserEntry";
		type, TEXT;
		mouse_events, 0;
		description {
		    state, "default" 0.0;
		    rel1 { 
			relative, 0.5 1.0;
			offset, -100 -71;
			to, "bg";
		    } rel2 {
			relative, 0.5 1.0;
			offset, 100 -36;
			to, "bg";
		    }
		    color, 255 255 255 255;
		    text {
			text, "";
			font, "Vera";
			size, 20;
			fit, 0 0;
			align, 0.5 0.5;
		    }
		}
	    }
	    part {
		name, "EntrancePassEntry";
		type, TEXT;
		mouse_events, 0;
		description {
		    state, "default" 0.0;
		    visible, 1;
		    rel1 { 
			relative, 0.5 1.0;
			offset, -100 -35;
			to, "bg";
		    } rel2 {
			relative, 0.5 1.0;
			offset, 100 -5;
			to, "bg";
		    }
		    color, 255 255 255 255;
		    text {
			text, "";
			font, "Vera";
			size, 20;
			fit, 0 0;
			align, 0.5 0.5;
		    }
		}
	    }
	}
	programs {
	    program {
		name, "authed";
		signal, "EntranceUserAuthSuccess";
		source, "";
		action, SIGNAL_EMIT "EntranceUserAuthSuccessDone" "";
	    }
	}
    }
}
@endverbatim

If everything worked ok, you should get something like <A
HREF="Example1.jpg">Example1</A>.  So what's worth taking notice of? 
The group "Main" is what entrance loads and fills the screen with.<BR>
<B>Edje Parts</B><UL>
<LI><B>EntranceUserEntry:</B> is a text part, this is where keyboard
input goes if the system is in a state accepting username
input.<B>REQUIRED</B>
<LI> <B>EntrancePassEntry:</B> is a text part, this is where keyboard
input goes if the system is in a state accepting the user's
password.<B>REQUIRED</B>
</UL>
<B>Edje Signals</B><UL>
<LI><B>EntranceUserAuthSuccess:</B> Entrance emits this signal when the
user successfully authenticates.  A program must always exist in your
theme that catches this signal.  The idea behind this is that you can
have neat effects after the user successfully logs in.  
<LI><B>EntranceUserAuthSuccessDone:</B> It's the themer's job to let
Entrance know that it's done and the user's session should start by
emitting this signal.
</UL>

@section example2 Example Two
You're probably thinking that Example 1 was really lame, and
contemplating skipping Example Two because it's just too basic, but bare
with me.  Example Two shows off a few of the built in features that
themers can take advantage of.  This is where your creativity steps in,
presenting these builtins in a pleasing manner.  You can see a preview
of it <A HREF="Example2.jpg">here</A>. Notice it's still not the
prettiest thing, but it was made without specifying a single image file.
:)

@verbatim
$ cd
$ mkdir mysecondtheme
$ cd mysecondtheme
$ mkdir images
$ vim cg
# cg contains the following info
#!/bin/sh -e
if [ -f ./mysecondtheme.eet ]; then
    rm -f mysecondtheme.eet
fi
edje_cc -v -id ./image mysecondtheme.edc mysecondtheme.eet
if [ -f ./mysecondtheme.eet ]; then
    edje mysecondtheme.eet
fi
$ chmod +x cg
$ vim mysecondtheme.edc # your favorite editor will suffice here
images { }
collections {
    group {
	name, "Main";
	parts {
	    part {
		name, "bg";
		type, RECT;
		mouse_events, 0;
		description {
		    state, "default" 0.0;
		    visible, 1;
		    rel1 { 
			relative, 0.0 0.0;
			offset, 0 0;
		    } rel2 {
			relative, 1.0 1.0;
			offset, 0 0;
		    }
		    color, 0 0 0 255;
		}
	    }
	    part {
		name, "BottomBar";
		type, RECT;
		mouse_events, 1;
		description {
		    state, "default" 0.0;
		    visible, 1;
		    rel1 {
			relative, 0.0 1.0;
			offset, 0 -50;
		    } rel2 {
			relative, 1.0 1.0;
			offset, 0 0;
		    }
		    color, 100 100 100 96;
		}
	    }
	    part {
		name, "EntranceUserEntry";
		type, TEXT;
		mouse_events, 0;
		description {
		    state, "default" 0.0;
		    rel1 { 
			relative, 0.5 1.0;
			offset, -100 -71;
			to, "bg";
		    } rel2 {
			relative, 0.5 1.0;
			offset, 100 -36;
			to, "bg";
		    }
		    color, 255 255 255 255;
		    text {
			text, "";
			font, "Vera";
			size, 20;
			fit, 0 0;
			align, 0.5 0.5;
		    }
		}
	    }
	    part {
		name, "EntrancePassEntry";
		type, TEXT;
		mouse_events, 0;
		description {
		    state, "default" 0.0;
		    visible, 1;
		    rel1 { 
			relative, 0.5 1.0;
			offset, -100 -35;
			to, "bg";
		    } rel2 {
			relative, 0.5 1.0;
			offset, 100 -5;
			to, "bg";
		    }
		    color, 255 255 255 255;
		    text {
			text, "";
			font, "Vera";
			size, 20;
			fit, 0 0;
			align, 0.5 0.5;
		    }
		}
	    }
	    part {
		name, "EntranceHostname";
		type, TEXT;
		mouse_events, 0;
		description {
		    state, "default" 0.0;
		    visible, 1;
		    rel1 { 
			relative, 0.5 0.0;
			offset, -200 -35;
			to, "EntranceUserEntry";
		    } rel2 {
			relative, 0.5 0.0;
			offset, 200 -5;
			to, "EntranceUserEntry";
		    }
		    color, 255 255 255 255;
		    text {
			text, "";
			font, "Vera";
			size, 20;
			fit, 0 0;
			align, 0.5 0.5;
		    }
		}
	    }
	    part {
		name, "EntranceDate";
		type, TEXT;
		mouse_events, 0;
		description {
		    state, "default" 0.0;
		    visible, 1;
		    rel1 { 
			relative, 1.0 1.0;
			offset, -300 -25;
			to, "bg";
		    } rel2 {
			relative, 1.0 1.0;
			offset, -10 -10;
			to, "bg";
		    }
		    color, 255 255 255 255;
		    text {
			text, "";
			font, "Vera";
			size, 10;
			fit, 0 0;
			align, 1.0 0.5;
		    }
		}
	    }
	    part {
		name, "EntranceTime";
		type, TEXT;
		mouse_events, 0;
		description {
		    state, "default" 0.0;
		    visible, 1;
		    rel1 { 
			relative, 1.0 1.0;
			offset, -300 -40;
			to, "bg";
		    } rel2 {
			relative, 1.0 1.0;
			offset, -10 -25;
			to, "bg";
		    }
		    color, 255 255 255 255;
		    text {
			text, "";
			font, "Vera";
			size, 10;
			fit, 0 0;
			align, 1.0 0.5;
		    }
		}
	    }
	    part {
		name, "EntranceError";
		type, TEXT;
		mouse_events, 0;
#define ERROR(sname, sdescription) \
description { state, sname 0.0; visible, 1; \
rel1 { relative, 0.0 1.0; offset, 5 -35; to, "bg"; }  \
rel2 { relative, 1.0 1.0; offset, -5 -5; to, "bg"; } \
color, 255 255 255 255; \
text { text, sdescription; \
font, "Vera"; size, 20; fit, 0 0; align, 1.0 0.5; } }
		ERROR("default", "");
		ERROR("userfail", "Unknown User");
		ERROR("passfail", "Authentication Failed");
	    }
	    part {
		name, "EntranceSessionList";
		type, RECT;
		mouse_events, 1;
		dragable {
		    x, 1 1 0;
		    y, 1 1 0;
		}
		description {
		    state, "default" 0.0;
		    visible, 1;
		    rel1 {
			relative, 1.0 0.5;
			offset, -205 -180;
		    } rel2 {
			relative, 1.0 0.5;
			offset, -25 180;
		    }
		    color, 255 255 255 64;
		}
	    }
	    part {
		name, "SessionLabel";
		type, TEXT;
		mouse_events, 0;
		effect, SOFT_SHADOW;
		description {
		    state, "default" 0.0;
		    visible, 1;
		    rel1 { 
			relative, 0.0 0.0;
			offset, 0 -30;
			to, "EntranceSessionList";
		    } rel2 {
			relative, 1.0 0.0;
			offset, 0 -5;
			to, "EntranceSessionList";
		    }
		    color, 255 255 255 255;
		    color3, 0 0 0 192;
		    text {
			text, "Sessions";
			font, "Vera";
			size, 10;
			fit, 0 0;
			align, 0.5 0.5;
		    }
		}
	    }
	    part {
		name, "EntranceUserList";
		type, RECT;
		mouse_events, 1;
		dragable {
		    x, 1 1 0;
		    y, 1 1 0;
		}
		description {
		    state, "default" 0.0;
		    visible, 1;
		    rel1 {
			relative, 0.0 0.25;
			offset, 100 -25;
		    } rel2 {
			relative, 0.0 0.25;
			offset, 210 25;
		    }
		    color, 255 255 255 64;
		}
	    }
	    part {
		name, "UsersLabel";
		type, TEXT;
		mouse_events, 0;
		effect, SOFT_SHADOW;
		description {
		    state, "default" 0.0;
		    visible, 1;
		    rel1 { 
			relative, 0.0 0.0;
			offset, 0 -30;
			to, "EntranceUserList";
		    } rel2 {
			relative, 1.0 0.0;
			offset, 0 -5;
			to, "EntranceUserList";
		    }
		    color, 255 255 255 255;
		    color3, 0 0 0 192;
		    text {
			text, "Users";
			font, "Vera";
			size, 10;
			fit, 0 0;
			align, 0.5 0.5;
		    }
		}
	    }
	    part {
		name, "EntranceFace";
		type, RECT;
		mouse_events, 1;
		description {
		    state, "default" 0.0;
		    visible, 1;
		    rel1 {
			relative, 0.0 0.5;
			offset, 100 -50;
		    } rel2 {
			relative, 0.0 0.5;
			offset, 300 50;
		    }
		    color, 100 100 100 0;
		}
	    }
	    part {
		name, "EntranceSession";
		type, RECT;
		mouse_events, 1;
		description {
		    state, "default" 0.0;
		    visible, 1;
		    rel1 {
			relative, 0.0 1.0;
			offset, 0 -45;
		    } rel2 {
			relative, 0.0 1.0;
			offset, 200 -5;
		    }
		    color, 100 100 100 0;
		}
	    }
	}
	programs {
	    program {
		name, "authed";
		signal, "EntranceUserAuthSuccess";
		source, "";
		action, SIGNAL_EMIT "EntranceUserAuthSuccessDone" "";
	    }
	    program {
		name, "errorreset";
		signal, "";
		source, "";
		action, STATE_SET "default" 0.0;
		target, "EntranceError";
		in, 2.0 0.0;
	    }
#define ERROR_PROGRAM(pstate, psignal) \
program { name, pstate; signal, psignal; source, ""; \
action, STATE_SET pstate 0.0; target, "EntranceError"; \
after, "errorreset"; }
	    ERROR_PROGRAM("userfail", "EntranceUserFail");
	    ERROR_PROGRAM("passfail", "EntranceUserAuthFail");
	}
    }
    group
    {
	name, "Session";
	parts
	{
	    part
	    {
		name, "EntranceSessionIcon";
		type, RECT;
		mouse_events, 1;
		description
		{
		    state, "default" 0.0;
		    visible, 1;
		    rel1
		    {
			relative, 0.0 0.0;
			offset, 2 2;
		    }
		    rel2
		    {
			relative, 0.0 0.0;
			offset, 34 34;
		    }
		    color, 255 255 255 0;
		}
	    }
	    part
	    {
		name, "EntranceSessionTitle";
		type, TEXT;
		mouse_events, 1;
		effect, SOFT_SHADOW;
		description
		{
		    state, "default" 0.0;
		    visible, 1;
		    rel1
		    {
			relative, 1.0 0.5;
			offset, 2 -17;
			to, "EntranceSessionIcon";
		    }
		    rel2
		    {
			relative, 1.0 0.5;
			offset, 150 17;
			to, "EntranceSessionIcon";
		    }
		    color, 100 100 100 192;
		    color3, 255 255 255 255;
		    text
		    {
			text, "Doesn't Matter";
			font, "Vera";
			size, 13;
			align, 0.0 0.5;
			fit, 0 0;
		    }
		}
	    }
	}
	programs
	{
	    program
	    {
		name, "SessionIconClicked";
		signal, "mouse,clicked,1";
		source, "EntranceSessionIcon";
		action, SIGNAL_EMIT "SessionSelected" "";
	    }
	    program
	    {
		name, "SessionTitleClicked";
		signal, "mouse,clicked,1";
		source, "EntranceSessionTitle";
		action, SIGNAL_EMIT "SessionSelected" "";
	    }
	}
    }
}
@endverbatim
<B>Oy!</B> That's a lot!  Most notably Example2 has a second Edje group
defined,"Session".<BR><P>Entrance will use the "Session" group as
a template and fill in the different parts with system specific session
information.<BR>
<B>Edje Parts</B><UL> 
<LI><B>EntranceSessionTitle</B>, Is a text part, the text will be set by
the system to the appropriate session's name.
<LI><B>EntranceSessionIcon</B>.  Is a rect part, the icon is swallowed
into this area if present.
</UL>
<B>Edje Signals</B><UL> 
<LI><B>SessionSelected:</B> Your "Session" edje emits this signal when
it requests entrance to accept it as the new chosen session.
<LI><B>SessionUnSelected:</B> Your "Session" edje emits this signal when
it requests Entrance to deselect it as the current x session.
</UL>
<P>Now lets focus our attention back to the "Main" group.  <BR>
<B>Edje Parts</B><UL>
<LI><B>EntranceHostname:</B> EntranceHostname is a text part that will
be filled with the greeting specified in the system configuration.
<LI><B>EntranceTime:</B> EntranceTime is a text part that will be filled
with the current time every second.  The time format is specified in the
system configuration.  If this part is present, it'll display the right
time :)
<LI><B>EntranceDate:</B> EntranceDate is a text part that will be filled
with the current date.  The format for the date is specified in the
system configuration file.
<LI><B>EntranceSession:</B> EntranceSession is a rect part that will
swallow the currently selected session.  If this part is present, an
instance of the "Session" group will be swallow to this rectangle.
<LI><B>EntranceFace:</B> EntranceFace is a rect part that will swallow
the currently selected user icon.  If this part is present a unique
edje specific to that user will be displayed in that region.
<LI><B>EntranceSessionList</B> EntranceSessionList is a rect part that
will swallow a list of "Session" group edjes.  The sessions available on
each system may vary, Entrance will properly pack all the available
xsessions into this area that the system configuration specifies.  
<LI><B>EntranceUserList</B> EntranceUserList is a rect part that will
swallow a list of users the system knows about.  The themer need only
define the area they should be swallowed into, Entrance will handle
adding them.
</UL>
<B>Edje Signals</B><UL>
<LI><B>EntranceUserFail:</B> Emitted if the username entered in
EntranceUserEntry is unknown to the system.
signal.
<LI><B>EntranceUserAuthFail:</B> Emitted if the password entered in the
EntrancePassEntry fails to authenticate with the system.
</UL>

@todo Theme edc walkthrough

*/
