Index: Doxyfile
===================================================================
RCS file: /cvs/e/e17/libs/edje/Doxyfile,v
retrieving revision 1.4
diff -u -r1.4 Doxyfile
--- Doxyfile	6 Dec 2007 23:40:48 -0000	1.4
+++ Doxyfile	16 Feb 2008 16:53:14 -0000
@@ -1,7 +1,7 @@
 PROJECT_NAME           = Edje
 PROJECT_NUMBER         =
 OUTPUT_DIRECTORY       = doc
-INPUT                  = edje.c ./src/bin/edje_cc_handlers.c
+INPUT                  = edje.c ./src/bin/edje_cc_handlers.c ./src/lib/Edje_Edit.h
 IMAGE_PATH             = doc/img
 OUTPUT_LANGUAGE        = English
 GENERATE_HTML          = YES
@@ -41,7 +41,7 @@
 SHOW_INCLUDE_FILES     = NO
 JAVADOC_AUTOBRIEF      = YES
 MULTILINE_CPP_IS_BRIEF = NO
-DETAILS_AT_TOP         = NO
+DETAILS_AT_TOP         = YES
 INHERIT_DOCS           = YES
 INLINE_INFO            = YES
 SORT_MEMBER_DOCS       = YES
Index: configure.in
===================================================================
RCS file: /cvs/e/e17/libs/edje/configure.in,v
retrieving revision 1.93
diff -u -r1.93 configure.in
--- configure.in	25 Jan 2008 03:35:46 -0000	1.93
+++ configure.in	16 Feb 2008 16:53:14 -0000
@@ -66,6 +66,7 @@
   evas >= 0.9.9
   ecore-evas >= 0.9.9
   ecore-job >= 0.9.9
+  ecore-file >= 0.9.9
   eet >= 0.9.10
   embryo >= 0.9.1
 ])
Index: gendoc
===================================================================
RCS file: /cvs/e/e17/libs/edje/gendoc,v
retrieving revision 1.6
diff -u -r1.6 gendoc
--- gendoc	6 Dec 2007 23:42:38 -0000	1.6
+++ gendoc	16 Feb 2008 16:53:14 -0000
@@ -1,7 +1,7 @@
 #!/bin/sh
 cp ./edje.c.in ./edje.c
 cat ./src/lib/Edje.h >> ./edje.c
-for I in `find ./src/lib -name "*.c" -print`; do
+for I in `find ./src/lib -name "*.c" -print | grep -v edje_edit.c`; do
   cat $I >> ./edje.c
 done
 rm -rf ./doc/html ./doc/latex ./doc/man
@@ -9,6 +9,8 @@
 doxygen
 cp doc/img/*.png doc/html/
 cp doc/img/*.gif doc/html/
+cp doc/img/*.jpg doc/html/
+cp doc/*.css doc/html/
 rm -f edje_docs.tar edje_docs.tar.gz
 tar -cvf edje_docs.tar doc/html doc/man doc/latex
 gzip -9 edje_docs.tar
Index: src/lib/Edje_Edit.h
===================================================================
RCS file: src/lib/Edje_Edit.h
diff -N src/lib/Edje_Edit.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/lib/Edje_Edit.h	16 Feb 2008 16:53:14 -0000
@@ -0,0 +1,1090 @@
+#ifndef _EDJE_EDIT_H
+#define _EDJE_EDIT_H
+
+#include <Evas.h>
+
+#ifdef EAPI
+#undef EAPI
+#endif
+#ifdef _MSC_VER
+# ifdef BUILDING_DLL
+#  define EAPI __declspec(dllexport)
+# else
+#  define EAPI __declspec(dllimport)
+# endif
+#else
+# ifdef __GNUC__
+#  if __GNUC__ >= 4
+#   define EAPI __attribute__ ((visibility("default")))
+#  else
+#   define EAPI
+#  endif
+# else
+#  define EAPI
+# endif
+#endif
+
+/** 
+ * @file
+ * @brief Functions to deal with edje internal object. Don't use in standard 
+ * situations. The use of any of the edje_edit_* functions can break your 
+ * theme ability, remember that the program must be separated from the interface!
+ *
+ * The API can be used to query or set every part of an edje object in real time.
+ * You can manage every aspect of parts, part states, programs, script and whatever
+ * is contained in the edje file. For a reference of what all parameter means 
+ * look at the complete @ref edcref.
+ * 
+ * All the functions that deals with part states include the state value inside
+ * the returned strings (ex: "defaut 0.00"). For this reason there aren't
+ * functions to set/get a state value, you have to pass the value inside the 
+ * name string (always in the form "state x.xx").
+ *
+ * Don't forget to free all the strings and the lists returned by any edje_edit_*()
+ * functions using edje_edit_string_free() and edje_edit_string_list_free() when
+ * you don't need anymore.
+ * 
+ * Example: print all the part in a loaded edje_object
+ * @code
+ *  Evas_List *parts, *l;
+ *  
+ *  parts = edje_edit_parts_list_get(edje_object);
+ *  while(l = parts; l; l = l->next)
+ *  {
+ *     printf("Part: %s\n", (char*)l->data);
+ *  }
+ *  edje_edit_string_list_free(parts);
+ * @endcode
+ *
+ * Example: Change the color of a rect inside an edje file
+ * @code
+ * Evas_Object *edje;
+ * 
+ * edje = edje_object_add(evas);
+ * edje_object_file_set(edje,"edj/file/name", "group to load");
+ * edje_edit_state_color_set(edje, "MyRectName", "default 0.00", 255, 255, 0, 255);
+ * edje_edit_save(edje);
+ * @endcode
+ *
+*/
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************/
+/**************************   GENERAL API   ***********************************/
+/******************************************************************************/
+/** @name General API
+ *  General functions that don't fit in other cateories.
+ */ //@{
+
+/** Free a generic Evas_List of (char *) allocated by an edje_edit_*_get() function.*/
+EAPI void
+edje_edit_string_list_free(
+   Evas_List *lst          ///< The list to free. Will also free all the strings.
+);
+
+/** Free a generic string (char *) allocated by an edje_edit_*_get() function.*/
+EAPI void
+edje_edit_string_free(
+   const char *str         ///< The string to free.
+);
+
+/**Save the modified edje object back to his file.
+ * Use this function when you are done with your editing, all the change made 
+ * to the current loaded group will be saved back to the original file.
+ *
+ * NOTE: for now this as 2 limitations
+ *    -the saved edje file cannot be decompiled anymore
+ *    -you will lost your #define in the edc source
+ */
+EAPI int                   ///@return 1 on success, 0 on failure
+edje_edit_save(
+   Evas_Object *obj        ///< The edje object to save
+);
+
+//@}
+/******************************************************************************/
+/**************************   GROUPS API   ************************************/
+/******************************************************************************/
+/** @name Groups API
+ *  Functions to deal with groups property (see @ref edcref).
+ */ //@{
+
+/**Create a new empty group in the given edje.
+ * If a group with the same name exist none is created.
+ */
+EAPI unsigned char         ///@return 1 on success, 0 on failure
+edje_edit_group_add(
+   Evas_Object *obj,       ///< The edje object
+   const char  *name       ///< The name for the new empty group
+);
+
+/**Delete the current group from the given edje.
+ * You can only delete the currently loaded group.
+ * All the parts and the programs inside the group will be deleted as well, 
+ * but not image or font embedded in the edje.
+ */
+EAPI unsigned char         ///@return 1 on success, 0 on failure
+edje_edit_group_del(
+   Evas_Object *obj        ///< The edje object
+);
+   
+/**Set a new name for the current open group.
+ * You can only rename a group that is currently loaded
+ * Note that the relative getter function don't exist as it don't make sense ;)
+ */
+EAPI void
+edje_edit_group_name_set(
+   Evas_Object *obj,       ///< The edje object
+   const char  *new_name   ///< The new name for the group
+);
+   
+/**Set the group min width*/
+EAPI void
+edje_edit_group_min_w_set(
+   Evas_Object *obj,       ///< The edje object
+   int w                   ///< The new group minimum width in pixel
+);
+/**Set the group min height*/
+EAPI void
+edje_edit_group_min_h_set(
+   Evas_Object *obj,       ///< The edje object
+   int h                   ///< The new group minimum height in pixel
+);
+/**Set the group max width*/
+EAPI void
+edje_edit_group_max_w_set(
+   Evas_Object *obj,       ///< The edje object
+   int w                   ///< The new group maximum width in pixel
+);
+/**Set the group max height*/
+EAPI void
+edje_edit_group_max_h_set(
+   Evas_Object *obj,       ///< The edje object
+   int h                   ///< The new group maximum height in pixel
+);
+
+//@}
+/******************************************************************************/
+/**************************   PARTS API   *************************************/
+/******************************************************************************/
+/** @name Parts API
+ *  Functions to deal with part objects (see @ref edcref).
+ */ //@{
+
+/**Get the list of all the parts in the given edje object.
+ * Use edje_edit_string_list_free() when you don't need it anymore.
+ */
+EAPI Evas_List *           ///@return An Evas_List* of string (char *)containing all the part names.
+edje_edit_parts_list_get(
+   Evas_Object *obj        ///< The edje object
+);
+
+/**Create a new part in the given edje
+ * If another part with the same name just exists nothing is created and FALSE is returned.
+ * Note that this function also create a default description for the part.
+ */
+EAPI unsigned char         ///@return TRUE on success, FALSE if the part can't be created
+edje_edit_part_add(
+   Evas_Object *obj,       ///< The edje object
+   const char *name,       ///< The name for the new part
+   unsigned char type      ///< The type of the part to create (One of: EDJE_PART_TYPE_NONE, EDJE_PART_TYPE_RECTANGLE, EDJE_PART_TYPE_TEXT,EDJE_PART_TYPE_IMAGE, EDJE_PART_TYPE_SWALLOW, EDJE_PART_TYPE_TEXTBLOCK,EDJE_PART_TYPE_GRADIENT or EDJE_PART_TYPE_GROUP)
+);
+
+/**Delete the given part from the edje
+ * All the reference to this part will be zeroed.
+ * A group must have at least one part, so it's not possible to 
+ * remove the last remaining part.
+ */
+EAPI unsigned char         ///@return TRUE on success, FALSE if the part can't be removed
+edje_edit_part_del(
+   Evas_Object *obj,       ///< The edje object
+   const char *part        ///< The name of the part to remove
+);
+   
+/**Set a new name for part.
+ * Note that the relative getter function don't exist as it don't make sense ;)
+ */
+EAPI void
+edje_edit_part_name_set(
+   Evas_Object *obj,       ///< The edje object
+   const char  *part,      ///< The name of the part to rename
+   const char  *new_name   ///< The new name for the part
+);
+
+/**Get the type of a part */
+EAPI unsigned char         ///@return One of: EDJE_PART_TYPE_NONE, EDJE_PART_TYPE_RECTANGLE, EDJE_PART_TYPE_TEXT,EDJE_PART_TYPE_IMAGE, EDJE_PART_TYPE_SWALLOW, EDJE_PART_TYPE_TEXTBLOCK,EDJE_PART_TYPE_GRADIENT or EDJE_PART_TYPE_GROUP
+edje_edit_part_type_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part        ///< The name of the part
+);
+
+/**Get the effect for a given part. */
+EAPI unsigned char         ///@return One of: EDJE_TEXT_EFFECT_NONE, _PLAIN, _OUTLINE, _SOFT_OUTLINE, _SHADOW, _SOFT_SHADOW, _OUTLINE_SHADOW, _OUTLINE_SOFT_SHADOW, _FAR_SHADOW, _FAR_SOFT_SHADOW, _GLOW.
+edje_edit_part_effect_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part        ///< The name of the part
+);
+/**Set the effect for a given part. */
+EAPI void
+edje_edit_part_effect_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   unsigned char effect    ///< The effect to set. See edje_edit_part_effect_get() for possible value
+);
+
+/**Get the current selected state in part. */
+EAPI const char *          ///@return The name of the selected state including the float value. Use edje_edit_string_free() when you don't need it anymore.
+edje_edit_part_selected_state_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part        ///< The name of the part
+);
+
+/**Set the current state in part.*/
+EAPI unsigned char         ///@return 1 on success, 0 otherwise.
+edje_edit_part_selected_state_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the state to set (including the float value)
+);
+
+/**Get mouse_events for part.*/
+EAPI unsigned char         ///@return 1 if part accept mouse events, 0 if not
+edje_edit_part_mouse_events_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part        ///< The name of the part
+);
+
+/**Set mouse_events for part.*/
+EAPI void                  
+edje_edit_part_mouse_events_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   unsigned char mouse_events ///< If set to 1 part will accept mouse events, 0 to ignore all mouse events from part.
+);
+  
+/**Get repeat_events for part.*/
+EAPI unsigned char         ///@return 1 if part will pass all events to the other parts, 0 if not
+edje_edit_part_repeat_events_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part        ///< The name of the part
+);
+
+/**Set repeat_events for part. */
+EAPI void
+edje_edit_part_repeat_events_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   unsigned char repeat_events /**< If set to 1 part will repeat 
+                                 * all the received mouse events to other parts.
+                                 * If set to 0 the events received will not propagate to other parts.*/
+);
+
+//@}
+/******************************************************************************/
+/**************************   STATES API   ************************************/
+/******************************************************************************/
+/** @name States API
+ *  Description of gen api 2. 
+ */ //@{
+
+/**Get the list of all the states in the given part.*/
+EAPI Evas_List *           /**@return An Evas_List* of string (char *)containing all the states names found 
+                            * in part, including the float value (ex: "default 0.00").
+                            * Use edje_edit_string_list_free() when you don't need it anymore. */
+edje_edit_part_states_list_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part        ///< The name of the part
+);
+
+/**Set a new name for the given state in the given part.
+ * Note that state and new_name must include the floating value inside the string (ex. "default 0.00")
+ */
+EAPI int
+edje_edit_state_name_set(
+   Evas_Object *obj,       ///< The edje object 
+   const char *part,       ///< The name of the part that contain state
+   const char *state,      ///< The current name of the state
+   const char *new_name    ///< The new name to assign
+);
+
+/**Create a new state to the give part
+ */
+EAPI void
+edje_edit_state_add(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *name        ///< The name for the new state
+);
+
+/**Delete the given part state from the edje
+ */
+EAPI void
+edje_edit_state_del(
+   Evas_Object *obj,       ///< The edje object 
+   const char *part,       ///< The name of the part that contain state
+   const char *state       ///< The current name of the state
+);
+
+/**Get the rel1 relative x value of state*/
+EAPI double                ///@return The 'rel1 relative X' value of the part state
+edje_edit_state_rel1_relative_x_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the part state (ex. "default 0.00")
+);
+/**Get the rel1 relative y value of state*/
+EAPI double                ///@return The 'rel1 relative Y' value of the part state
+edje_edit_state_rel1_relative_y_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Get the rel2 relative x value of state*/
+EAPI double                ///@return The 'rel2 relative X' value of the part state
+edje_edit_state_rel2_relative_x_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Get the rel2 relative y value of state*/
+EAPI double                ///@return The 'rel2 relative Y' value of the part state
+edje_edit_state_rel2_relative_y_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+
+/**Set the rel1 relative x value of state*/
+EAPI void
+edje_edit_state_rel1_relative_x_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   double x                ///< The new 'rel1 relative X' value to set
+);
+/**Set the rel1 relative y value of state*/
+EAPI void
+edje_edit_state_rel1_relative_y_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   double y                ///< The new 'rel1 relative Y' value to set
+);
+/**Set the rel2 relative x value of state*/
+EAPI void
+edje_edit_state_rel2_relative_x_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   double x                ///< The new 'rel2 relative X' value to set
+);
+/**Set the rel2 relative y value of state*/
+EAPI void
+edje_edit_state_rel2_relative_y_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   double y                ///< The new 'rel2 relative Y' value to set
+);
+
+/**Get the rel1 offset x value of state*/
+EAPI int                   /// @return The 'rel1 offset X' value of the part state
+edje_edit_state_rel1_offset_x_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Get the rel1 offset y value of state*/
+EAPI int                   /// @return The 'rel1 offset Y' value of the part state
+edje_edit_state_rel1_offset_y_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Get the rel2 offset x value of state*/
+EAPI int                   /// @return The 'rel2 offset X' value of the part state
+edje_edit_state_rel2_offset_x_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Get the rel2 offset y value of state*/
+EAPI int                   /// @return The 'rel2 offset Y' value of the part state
+edje_edit_state_rel2_offset_y_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+   
+/**Set the rel1 offset x value of state*/
+EAPI void
+edje_edit_state_rel1_offset_x_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   double x                ///< The new 'rel1 offset X' value to set
+);
+/**Get the rel1 offset y value of state*/
+EAPI void
+edje_edit_state_rel1_offset_y_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   double y                ///< The new 'rel1 offset Y' value to set
+);
+/**Get the rel2 offset x value of state*/
+EAPI void
+edje_edit_state_rel2_offset_x_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   double x                ///< The new 'rel2 offset X' value to set
+);
+/**Get the rel2 offset y value of state*/
+EAPI void
+edje_edit_state_rel2_offset_y_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   double y                ///< The new 'rel2 offset Y' value to set
+); 
+
+/**Get the part name rel1x is relative to. The function return NULL if the part is relative to the whole interface.*/
+EAPI const char *          ///@return The name of the part to apply the relativity
+edje_edit_state_rel1_to_x_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Get the part name rel1y is relative to. The function return NULL if the part is relative to the whole interface.*/
+EAPI const char *          ///@return The name of the part to apply the relativity
+edje_edit_state_rel1_to_y_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Get the part name rel2x is relative to. The function return NULL if the part is relative to the whole interface.*/
+EAPI const char *         ///@return The name of the part to apply the relativity
+edje_edit_state_rel2_to_x_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Get the part name rel2y is relative to. The function return NULL if the part is relative to the whole interface.*/
+EAPI const char *         ///@return The name of the part to apply the relativity
+edje_edit_state_rel2_to_y_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+
+/**Set the part rel1x is relative to. Set rel_to to NULL make the part relative to the whole interface.*/
+EAPI void
+edje_edit_state_rel1_to_x_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   const char *rel_to      ///< The name of the part that is used as container/parent
+);
+/**Set the part rel1y is relative to. Set rel_to to NULL make the part relative to the whole interface.*/
+EAPI void
+edje_edit_state_rel1_to_y_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   const char *rel_to      ///< The name of the part that is used as container/parent
+);
+/**Set the part rel2x is relative to. Set rel_to to NULL make the part relative to the whole interface.*/
+EAPI void
+edje_edit_state_rel2_to_x_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   const char *rel_to      ///< The name of the part that is used as container/parent
+);
+/**Set the part rel2y is relative to. Set rel_to to NULL make the part relative to the whole interface.*/
+EAPI void
+edje_edit_state_rel2_to_y_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   const char *rel_to      ///< The name of the part that is used as container/parent
+);
+
+/**Get the color of a part state. Pass NULL to any of [r,g,b,a] to get only the others.*/
+EAPI void
+edje_edit_state_color_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   int *r,                 ///< A pointer to store the red value
+   int *g,                 ///< A pointer to store the green value
+   int *b,                 ///< A pointer to store the blue value
+   int *a                  ///< A pointer to store the alpha value
+);
+/**Get the color2 of a part state. Pass NULL to any of [r,g,b,a] to get only the others.*/
+EAPI void
+edje_edit_state_color2_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   int *r,                 ///< A pointer to store the red value
+   int *g,                 ///< A pointer to store the green value
+   int *b,                 ///< A pointer to store the blue value
+   int *a                  ///< A pointer to store the alpha value
+);
+/**Get the color3 of a part state. Pass NULL to any of [r,g,b,a] to get only the others.*/
+EAPI void
+edje_edit_state_color3_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   int *r,                 ///< A pointer to store the red value
+   int *g,                 ///< A pointer to store the green value
+   int *b,                 ///< A pointer to store the blue value
+   int *a                  ///< A pointer to store the alpha value
+);
+
+/**Set the color of a part state. Pass -1 to any of [r,g,b,a] to leave the value untouched.*/
+EAPI void
+edje_edit_state_color_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   int r,                  ///< The red value of the color
+   int g,                  ///< The green value of the color
+   int b,                  ///< The blue value of the color
+   int a                   ///< The alpha value of the color
+);
+/**Set the color2 of a part state. Pass -1 to any of [r,g,b,a] to leave the value untouched.*/
+EAPI void
+edje_edit_state_color2_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   int r,                  ///< The red value of the color
+   int g,                  ///< The green value of the color
+   int b,                  ///< The blue value of the color
+   int a                   ///< The alpha value of the color
+);
+/**Set the color3 of a part state. Pass -1 to any of [r,g,b,a] to leave the value untouched.*/
+EAPI void
+edje_edit_state_color3_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   int r,                  ///< The red value of the color
+   int g,                  ///< The green value of the color
+   int b,                  ///< The blue value of the color
+   int a                   ///< The alpha value of the color
+);
+
+/**Get the align_x value of a part state.*/
+EAPI double                ///@return The horizontal align value for the given state
+edje_edit_state_align_x_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Get the align_y value of a part state.*/
+EAPI double                ///@return The vertical align value for the given state
+edje_edit_state_align_y_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Set the align_x value of a part state.*/
+EAPI void
+edje_edit_state_align_x_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   double align            ///< The new horizontal align to set
+);
+/**Set the align_y value of a part state.*/
+EAPI void
+edje_edit_state_align_y_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   double align            ///< The new vertical align to set
+);
+/**Get the min_w value of a part state.*/
+EAPI int                   ///@return The minimum width of a part state
+edje_edit_state_min_w_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Set the min_w value of a part state.*/
+EAPI void
+edje_edit_state_min_w_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   int min_w               ///< The new minimum width to set for the part state
+);
+/**Get the min_h value of a part state.*/
+EAPI int                   ///@return The minimum height of a part state
+edje_edit_state_min_h_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Set the min_h value of a part state.*/
+EAPI void
+edje_edit_state_min_h_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   int min_h               ///< The new minimum height to set for the part state
+);
+
+/**Get the max_w value of a part state.*/
+EAPI int                   ///@return The maximum width of a part state
+edje_edit_state_max_w_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Set the max_w value of a part state.*/
+EAPI void
+edje_edit_state_max_w_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   int max_w               ///< The new maximum width to set for the part state
+);
+/**Get the max_h value of a part state.*/
+EAPI int                   ///@return The maximum height of a part state
+edje_edit_state_max_h_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Set the max_h value of a part state.*/
+EAPI void
+edje_edit_state_max_h_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   int max_h               ///< The new maximum height to set for the part state
+);
+
+/**Get the minimum aspect value of a part state.*/
+EAPI double                ///@return The aspect minimum value of a part state
+edje_edit_state_aspect_min_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Get the maximum aspect value of a part state.*/
+EAPI double                ///@return The aspect maximum value of a part state
+edje_edit_state_aspect_max_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Set the minimum aspect value of a part state.*/
+EAPI void
+edje_edit_state_aspect_min_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   double aspect           ///< The new minimum aspect value to set
+);
+/**Set the maximum aspect value of a part state.*/
+EAPI void
+edje_edit_state_aspect_max_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   double aspect           ///< The new maximum aspect value to set
+);
+/**Get the aspect preference value of a part state.*/
+EAPI unsigned char         ///@return The aspect preference (0=none, 1=vertical, 2=horizontal, 3=both)
+edje_edit_state_aspect_pref_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Set the aspect preference value of a part state.*/
+EAPI void
+edje_edit_state_aspect_pref_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   unsigned char pref      ///< The new aspect preference to set (0=none, 1=vertical, 2=horizontal, 3=both)
+);
+
+   
+//@}
+/******************************************************************************/
+/**************************   TEXT API   ************************************/
+/******************************************************************************/
+/** @name Text API
+ *  Description of gen api 2. 
+ */ //@{
+
+/**Get the text of a part state. Remember to free the returned string with edje_edit_string_free(). */
+EAPI const char *          ///@return A newly allocated string containing the text for the given state
+edje_edit_state_text_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Set the text of a part state.*/
+EAPI void
+edje_edit_state_text_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   const char *text        ///< The new text to assign
+);
+
+/**Get the text size of a part state. The function will return -1 on errors.*/
+EAPI int                   ///@return The font size in pixel or -1 on errors.
+edje_edit_state_text_size_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Set the text size of a part state.*/
+EAPI void
+edje_edit_state_text_size_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   int size                ///< The new font size to set (in pixel)
+);
+
+/**Get the text horizontal align of a part state. The value range is from 0.0(right) to 1.0(left)*/
+EAPI double                ///@return The text align X value
+edje_edit_state_text_align_x_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Get the text vertical align of a part state. The value range is from 0.0(top) to 1.0(bottom)*/
+EAPI double                ///@return The text align Y value
+edje_edit_state_text_align_y_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Set the text horizontal align of a part state. The value range is from 0.0(right) to 1.0(left)*/
+EAPI void
+edje_edit_state_text_align_x_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   double align            ///< The new text align X value
+);
+/**Set the text vertical align of a part state. The value range is from 0.0(top) to 1.0(bottom)*/
+EAPI void
+edje_edit_state_text_align_y_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   double align            ///< The new text align Y value
+);
+
+/**Get the list of all the fonts in the given edje.
+ * @return An Evas_List* of string (char *)containing all the fonts names found 
+ * in the edje file.
+ * Use edje_edit_string_list_free() when you don't need it anymore.
+ */
+EAPI Evas_List *          ///@return A string list of all the fonts found in the edje file
+edje_edit_fonts_list_get(
+   Evas_Object *obj       ///< The edje object
+);
+
+/**Add a new ttf font to the edje file.
+ * The newly created font will be available to all the groups in the edje, not only the current one.
+ * If font can't be load FALSE is returned.
+ */
+EAPI unsigned char         ///@return TRUE on success or FALSE on failure
+edje_edit_font_add(
+   Evas_Object *obj,       ///< The edje object
+   const char* path        ///< The file path to load the ttf font from
+);
+
+/**Get font name for a given part state. Remember to free the returned string using edje_edit_string_free().*/
+EAPI const char *          ///@return The name of the font used in the given part state
+edje_edit_state_font_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Set font name for a given part state. */
+EAPI void
+edje_edit_state_font_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   const char *font        ///< The name of the font to use in the given part state
+);
+
+//@}
+/******************************************************************************/
+/**************************   IMAGES API   ************************************/
+/******************************************************************************/
+/** @name Images API
+ *  Description of gen api 2. 
+ */ //@{
+
+/**Get the list of all the images in the given edje.
+ * @return An Evas_List* of string (char *)containing all the images names found 
+ * in the edje file.
+ * Use edje_edit_string_list_free() when you don't need it anymore.
+ */
+EAPI Evas_List *          ///@return A string list containing all the images found in the edje file
+edje_edit_images_list_get(
+   Evas_Object *obj       ///< The edje object
+);
+
+/**Add an new image to the image collection
+ *
+ * This function add the given image inside the edje. Don't add a new image part
+ * but only put the image inside the edje file. It actually write directly to 
+ * the file so you don't have to save (and you can't undo!).
+ * After you have to create a new image_part that use this image. Note that all
+ * the parts in the edje share the same image collection, thus you can/must use 
+ * the same image for different part.
+ * 
+ * The format of the image files that can be loaded depend on the evas engine on your system
+ */
+EAPI unsigned char         ///@return TRUE on success or FALSE on failure
+edje_edit_image_add(
+   Evas_Object *obj,       ///< The edje object
+   const char* path        ///< The name of the image file to include in the edje
+);
+   
+/**Get normal image name for a given part state. Remember to free the returned string using edje_edit_string_free().*/
+EAPI const char *          ///@return The name of the image used by state
+edje_edit_state_image_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+/**Set normal image for a given part state.*/
+EAPI void
+edje_edit_state_image_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   const char *image       ///< The name of the image for the given state (must be an image contained in the edje file)
+);
+
+/**Get image id for a given image name. Could be usefull to directly load the image from the eet file.*/
+EAPI int                   ///< The ID of the givan image name
+edje_edit_image_id_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *image_name
+);
+
+/**Get the image border of a part state. Pass NULL to any of [r,g,b,a] to get only the others.*/
+EAPI void
+edje_edit_state_image_border_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   int *l,                 ///< A pointer to store the left value
+   int *r,                 ///< A pointer to store the right value
+   int *t,                 ///< A pointer to store the top value
+   int *b                  ///< A pointer to store the bottom value
+);
+/**Set the image border of a part state. Pass -1 to any of [l,r,t,b] to leave the value untouched.*/
+EAPI void
+edje_edit_state_image_border_set(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   int l,                  ///< The new left border (or -1)
+   int r,                  ///< The new right border (or -1)
+   int t,                  ///< The new top border (or -1)
+   int b                   ///< The new bottom border (or -1)
+);
+    
+/**Get the list of all the tweens images in the given part state.
+ * Use edje_edit_string_list_free() when you don't need it anymore.
+ */
+EAPI Evas_List *           ///@return A string list containing all the image name that form a tween animation in the given part state
+edje_edit_state_tweens_list_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state       ///< The name of the 'part state' (ex. "default 0.00")
+);
+
+/**Add a new tween frame to the given part state
+ * The tween param must be the name of an existing image.
+ */
+EAPI unsigned char         ///@return 1 on success, 0 otherwise
+edje_edit_state_tween_add(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   const char *tween       ///< The name of the image to add.
+);
+   
+/**Remove the first tween with the given name.
+ * If none is removed the function return 0.
+ * The image is not removed from the edje.
+ */
+EAPI unsigned char         ///@return 1 on success, 0 otherwise
+edje_edit_state_tween_del(
+   Evas_Object *obj,       ///< The edje object
+   const char *part,       ///< The name of the part
+   const char *state,      ///< The name of the 'part state' (ex. "default 0.00")
+   const char *tween       ///< The name of the image to remove from the tween list.
+);
+
+//@}
+/******************************************************************************/
+/*************************   PROGRAMS API   ***********************************/
+/******************************************************************************/ 
+/** @name Programs API
+ *  Description of gen api 2. 
+ */ //@{
+
+/**Get the list of all the programs in the given edje object.
+ * @param obj The edje object
+ * @return An Evas_List* of string (char *)containing all the program names.
+ * Use edje_edit_string_list_free() when you don't need it anymore.
+ */
+EAPI Evas_List *          ///@return A string list containing all the program names
+edje_edit_programs_list_get(
+   Evas_Object *obj       ///< The edje object
+);
+/**Get source of a given program. Remember to free the returned string using edje_edit_string_free().*/
+EAPI const char *          ///@return The source value for prog
+edje_edit_program_source_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *prog        ///< The program name
+);
+/**Get signal of a given program. Remember to free the returned string using edje_edit_string_free().*/
+EAPI const char *          ///@return The signal value for prog
+edje_edit_program_signal_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *prog        ///< The program name
+);
+/**Get in.from of a given program.*/
+EAPI double                ///@return The delay 
+edje_edit_program_in_from_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *prog        ///< The program name
+);
+/**Get in.range of a given program.*/
+EAPI double                ///@return The delay random
+edje_edit_program_in_range_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *prog        ///< The program name
+);
+/**Get the action of a given program.
+ * Action can be one of EDJE_ACTION_TYPE_NONE, _STATE_SET, ACTION_STOP, SIGNAL_EMIT, DRAG_VAL_SET, _DRAG_VAL_STEP, _DRAG_VAL_PAGE, _SCRIPT
+ */
+EAPI int                   ///@return The action type, or -1 on errors
+edje_edit_program_action_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *prog        ///< The program name
+);
+
+/**Get the list of the targets for the given program
+ * Return a list of target name
+ * Use edje_edit_string_list_free() when you don't need it anymore.
+ */
+EAPI Evas_List*            ///@return An Evas_List of char*, or NULL on error
+edje_edit_program_targets_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *prog        ///< The program name
+);
+   
+/**Get the list of action that will be run after the give program
+ * Return a list of program name.
+ * Use edje_edit_string_list_free() when you don't need it anymore.
+ */
+EAPI Evas_List*            ///@return An Evas_List of char*, or NULL on error
+edje_edit_program_afters_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *prog        ///< The program name
+);
+
+/**Get the state for the given program
+ * In a STATE_SET action this is the name of state to set.
+ * In a SIGNAL_EMIT action is the name of the signal to emit.
+ */
+EAPI const char*           ///@return The name of state for prog
+edje_edit_program_state_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *prog        ///< The program name
+);
+
+/**Get the value of state for the given program.
+ * In a STATE_SET action this is the value of state to set.
+ * Not used on SIGNAL_EMIT action.
+ */
+EAPI double                ///@return The value of state for prog
+edje_edit_program_value_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *prog        ///< The program name
+);
+
+/**Get the state2 for the given program
+ * In a STATE_SET action is not used
+ * In a SIGNAL_EMIT action is the source of the emitted signal.
+ */
+EAPI const char*           ///@return The source to emit for prog
+edje_edit_program_state2_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *prog        ///< The program name
+);
+
+/**Get the value of state2 for the given program.
+ * I don't know what this is used for. :P
+ */
+EAPI double                ///@return The value of state2 for prog
+edje_edit_program_value2_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *prog        ///< The program name
+);
+
+/**Get the type of transition to use when apply animations.
+ * Can be one of: EDJE_TWEEN_MODE_NONE, EDJE_TWEEN_MODE_LINEAR, EDJE_TWEEN_MODE_SINUSOIDAL, EDJE_TWEEN_MODE_ACCELERATE or EDJE_TWEEN_MODE_DECELERATE.
+ */
+EAPI int                   ///@return The type of transition used by program
+edje_edit_program_transition_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *prog        ///< The program name
+);
+   
+/**Get the duration of the transition in seconds.*/
+EAPI double                ///@return The duration of the transition
+edje_edit_program_transition_time_get(
+   Evas_Object *obj,       ///< The edje object
+   const char *prog        ///< The program name
+);
+
+//@}
+/******************************************************************************/
+/**************************   SCRIPTS API   ***********************************/
+/******************************************************************************/
+/** @name Scripts API
+ *  Description of gen api 2. 
+ */ //@{
+
+    
+    
+
+EAPI const char* edje_edit_script_get(Evas_Object *obj);
+
+    
+   
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: src/lib/Makefile.am
===================================================================
RCS file: /cvs/e/e17/libs/edje/src/lib/Makefile.am,v
retrieving revision 1.39
diff -u -r1.39 Makefile.am
--- src/lib/Makefile.am	18 Jan 2008 06:38:46 -0000	1.39
+++ src/lib/Makefile.am	16 Feb 2008 16:53:14 -0000
@@ -14,7 +14,8 @@
 libedje.la
 
 include_HEADERS      =  \
-Edje.h
+Edje.h \
+Edje_Edit.h
 
 libedje_la_SOURCES  = \
 edje_calc.c \
@@ -35,7 +36,8 @@
 edje_private.h \
 edje_cache.c \
 edje_match.c \
-edje_textblock_styles.c
+edje_textblock_styles.c \
+edje_edit.c
 
 libedje_la_LIBADD       = -lm @EDJE_LIBS@
 libedje_la_DEPENDENCIES = $(top_builddir)/config.h
Index: src/lib/edje_edit.c
===================================================================
RCS file: src/lib/edje_edit.c
diff -N src/lib/edje_edit.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/lib/edje_edit.c	16 Feb 2008 16:53:14 -0000
@@ -0,0 +1,2392 @@
+/*
+ * vim:ts=8:sw=3:sts=8:noexpandtab:cino=>5n-3f0^-2{2
+ */
+/**
+
+ TODO / BUGS
+-------------
+
+* globe.edj segfault if you insert a new image
+* Can't have scripts source
+* Write decompile info (print source) back to edje file
+
+
+**/
+#include <locale.h>
+#include <errno.h>
+#include <Ecore_Evas.h>
+#include <Ecore_File.h>
+#include "Edje.h"
+#include "edje_private.h"
+#include "../bin/edje_cc.h"
+#include "Edje_Edit.h"
+
+#define MAX_PATH 4096
+
+/* Get ed(Edje*) from obj(Evas_Object*) */
+#define GET_ED_OR_RETURN(RET) \
+   Edje *ed; \
+   ed = _edje_fetch(obj); \
+   if (!ed) return RET;
+
+/* Get rp(Edje_Real_Part*) from obj(Evas_Object*) and part(char*) */
+#define GET_RP_OR_RETURN(RET) \
+   Edje *ed; \
+   Edje_Real_Part *rp; \
+   ed = _edje_fetch(obj); \
+   if (!ed) return RET; \
+   rp = _edje_real_part_get(ed, part); \
+   if (!rp) return RET;
+
+/* Get pd(Edje_Part_Description*) from obj(Evas_Object*), part(char*) and state (char*) */
+#define GET_PD_OR_RETURN(RET) \
+   Edje *ed; \
+   Edje_Part_Description *pd; \
+   ed = _edje_fetch(obj); \
+   if (!ed) return RET; \
+   pd = _edje_part_description_find_byname(ed, part, state); \
+   if (!pd) return RET;
+
+/* Get epr(Edje_Program*) from obj(Evas_Object*) and prog(char*)*/
+#define GET_EPR_OR_RETURN(RET) \
+   Edje_Program *epr; \
+   epr = _edje_program_get_byname(obj, prog); \
+   if (!epr) return RET;
+
+void *
+mem_alloc(size_t size)
+{
+   void *mem;
+   
+   mem = calloc(1, size);
+   if (mem) return mem;
+   fprintf(stderr, "Edje_Edit: Error. memory allocation of %i bytes failed. %s\n",
+           size, strerror(errno));
+   exit(-1);
+   return NULL;
+}
+
+char *
+mem_strdup(const char *s)
+{
+   void *str;
+   
+   str = strdup(s);
+   if (str) return str;
+   fprintf(stderr, "Edje_Edit: Error. memory allocation of %i bytes failed. %s."
+        "string being duplicated: \"%s\"\n", strlen(s) + 1, strerror(errno), s);
+   exit(-1);
+   return NULL;
+}
+
+
+/*************/
+/* INTERNALS */
+/*************/
+
+Edje_Part_Description *
+_edje_part_description_find_byname(Edje *ed, const char *part, const char *state) //state include the value in the string (ex. "default 0.00")
+{
+   Edje_Real_Part *rp;
+   Edje_Part_Description *pd;
+   char *delim;
+   double value;
+   char *name;
+   
+   if (!ed || !part || !state) return NULL;
+   
+   rp = _edje_real_part_get(ed, part);
+   if (!rp) return NULL;
+   
+   name = strdup(state);
+   delim = strrchr(name, (int)' ');
+   if (!delim)
+   {
+      free(name);
+      return NULL;
+   }
+   
+   if (sscanf(delim,"%lf", &value) != 1)
+   {
+      free(name);
+      return NULL;
+   }
+   
+   delim[0] = '\0';
+   //printf("SEARCH DESC(%s): %s %f\n", state, state, value);
+   pd = _edje_part_description_find(ed, rp, name, value);
+
+   free(name);
+   
+   if (!pd) return NULL;
+   return pd;
+}
+
+int
+_edje_image_id_find(Evas_Object *obj, const char *image_name)
+{
+   Edje_Image_Directory_Entry *i;
+   Evas_List *l;
+    
+   GET_ED_OR_RETURN(-1);
+   
+   if (!ed->file) return -1;
+   if (!ed->file->image_dir) return -1;
+   
+   //printf("SEARCH IMAGE %s\n",image_name);
+    
+   l = ed->file->image_dir->entries;
+   while (l)
+   {
+      i = l->data;
+      if (strcmp(image_name,i->entry) == 0)
+      {
+         //printf("   Found id: %d \n", i->id);
+         return i->id;
+      }
+      l = l->next;
+   }
+    
+   return -1;
+}
+
+const char*
+_edje_image_name_find(Evas_Object *obj, int image_id)
+{
+   Edje_Image_Directory_Entry *i;
+   Evas_List *l;
+   
+   GET_ED_OR_RETURN(NULL);
+   
+   if (!ed->file) return NULL;
+   if (!ed->file->image_dir) return NULL;
+   
+   //printf("SEARCH IMAGE ID %d\n", image_id);
+   
+   l = ed->file->image_dir->entries;
+   while (l)
+   {
+      i = l->data;
+      if (image_id == i->id)
+      {
+         return i->entry;
+      }
+      l = l->next;
+   }
+   
+   return NULL;
+}
+
+static void
+_edje_real_part_free(Edje_Real_Part *rp)
+{
+   Evas_List *l;
+   
+   if (!rp) return;
+   
+   if (rp->object)
+   {
+      _edje_text_real_part_on_del(rp->edje, rp);
+      _edje_callbacks_del(rp->object);
+      evas_object_del(rp->object);
+   }
+   
+   l = rp->extra_objects;
+   while (rp->extra_objects)
+   {
+      evas_object_del(rp->extra_objects->data);
+      rp->extra_objects = evas_list_remove_list(rp->extra_objects,
+                                                rp->extra_objects);
+   }
+   
+   if (rp->swallowed_object)
+   {
+      evas_object_smart_member_del(rp->swallowed_object);
+      evas_object_event_callback_del(rp->swallowed_object,
+                                     EVAS_CALLBACK_FREE,
+                                     _edje_object_part_swallow_free_cb);
+      evas_object_clip_unset(rp->swallowed_object);
+      evas_object_data_del(rp->swallowed_object, "\377 edje.swallowing_part");
+      if (rp->part->mouse_events)
+         _edje_callbacks_del(rp->swallowed_object);
+      
+      if (rp->part->type == EDJE_PART_TYPE_GROUP)
+         evas_object_del(rp->swallowed_object);
+
+      rp->swallowed_object = NULL;
+   }
+   
+   if (rp->text.text) evas_stringshare_del(rp->text.text);
+   if (rp->text.font) evas_stringshare_del(rp->text.font);
+   if (rp->text.cache.in_str) evas_stringshare_del(rp->text.cache.in_str);
+   if (rp->text.cache.out_str) evas_stringshare_del(rp->text.cache.out_str);
+   
+   if (rp->custom.description)
+   {
+      _edje_collection_free_part_description_free(rp->custom.description);
+   }
+
+   _edje_unref(rp->edje);
+   free(rp);
+
+}
+
+static unsigned char
+_edje_import_image_file(Edje *ed, const char *path, int id)
+{
+   Evas_Object *im;
+   Eet_File *eetf;
+   
+   /* Try to load the file */
+   im = evas_object_image_add(ed->evas);
+   if (!im) return 0;
+
+   evas_object_image_file_set(im, path, NULL);
+   if (evas_object_image_load_error_get(im) != EVAS_LOAD_ERROR_NONE)
+   {
+      fprintf(stderr, "Edje_Edit: Error. unable to load image \"%s\"."
+                      "Missing PNG or JPEG loader modules for Evas or "
+                      "file does not exist, or is not readable.\n", path);
+      evas_object_del(im);
+      im = NULL;
+      return 0;
+   }
+   
+   if (!im) return 0;
+   
+   /* Write the loaded image to the edje file */
+   void *im_data;
+   int  im_w, im_h;
+   int  im_alpha;
+   int bytes;
+   char buf[256];
+
+   evas_object_image_size_get(im, &im_w, &im_h);
+   im_alpha = evas_object_image_alpha_get(im);
+   im_data = evas_object_image_data_get(im, 0);
+   if ((!im_data) || !(im_w > 0) || !(im_h > 0))
+   {
+      evas_object_del(im);
+      return 0;
+   }
+
+   /* open the eet file */
+   eetf = eet_open(ed->path, EET_FILE_MODE_READ_WRITE);
+   if (!eetf)
+   {
+      fprintf(stderr,
+              "Edje_Edit: Error. unable to open \"%s\" for writing output\n",
+              ed->path);
+      evas_object_del(im);
+      return 0;
+   }
+    
+   snprintf(buf, sizeof(buf), "images/%i", id);
+   
+   /* write the image data */
+   printf("***********  Writing images/%i to edj ******************\n", id);
+   bytes = eet_data_image_write(eetf, buf,
+               im_data, im_w, im_h,
+               im_alpha,
+               0, 100, 1);
+   if (bytes <= 0)
+   {
+      fprintf(stderr, "Edje_Edit: Error. unable to write image part \"%s\" "
+                      "part entry to %s\n", buf, ed->path);
+      evas_object_del(im);
+      return 0;
+   }
+   
+   /* Rewrite Edje_File to edj */
+   evas_object_del(im);
+   
+   printf("***********  Writing Edje_File* ed->file ******************\n");
+   bytes = eet_data_write(eetf, _edje_edd_edje_file, "edje_file", ed->file, 1);
+   if (bytes <= 0)
+   {
+      fprintf(stderr, "Edje_Edit: Error. unable to write \"edje_file\" "
+                      "entry to \"%s\" \n", ed->path);
+      eet_close(eetf);
+      return 0;
+   }
+    
+   eet_close(eetf);
+   return 1;
+
+}
+/*****************/
+/*  GENERAL API  */
+/*****************/
+
+EAPI void
+edje_edit_string_list_free(Evas_List *lst)
+{
+   //printf("FREE LIST: \n");
+   while (lst)
+   {
+      if (lst->data) evas_stringshare_del(lst->data);
+      //printf("FREE: %s\n",lst->data);
+      lst = evas_list_remove(lst, lst->data);
+   }
+}
+
+EAPI void
+edje_edit_string_free(const char *str)
+{
+   if (str) evas_stringshare_del(str);
+}
+
+/****************/
+/*  GROUPS API  */
+/****************/
+
+EAPI unsigned char
+edje_edit_group_add(Evas_Object *obj, const char *name)
+{
+   printf("ADD GROUP: %s \n", name);
+   
+   GET_ED_OR_RETURN(0);
+   
+   Edje_Part_Collection_Directory_Entry *de;
+   Edje_Part_Collection *pc;
+   Evas_List *l;
+   //Code *cd;
+   
+   /* check if a group with the same name already exists */
+   for (l = ed->file->collection_dir->entries; l; l = l->next)
+   {
+      Edje_Part_Collection_Directory_Entry *d = l->data;
+      if (!strcmp(d->entry, name))
+         return 0;
+   }
+   
+   /* Create structs */
+   de = mem_alloc(SZ(Edje_Part_Collection_Directory_Entry));
+   if (!de) return 0;
+   
+   pc = mem_alloc(SZ(Edje_Part_Collection));
+   if (!pc)
+   {
+      free(de);
+      return 0;
+   }
+   
+   /* Search first free id */
+   int id = 0;
+   int search = 0;
+   while (!id)
+   {
+      unsigned char found = 0;
+      for (l = ed->file->collection_dir->entries; l; l = l->next)
+      {
+         Edje_Part_Collection_Directory_Entry *d = l->data;
+        // printf("search if %d is free [id %d]\n", search, d->id);
+         if (search == d->id)
+         {
+            found = 1;
+            break;
+         }
+      }
+      if (!found)
+         id = search;
+      else
+         search++;
+   }
+   
+   /* Init Edje_Part_Collection_Directory_Entry */
+   printf(" new id: %d\n",id);
+   de->id = id;
+   de->entry = mem_strdup(name);
+   ed->file->collection_dir->entries = evas_list_append(ed->file->collection_dir->entries, de);
+   
+   
+   /* Init Edje_Part_Collection */
+   pc->id = id;
+   pc->references = 1;
+   pc->programs = NULL;
+   pc->parts = NULL;
+   pc->data = NULL;
+   pc->script = NULL;
+   pc->part = evas_stringshare_add(name);
+   
+   //cd = mem_alloc(SZ(Code));
+   //codes = evas_list_append(codes, cd);
+ 
+   ed->file->collection_hash = evas_hash_add(ed->file->collection_hash, name, pc);
+ 
+   return 1;
+}
+
+
+EAPI unsigned char
+edje_edit_group_del(Evas_Object *obj)
+{
+   GET_ED_OR_RETURN(0)
+   
+   Evas_List *l;
+   int i;
+   Edje_Part_Collection *g;
+   g = ed->collection;
+   printf("REMOVE GROUP: %s [id: %d]\n", g->part, g->id);
+   
+   /* Don't remove the last group */
+   if (evas_list_count(ed->file->collection_dir->entries) < 2)
+      return 0;
+   
+   /* Remove collection/id from eet file */
+   Eet_File *eetf;
+   char buf[32];
+   eetf = eet_open(ed->file->path, EET_FILE_MODE_READ_WRITE);
+   if (!eetf)
+   {
+      fprintf(stderr, "Edje_Edit: Error. unable to open \"%s\" "
+                      "for writing output\n", ed->file->path);
+      return 0;
+   }
+   snprintf(buf, SZ(buf), "collections/%d",g->id);
+   eet_delete(eetf, buf);
+   eet_close(eetf);
+   
+   /* Remove all Edje_Real_Parts */
+   for (i = 0; i < ed->table_parts_size; i++)
+   {
+      _edje_real_part_free(ed->table_parts[i]);
+   }
+   ed->table_parts_size = 0;
+   free(ed->table_parts);
+   ed->table_parts = NULL;
+   
+   /* Free Group */
+   _edje_collection_free(ed->file, g);
+   
+   /* Update collection_dir */
+   for (l = ed->file->collection_dir->entries; l; l = l->next)
+   {
+      Edje_Part_Collection_Directory_Entry *e;
+      e = l->data;
+      printf("  id: %d  entry: %s\n", e->id, e->entry);
+      if (e->id == g->id)
+      {
+         ed->file->collection_dir->entries = evas_list_remove_list(
+                                    ed->file->collection_dir->entries, l);
+//         free(e->entry);  This should be right but cause a segv
+         free(e);
+         e = NULL;
+         break;
+      }
+   }
+   
+   ed->collection = NULL;
+   
+   if (ed->table_programs_size > 0)
+   {
+      free(ed->table_programs);
+      ed->table_programs = NULL;
+      ed->table_programs_size = 0;
+   }
+   
+   return 1;
+}
+
+EAPI void
+edje_edit_group_name_set(Evas_Object *obj, const char *new_name)
+{
+   Evas_List *l;
+   int id;
+  
+   GET_ED_OR_RETURN()
+   
+   Edje_Part_Collection *pc;   
+   pc = ed->collection;
+
+   printf("Set name of current group: %s [id: %d][new name: %s]\n",
+          pc->part, pc->id, new_name); 
+   
+   if (pc->part) evas_stringshare_del(pc->part);
+   pc->part = evas_stringshare_add(new_name);
+   
+   l = ed->file->collection_dir->entries;
+   while (l)
+   {
+      Edje_Part_Collection_Directory_Entry *pce = l->data;
+      if (pc->id == pce->id)
+      {
+         //if (pce->entry) free(pce->entry); //Also this cause segv
+         pce->entry = mem_strdup(new_name);
+         
+         //ed->file->collection_hash = evas_hash_del(ed->file->collection_hash, pc->entry, edc);
+         //ed->file->collection_hash = evas_hash_add(ed->file->collection_hash, name, pc);
+         
+         return;
+      }
+      l = l->next;
+   }
+}
+
+EAPI void
+edje_edit_group_min_w_set(Evas_Object *obj, int w)
+{
+   printf("Set min_w of group [new w: %d]\n", w);
+   GET_ED_OR_RETURN()
+   ed->collection->prop.min.w = w;
+}
+EAPI void
+edje_edit_group_min_h_set(Evas_Object *obj, int h)
+{
+   printf("Set min_h of group [new h: %d]\n", h);
+   GET_ED_OR_RETURN()
+   ed->collection->prop.min.h = h;
+}
+EAPI void
+edje_edit_group_max_w_set(Evas_Object *obj, int w)
+{
+   printf("Set max_w of group: [new w: %d]\n", w);
+   GET_ED_OR_RETURN()
+   ed->collection->prop.max.w = w;
+}
+EAPI void
+edje_edit_group_max_h_set(Evas_Object *obj, int h)
+{
+   printf("Set max_h of group: [new h: %d]\n", h);
+   GET_ED_OR_RETURN()
+   ed->collection->prop.max.h = h;
+}
+
+/***************/
+/*  PARTS API  */
+/***************/
+
+EAPI Evas_List *
+edje_edit_parts_list_get(Evas_Object *obj)
+{
+   Evas_List *parts;
+   int i;
+   
+   GET_ED_OR_RETURN(NULL)
+   
+   //printf("EE: Found %d parts\n", ed->table_parts_size);
+   
+   parts = NULL;
+   for (i = 0; i < ed->table_parts_size; i++)
+   {
+      Edje_Real_Part *rp;
+      rp = ed->table_parts[i];
+      parts = evas_list_append(parts, evas_stringshare_add(rp->part->name));
+   }
+
+   return parts;
+}
+
+EAPI void
+edje_edit_part_name_set(Evas_Object *obj, const char* part, const char* new_name)
+{
+   GET_RP_OR_RETURN()
+   if (!new_name) return;
+   
+   printf("Set name of part: %s [new name: %s]\n", part, new_name);
+   
+   if (rp->part->name) evas_stringshare_del(rp->part->name);
+   rp->part->name = (char *)evas_stringshare_add(new_name);
+}
+
+
+EAPI unsigned char
+edje_edit_part_add(Evas_Object *obj, const char* name, unsigned char type)
+{
+   printf("ADD PART: %s [type: %d]\n", name, type);
+   
+   Edje_Part_Collection *pc;
+   Edje_Part *ep;
+   Edje_Real_Part *rp;
+   
+   GET_ED_OR_RETURN(FALSE)
+   
+   //Check if part already exists
+   if (_edje_real_part_get(ed, name))
+      return FALSE;
+   
+   //Alloc Edje_Part or return
+   ep = mem_alloc(sizeof(Edje_Part));
+   if (!ep) return FALSE;
+   
+   //Alloc Edje_Real_Part or return
+   rp = mem_alloc(sizeof(Edje_Real_Part));
+   if (!rp)
+   {
+      free(ep);
+      return FALSE;
+   }
+   
+   //Init Edje_Part
+   pc = ed->collection;
+   pc->parts = evas_list_append(pc->parts, ep);
+   
+   ep->id = evas_list_count(pc->parts) - 1;
+   ep->type = type;
+   ep->name = evas_stringshare_add(name);
+   ep->mouse_events = 1;
+   ep->repeat_events = 0;
+   ep->pointer_mode = EVAS_OBJECT_POINTER_MODE_AUTOGRAB;
+   ep->precise_is_inside = 0;
+   ep->use_alternate_font_metrics = 0;
+   ep->clip_to_id = -1;
+   ep->dragable.confine_id = -1;
+   ep->dragable.events_id = -1;
+   
+   ep->default_desc = NULL;
+   ep->other_desc = NULL;
+   
+   //Init Edje_Real_Part
+   rp->edje = ed;
+   _edje_ref(rp->edje);
+   rp->part = ep;
+   
+   if (ep->type == EDJE_PART_TYPE_RECTANGLE)
+      rp->object = evas_object_rectangle_add(ed->evas);
+   else if (ep->type == EDJE_PART_TYPE_IMAGE)
+      rp->object = evas_object_image_add(ed->evas);
+   else if (ep->type == EDJE_PART_TYPE_TEXT)
+   {
+      _edje_text_part_on_add(ed, rp);
+      rp->object = evas_object_text_add(ed->evas);
+      evas_object_text_font_source_set(rp->object, ed->path);
+   }
+   else if (ep->type == EDJE_PART_TYPE_SWALLOW ||
+            ep->type == EDJE_PART_TYPE_GROUP)
+   {
+      rp->object = evas_object_rectangle_add(ed->evas);
+      evas_object_color_set(rp->object, 0, 0, 0, 0);
+      evas_object_pass_events_set(rp->object, 1);
+      evas_object_pointer_mode_set(rp->object, EVAS_OBJECT_POINTER_MODE_NOGRAB);
+   }
+   else if (ep->type == EDJE_PART_TYPE_TEXTBLOCK)
+      rp->object = evas_object_textblock_add(ed->evas);
+   else if (ep->type == EDJE_PART_TYPE_GRADIENT)
+      rp->object = evas_object_gradient_add(ed->evas);
+   else
+   {
+      printf("EDJE ERROR: wrong part type %i!\n", ep->type);
+   }
+   if (rp->object)
+   {
+      evas_object_smart_member_add(rp->object, ed->obj);
+      evas_object_layer_set(rp->object, evas_object_layer_get(ed->obj));
+      if (ep->type != EDJE_PART_TYPE_SWALLOW && ep->type != EDJE_PART_TYPE_GROUP)
+      {
+         if (ep->mouse_events)
+         {
+            _edje_callbacks_add(rp->object, ed, rp);
+            if (ep->repeat_events)
+               evas_object_repeat_events_set(rp->object, 1);
+
+            if (ep->pointer_mode != EVAS_OBJECT_POINTER_MODE_AUTOGRAB)
+               evas_object_pointer_mode_set(rp->object, ep->pointer_mode);
+         }
+         else
+         {
+            evas_object_pass_events_set(rp->object, 1);
+            evas_object_pointer_mode_set(rp->object,
+                                         EVAS_OBJECT_POINTER_MODE_NOGRAB);
+         }
+         if (ep->precise_is_inside)
+            evas_object_precise_is_inside_set(rp->object, 1);
+      }
+      if (rp->part->clip_to_id < 0)
+         evas_object_clip_set(rp->object, ed->clipper);
+   }
+   rp->drag.step.x = ep->dragable.step_x;
+   rp->drag.step.y = ep->dragable.step_y;
+   rp->gradient_id = -1;
+
+   
+   //Update table_parts
+   ed->table_parts_size++;
+   ed->table_parts = realloc(ed->table_parts,
+                             sizeof(Edje_Real_Part *) * ed->table_parts_size);
+   
+   ed->table_parts[ep->id % ed->table_parts_size] = rp;
+   
+   
+   //create default description
+   edje_edit_state_add(obj, name, "default");
+   
+   rp->param1.description = ep->default_desc;
+   rp->chosen_description = rp->param1.description;
+   
+   return TRUE;
+}
+
+EAPI unsigned char
+edje_edit_part_del(Evas_Object *obj, const char* part)
+{
+   printf("REMOVE PART: %s\n", part);
+   Evas_List *l;
+   int id;
+   GET_RP_OR_RETURN()
+   Edje_Part *ep;
+   ep = rp->part;
+   id = ep->id;
+   
+   if (ed->table_parts_size <= 1) return FALSE; //don't remove the last part
+   
+   //Remove part from parts list
+   Edje_Part_Collection *pc;
+   pc = ed->collection;
+   pc->parts = evas_list_remove(pc->parts, ep);
+   
+   //Free Edje_Part and all descriptions
+   if (ep->name) evas_stringshare_del(ep->name);
+   if (ep->default_desc)
+   {
+      _edje_collection_free_part_description_free(ep->default_desc);
+      ep->default_desc = NULL;
+   }
+   while (ep->other_desc)
+   {
+      Edje_Part_Description *desc;
+      
+      desc = ep->other_desc->data;
+      ep->other_desc = evas_list_remove(ep->other_desc, desc);
+      _edje_collection_free_part_description_free(desc);
+   }
+   free(ep);
+   
+   //Clear real_parts that link to the removed one
+   int i;
+   for (i = 0; i < ed->table_parts_size; i++)
+   {
+      Edje_Real_Part *real;
+      real = ed->table_parts[i];
+      if (real->text.source == rp) real->text.source = NULL;
+      if (real->text.text_source == rp) real->text.text_source = NULL;
+      
+      if (real->param1.rel1_to_x == rp) real->param1.rel1_to_x = NULL;
+      if (real->param1.rel1_to_y == rp) real->param1.rel1_to_y = NULL;
+      if (real->param1.rel2_to_x == rp) real->param1.rel2_to_x = NULL;
+      if (real->param1.rel2_to_y == rp) real->param1.rel2_to_y = NULL;
+      
+      if (real->param2.rel1_to_x == rp) real->param2.rel1_to_x = NULL;
+      if (real->param2.rel1_to_y == rp) real->param2.rel1_to_y = NULL;
+      if (real->param2.rel2_to_x == rp) real->param2.rel2_to_x = NULL;
+      if (real->param2.rel2_to_y == rp) real->param2.rel2_to_y = NULL;
+      
+      if (real->custom.rel1_to_x == rp) real->custom.rel1_to_x = NULL;
+      if (real->custom.rel1_to_y == rp) real->custom.rel1_to_y = NULL;
+      if (real->custom.rel2_to_x == rp) real->custom.rel2_to_x = NULL;
+      if (real->custom.rel2_to_y == rp) real->custom.rel2_to_y = NULL;
+   }
+   
+   
+   //Free real_part
+   _edje_real_part_free(rp);
+   
+   
+   //Update parts table (and all references?)
+   //We move the last part in place of the deleted one
+   //and realloc the table without the last element.
+   ed->table_parts[id % ed->table_parts_size] = ed->table_parts[ed->table_parts_size-1];
+   ed->table_parts_size--;
+   ed->table_parts = realloc(ed->table_parts,
+                             sizeof(Edje_Real_Part *) * ed->table_parts_size);
+   
+   //Update the id of the moved part
+   int old_id;
+   if (id < ed->table_parts_size)
+   {
+      rp = ed->table_parts[id % ed->table_parts_size];
+      printf("UPDATE: %s(id:%d) with new id: %d\n",
+             rp->part->name, rp->part->id, id);
+      old_id = rp->part->id;
+      rp->part->id = id;
+   }else
+      old_id = -1;
+   
+   //We also update all the parts and descriptions that refer to id or old_id
+   for (l = ed->collection->parts; l; l = l->next)
+   {
+      Edje_Part *p;
+      p = l->data;
+      if (p->clip_to_id == id) p->clip_to_id = 0;  //TODO is 0 right?? don't tink so (maybe we need to unclip in some way)
+      if (p->clip_to_id == old_id && old_id != -1) p->clip_to_id = id;
+      if (p->dragable.confine_id == id) p->dragable.confine_id = 0; //TODO is 0 right?? don't tink so (maybe we need to unclip in some way)
+      if (p->dragable.confine_id == old_id && old_id != -1)
+         p->dragable.confine_id = id;
+      
+      Evas_List *ll;
+      Edje_Part_Description *d;
+      d = p->default_desc;
+      if (d->rel1.id_x == id) d->rel1.id_x = -1;
+      if (d->rel1.id_x == old_id && old_id != -1) d->rel1.id_x = id;
+      if (d->rel1.id_y == id) d->rel1.id_y = -1;
+      if (d->rel1.id_y == old_id && old_id != -1) d->rel1.id_y = id;
+      if (d->rel2.id_x == id) d->rel2.id_x = -1;
+      if (d->rel2.id_x == old_id && old_id != -1) d->rel2.id_x = id;
+      if (d->rel2.id_y == id) d->rel2.id_y = -1;
+      if (d->rel2.id_y == old_id && old_id != -1) d->rel2.id_y = id;
+      //TODO d->text.id_source ??
+      //TODO d->text.id_text_source ??
+      for (ll = p->other_desc; ll; ll = ll->next)
+      {
+         d = ll->data;
+         if (d->rel1.id_x == id) d->rel1.id_x = -1;
+         if (d->rel1.id_x == old_id && old_id != -1) d->rel1.id_x = id;
+         if (d->rel1.id_y == id) d->rel1.id_y = -1;
+         if (d->rel1.id_y == old_id && old_id != -1) d->rel1.id_y = id;
+         if (d->rel2.id_x == id) d->rel2.id_x = -1;
+         if (d->rel2.id_x == old_id && old_id != -1) d->rel2.id_x = id;
+         if (d->rel2.id_y == id) d->rel2.id_y = -1;
+         if (d->rel2.id_y == old_id && old_id != -1) d->rel2.id_y = id;
+         //TODO d->text.id_source ??
+         //TODO d->text.id_text_source ??
+      }
+   }
+   
+   edje_object_calc_force(obj);
+   
+   return TRUE;
+}
+
+EAPI unsigned char
+edje_edit_part_type_get(Evas_Object *obj, const char *part)
+{
+   GET_RP_OR_RETURN(0)
+   
+   return rp->part->type;
+}
+
+EAPI const char *
+edje_edit_part_selected_state_get(Evas_Object *obj, const char *part)
+{
+   char name[MAX_PATH];
+   
+   GET_RP_OR_RETURN(NULL)
+
+   if (!rp->chosen_description)
+      return "default 0.00";
+   
+   snprintf(name, MAX_PATH, "%s %.2f",
+            rp->chosen_description->state.name,
+            rp->chosen_description->state.value);
+   
+   return evas_stringshare_add(name);
+}
+
+EAPI unsigned char
+edje_edit_part_selected_state_set(Evas_Object *obj, const char *part, const char *state)
+{
+   Edje_Part_Description *pd;
+   
+   GET_RP_OR_RETURN(0)
+   
+   pd = _edje_part_description_find_byname(ed, part, state);
+   if (!pd) return 0;
+
+   printf("EDJE: Set state: %s\n",pd->state.name);
+   _edje_part_description_apply(ed, rp, pd->state.name, pd->state.value, NULL, 0); //WHAT IS NULL ,0 
+   
+   edje_object_calc_force(obj);
+   return 1;
+}
+
+EAPI unsigned char
+edje_edit_part_mouse_events_get(Evas_Object *obj, const char *part)
+{
+   GET_RP_OR_RETURN(0)
+   //printf("Get mouse_events for part: %s [%d]\n",part, rp->part->mouse_events);
+   return rp->part->mouse_events;
+}
+
+EAPI void
+edje_edit_part_mouse_events_set(Evas_Object *obj, const char *part, unsigned char mouse_events)
+{
+   GET_RP_OR_RETURN()
+   if (!rp->object) return;
+   printf("Set mouse_events for part: %s [%d]\n",part, mouse_events);
+   
+   rp->part->mouse_events = mouse_events ? 1 : 0;
+    
+   if (mouse_events)
+   {
+      evas_object_pass_events_set(rp->object, 0);
+      _edje_callbacks_add(rp->object, ed, rp);
+   }
+   else
+   {
+      evas_object_pass_events_set(rp->object, 1);
+      _edje_callbacks_del(rp->object);
+   }
+   
+}
+
+EAPI unsigned char
+edje_edit_part_repeat_events_get(Evas_Object *obj, const char *part)
+{
+   GET_RP_OR_RETURN(0)
+   //printf("Get repeat_events for part: %s [%d]\n",part, rp->part->repeat_events);
+   return rp->part->repeat_events;
+}
+
+EAPI void
+edje_edit_part_repeat_events_set(Evas_Object *obj, const char *part, unsigned char repeat_events)
+{
+   GET_RP_OR_RETURN()
+   if (!rp->object) return;
+   printf("Set repeat_events for part: %s [%d]\n",part, repeat_events);
+   
+   rp->part->repeat_events = repeat_events ? 1 : 0;
+    
+   if (repeat_events)
+   {
+      evas_object_repeat_events_set(rp->object, 1);
+   }
+   else
+   {
+      evas_object_repeat_events_set(rp->object, 0);
+   }
+   
+}
+
+/*********************/
+/*  PART STATES API  */
+/*********************/
+EAPI Evas_List *
+edje_edit_part_states_list_get(Evas_Object *obj, const char *part)
+{
+   Evas_List *states;
+   Evas_List *l;
+   Edje_Part_Description *state;
+   char state_name[MAX_PATH]; //TODO 4096?
+   
+   GET_RP_OR_RETURN(NULL)
+   
+   //Is there a better place to put this? maybe edje_edit_init() ?
+   setlocale(LC_NUMERIC, "C");
+   
+   states = NULL;
+   
+   //append default state
+   state = rp->part->default_desc;
+   snprintf(state_name, MAX_PATH,
+            "%s %.2f", state->state.name,state->state.value);
+   states = evas_list_append(states, evas_stringshare_add(state_name));
+   //printf("NEW STATE def: %s\n", state->state.name);  
+    
+   //append other states
+   l = rp->part->other_desc;
+   while (l)
+   {
+      state = l->data;
+      snprintf(state_name, sizeof(state_name),
+               "%s %.2f", state->state.name,state->state.value);
+      states = evas_list_append(states, evas_stringshare_add(state_name));
+      //printf("NEW STATE: %s\n", state_name);
+      l = l->next;
+   }
+   return states;
+}
+
+EAPI int
+edje_edit_state_name_set(Evas_Object *obj, const char *part, const char *state, const char *new_name)//state and new_name include the value in the string (ex. "default 0.00")
+{
+   char *delim;
+   double value;
+   
+   GET_PD_OR_RETURN(0)
+   printf("Set name of state: %s in part: %s [new name: %s]\n",
+          part, state, new_name);
+   
+   if (!new_name) return 0;
+   
+   /* split name from value */
+   delim = strrchr(new_name, (int)' ');
+   if (!delim) return 0;
+   if (sscanf(delim,"%lf", &value) != 1) return 0;
+   delim[0] = '\0';
+   
+   /* set name */
+   if (pd->state.name) evas_stringshare_del(pd->state.name);
+   pd->state.name = (char *)evas_stringshare_add(new_name);
+   /* set value */
+   pd->state.value = value;
+   
+   delim[0] = ' ';
+   printf("## SET OK %s %.2f\n", pd->state.name, pd->state.value);
+   return 1;
+}
+
+
+
+EAPI void
+edje_edit_state_del(Evas_Object *obj, const char *part, const char *state)
+{
+   printf("REMOVE STATE: %s IN PART: %s\n",state, part);
+   
+   GET_RP_OR_RETURN()
+   
+   Edje_Part_Description *pd;
+   pd = _edje_part_description_find_byname(ed, part, state);
+   if (!pd) return;
+   
+   rp->part->other_desc = evas_list_remove(rp->part->other_desc, pd);
+   
+   _edje_collection_free_part_description_free(pd);
+}
+
+EAPI void
+edje_edit_state_add(Evas_Object *obj, const char *part, const char *name)
+{
+   printf("ADD STATE: %s TO PART: %s\n", name , part);
+   
+   GET_RP_OR_RETURN();
+   
+   Edje_Part_Description *pd;
+   pd = mem_alloc(sizeof(Edje_Part_Description));
+   
+   if (!rp->part->default_desc)
+      rp->part->default_desc = pd;
+   else
+      rp->part->other_desc = evas_list_append(rp->part->other_desc, pd);
+   
+   pd->state.name = evas_stringshare_add(name);
+   pd->state.value = 0.0;
+   pd->visible = 1;
+   pd->align.x = 0.5;
+   pd->align.y = 0.5;
+   pd->min.w = 0;
+   pd->min.h = 0;
+   pd->fixed.w = 0;
+   pd->fixed.h = 0;
+   pd->max.w = -1;
+   pd->max.h = -1;
+   pd->rel1.relative_x = 0.0;
+   pd->rel1.relative_y = 0.0;
+   pd->rel1.offset_x = 0;
+   pd->rel1.offset_y = 0;
+   pd->rel1.id_x = -1;
+   pd->rel1.id_y = -1;
+   pd->rel2.relative_x = 1.0;
+   pd->rel2.relative_y = 1.0;
+   pd->rel2.offset_x = -1;
+   pd->rel2.offset_y = -1;
+   pd->rel2.id_x = -1;
+   pd->rel2.id_y = -1;
+   pd->image.id = -1;
+   pd->fill.smooth = 1;
+   pd->fill.pos_rel_x = 0.0;
+   pd->fill.pos_abs_x = 0;
+   pd->fill.rel_x = 1.0;
+   pd->fill.abs_x = 0;
+   pd->fill.pos_rel_y = 0.0;
+   pd->fill.pos_abs_y = 0;
+   pd->fill.rel_y = 1.0;
+   pd->fill.abs_y = 0;
+   pd->fill.angle = 0;
+   pd->fill.spread = 0;
+   pd->fill.type = EDJE_FILL_TYPE_SCALE;
+   pd->color_class = NULL;
+   pd->color.r = 255;
+   pd->color.g = 255;
+   pd->color.b = 255;
+   pd->color.a = 255;
+   pd->color2.r = 0;
+   pd->color2.g = 0;
+   pd->color2.b = 0;
+   pd->color2.a = 255;
+   pd->color3.r = 0;
+   pd->color3.g = 0;
+   pd->color3.b = 0;
+   pd->color3.a = 128;
+   pd->text.align.x = 0.5;
+   pd->text.align.y = 0.5;
+   pd->text.id_source = -1;
+   pd->text.id_text_source = -1;
+   pd->gradient.rel1.relative_x = 0;
+   pd->gradient.rel1.relative_y = 0;
+   pd->gradient.rel1.offset_x = 0;
+   pd->gradient.rel1.offset_y = 0;
+   pd->gradient.rel2.relative_x = 1;
+   pd->gradient.rel2.relative_y = 1;
+   pd->gradient.rel2.offset_x = -1;
+   pd->gradient.rel2.offset_y = -1;
+}
+
+//relative
+EAPI double
+edje_edit_state_rel1_relative_x_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   //printf("Get rel1 rel of part: %s state: %s [%f]\n",part,state,pd->rel1.relative_x);
+   return pd->rel1.relative_x;
+}
+
+EAPI double
+edje_edit_state_rel1_relative_y_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   //printf("Get rel1 rel of part: %s state: %s\n",part,state);
+   return pd->rel1.relative_y;
+}
+
+EAPI double
+edje_edit_state_rel2_relative_x_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   //printf("Get rel2 rel of part: %s state: %s\n",part,state);
+   return pd->rel2.relative_x;
+}
+
+EAPI double
+edje_edit_state_rel2_relative_y_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   //printf("Get rel2 rel of part: %s state: %s\n",part,state);
+   return pd->rel2.relative_y;
+}
+
+EAPI void
+edje_edit_state_rel1_relative_x_set(Evas_Object *obj, const char *part, const char *state, double x)
+{
+   GET_PD_OR_RETURN()
+   //printf("Set rel1x of part: %s state: %s to: %f\n", part, state, x);
+   //TODO check boudaries
+   pd->rel1.relative_x = x;
+   edje_object_calc_force(obj);
+}
+
+EAPI void
+edje_edit_state_rel1_relative_y_set(Evas_Object *obj, const char *part, const char *state, double y)
+{
+   GET_PD_OR_RETURN()
+   //printf("Set rel1y of part: %s state: %s to: %f\n", part, state, y);
+   //TODO check boudaries
+   pd->rel1.relative_y = y;
+   edje_object_calc_force(obj);
+}
+
+EAPI void
+edje_edit_state_rel2_relative_x_set(Evas_Object *obj, const char *part, const char *state, double x)
+{
+   GET_PD_OR_RETURN()
+   //printf("Set rel2x of part: %s state: %s to: %f\n", part, state, x);
+   //TODO check boudaries
+   pd->rel2.relative_x = x;
+   edje_object_calc_force(obj);
+}
+
+EAPI void
+edje_edit_state_rel2_relative_y_set(Evas_Object *obj, const char *part, const char *state, double y)
+{
+   GET_PD_OR_RETURN()
+   //printf("Set rel2y of part: %s state: %s to: %f\n", part, state, y);
+   pd = _edje_part_description_find_byname(ed, part, state);
+   //TODO check boudaries
+   pd->rel2.relative_y = y;
+   edje_object_calc_force(obj);
+}
+
+//offset
+EAPI int
+edje_edit_state_rel1_offset_x_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   //printf("Get rel1 offset of part: %s state: %s\n",part,state);
+   return pd->rel1.offset_x;
+}
+
+EAPI int
+edje_edit_state_rel1_offset_y_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   //printf("Get rel1 offset of part: %s state: %s\n",part,state);
+   return pd->rel1.offset_y;
+}
+
+EAPI int
+edje_edit_state_rel2_offset_x_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   //printf("Get rel2 offset of part: %s state: %s\n",part,state);
+   return pd->rel2.offset_x;
+}
+
+EAPI int
+edje_edit_state_rel2_offset_y_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   //printf("Get rel2 offset of part: %s state: %s\n",part,state);
+   return pd->rel2.offset_y;
+}
+
+EAPI void
+edje_edit_state_rel1_offset_x_set(Evas_Object *obj, const char *part, const char *state, double x)
+{
+   GET_PD_OR_RETURN()
+   printf("Set rel1x offset of part: %s state: %s to: %f\n", part, state, x);
+   //TODO check boudaries
+   pd->rel1.offset_x = x;
+   edje_object_calc_force(obj);
+}
+
+EAPI void
+edje_edit_state_rel1_offset_y_set(Evas_Object *obj, const char *part, const char *state, double y)
+{
+   GET_PD_OR_RETURN()
+   printf("Set rel1y offset of part: %s state: %s to: %f\n", part, state, y);
+   //TODO check boudaries
+   pd->rel1.offset_y = y;
+   edje_object_calc_force(obj);
+}
+
+EAPI void
+edje_edit_state_rel2_offset_x_set(Evas_Object *obj, const char *part, const char *state, double x)
+{
+   GET_PD_OR_RETURN()
+   printf("Set rel2x offset of part: %s state: %s to: %f\n", part, state, x);
+   //TODO check boudaries
+   pd->rel2.offset_x = x;
+   edje_object_calc_force(obj);
+}
+
+EAPI void
+edje_edit_state_rel2_offset_y_set(Evas_Object *obj, const char *part, const char *state, double y)
+{
+   GET_PD_OR_RETURN()
+   printf("Set rel2y offset of part: %s state: %s to: %f\n", part, state, y);
+   //TODO check boudaries
+   pd->rel2.offset_y = y;
+   edje_object_calc_force(obj);
+}
+
+//relative to
+EAPI const char *
+edje_edit_state_rel1_to_x_get(Evas_Object *obj, const char *part, const char *state)
+{
+   Edje_Real_Part *rel;
+   GET_PD_OR_RETURN(NULL)
+   //printf("Get rel1x TO of part: %s state: %s\n",part,state);
+   
+   if (pd->rel1.id_x == -1) return NULL;
+   
+   rel = ed->table_parts[pd->rel1.id_x % ed->table_parts_size];
+   
+   if (rel->part->name)
+      return evas_stringshare_add(rel->part->name);
+   else
+      return NULL;
+}
+
+EAPI const char *
+edje_edit_state_rel1_to_y_get(Evas_Object *obj, const char *part, const char *state)
+{
+   Edje_Real_Part *rel;
+   GET_PD_OR_RETURN(NULL)
+   //printf("Get rel1y TO of part: %s state: %s\n",part,state);
+
+   if (pd->rel1.id_y == -1) return NULL;
+   
+   rel = ed->table_parts[pd->rel1.id_y % ed->table_parts_size];
+   
+   if (rel->part->name)
+      return evas_stringshare_add(rel->part->name);
+   else
+      return NULL;
+}
+
+EAPI const char *
+edje_edit_state_rel2_to_x_get(Evas_Object *obj, const char *part, const char *state)
+{
+   Edje_Real_Part *rel;
+   GET_PD_OR_RETURN(NULL)
+   //printf("Get rel2x TO of part: %s state: %s\n",part,state);
+
+   if (pd->rel2.id_x == -1) return NULL;
+   
+   rel = ed->table_parts[pd->rel2.id_x % ed->table_parts_size];
+   
+   if (rel->part->name)
+      return evas_stringshare_add(rel->part->name);
+   else
+      return NULL;
+}
+
+EAPI const char *
+edje_edit_state_rel2_to_y_get(Evas_Object *obj, const char *part, const char *state)
+{
+   Edje_Real_Part *rel;
+   GET_PD_OR_RETURN(NULL)
+   //printf("Get rel2y TO of part: %s state: %s\n",part,state);
+
+   if (pd->rel2.id_y == -1) return NULL;
+   
+   rel = ed->table_parts[pd->rel2.id_y % ed->table_parts_size];
+   
+   if (rel->part->name)
+      return evas_stringshare_add(rel->part->name);
+   else
+      return NULL;
+}
+
+EAPI void
+//note after this call edje_edit_part_selected_state_set() to update !! need to fix this
+edje_edit_state_rel1_to_x_set(Evas_Object *obj, const char *part, const char *state, const char *rel_to)
+{
+   Edje_Real_Part *relp;
+   GET_PD_OR_RETURN()
+   printf("Set rel1 to x on state: %s (to part: )\n",state);
+   
+   if (rel_to)
+   {
+      relp = _edje_real_part_get(ed, rel_to);
+      if (!relp) return;
+         pd->rel1.id_x = relp->part->id;
+   }
+   else
+      pd->rel1.id_x = -1;
+   
+   //_edje_part_description_apply(ed, rp, pd->state.name, pd->state.value, "state", 0.1); //Why segfault??
+   // edje_object_calc_force(obj);//don't work for redraw
+}
+
+EAPI void
+//note after this call edje_edit_part_selected_state_set() to update !! need to fix this
+edje_edit_state_rel1_to_y_set(Evas_Object *obj, const char *part, const char *state, const char *rel_to)
+{
+   Edje_Real_Part *relp;
+   GET_PD_OR_RETURN()
+   
+   //printf("Set rel1 to y on state: %s (to part: %s)\n",state, rel_to);
+   
+   if (rel_to)
+   {
+      relp = _edje_real_part_get(ed, rel_to);
+      if (!relp) return;
+         pd->rel1.id_y = relp->part->id;
+   }
+   else
+      pd->rel1.id_y = -1;
+   
+   //_edje_part_description_apply(ed, rp, pd->state.name, pd->state.value, "state", 0.1); //Why segfault??
+   // edje_object_calc_force(obj);//don't work for redraw
+}
+
+EAPI void
+//note after this call edje_edit_part_selected_state_set() to update !! need to fix this
+edje_edit_state_rel2_to_x_set(Evas_Object *obj, const char *part, const char *state, const char *rel_to)
+{
+   Edje_Real_Part *relp;
+   GET_PD_OR_RETURN()
+   printf("Set rel2 to x on state: %s (to part: )\n",state);
+   
+   if (rel_to)
+   {
+      relp = _edje_real_part_get(ed, rel_to);
+      if (!relp) return;
+         pd->rel2.id_x = relp->part->id;
+   }
+   else
+      pd->rel2.id_x = -1;
+   
+   //_edje_part_description_apply(ed, rp, pd->state.name, pd->state.value, "state", 0.1); //Why segfault??
+   // edje_object_calc_force(obj);//don't work for redraw
+}
+
+EAPI void
+//note after this call edje_edit_part_selected_state_set() to update !! need to fix this
+edje_edit_state_rel2_to_y_set(Evas_Object *obj, const char *part, const char *state, const char *rel_to)
+{
+   Edje_Real_Part *relp;
+   GET_PD_OR_RETURN()
+   //printf("Set rel2 to y on state: %s (to part: %s)\n",state, rel_to);
+   
+   if (rel_to)
+   {
+      relp = _edje_real_part_get(ed, rel_to);
+      if (!relp) return;
+         pd->rel2.id_y = relp->part->id;
+   }
+   else
+      pd->rel2.id_y = -1;
+   
+   //_edje_part_description_apply(ed, rp, pd->state.name, pd->state.value, "state", 0.1); //Why segfault??
+   // edje_object_calc_force(obj);//don't work for redraw
+}
+
+//colors
+EAPI void
+edje_edit_state_color_get(Evas_Object *obj, const char *part, const char *state, int *r, int *g, int *b, int *a)
+{
+   GET_PD_OR_RETURN()
+   //printf("GET COLOR of state '%s'\n", state);
+   
+   if (r) *r = pd->color.r;
+   if (g) *g = pd->color.g;
+   if (b) *b = pd->color.b;
+   if (a) *a = pd->color.a;
+}
+
+EAPI void
+edje_edit_state_color2_get(Evas_Object *obj, const char *part, const char *state, int *r, int *g, int *b, int *a)
+{
+   GET_PD_OR_RETURN()
+   //printf("GET COLOR2 of state '%s'\n", state);
+   
+   if (r) *r = pd->color2.r;
+   if (g) *g = pd->color2.g;
+   if (b) *b = pd->color2.b;
+   if (a) *a = pd->color2.a;
+}
+
+EAPI void
+edje_edit_state_color3_get(Evas_Object *obj, const char *part, const char *state, int *r, int *g, int *b, int *a)
+{
+   GET_PD_OR_RETURN()
+   //printf("GET COLOR3 of state '%s'\n", state);
+
+   if (r) *r = pd->color3.r;
+   if (g) *g = pd->color3.g;
+   if (b) *b = pd->color3.b;
+   if (a) *a = pd->color3.a;
+}
+
+EAPI void
+edje_edit_state_color_set(Evas_Object *obj, const char *part, const char *state, int r, int g, int b, int a)
+{
+   GET_PD_OR_RETURN()
+   //printf("SET COLOR of state '%s'\n", state);
+
+   if (r > -1 && r < 256) pd->color.r = r;
+   if (g > -1 && g < 256) pd->color.g = g;
+   if (b > -1 && b < 256) pd->color.b = b;
+   if (a > -1 && a < 256) pd->color.a = a;
+    
+   edje_object_calc_force(obj);
+}
+
+EAPI void
+edje_edit_state_color2_set(Evas_Object *obj, const char *part, const char *state, int r, int g, int b, int a)
+{
+   GET_PD_OR_RETURN()
+   //printf("SET COLOR2 of state '%s'\n", state);
+
+   if (r > -1 && r < 256) pd->color2.r = r;
+   if (g > -1 && g < 256) pd->color2.g = g;
+   if (b > -1 && b < 256) pd->color2.b = b;
+   if (a > -1 && a < 256) pd->color2.a = a;
+    
+   edje_object_calc_force(obj);
+}
+
+EAPI void
+edje_edit_state_color3_set(Evas_Object *obj, const char *part, const char *state, int r, int g, int b, int a)
+{
+   GET_PD_OR_RETURN()
+   //printf("SET COLOR3 of state '%s'\n", state);
+
+   if (r > -1 && r < 256) pd->color3.r = r;
+   if (g > -1 && g < 256) pd->color3.g = g;
+   if (b > -1 && b < 256) pd->color3.b = b;
+   if (a > -1 && a < 256) pd->color3.a = a;
+    
+   edje_object_calc_force(obj);
+}
+
+//align
+EAPI double
+edje_edit_state_align_x_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   //printf("GET ALIGN_X of state '%s' [%f]\n", state, pd->align.x);
+   
+   return pd->align.x;
+}
+EAPI double
+edje_edit_state_align_y_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   //printf("GET ALIGN_Y of state '%s' [%f]\n", state, pd->align.y);
+   
+   return pd->align.y;
+}
+EAPI void
+edje_edit_state_align_x_set(Evas_Object *obj, const char *part, const char *state, double align)
+{
+   GET_PD_OR_RETURN()
+   printf("SET ALIGN_X of state '%s' [to: %f]\n", state, align);
+   pd->align.x = align;
+}
+EAPI void
+edje_edit_state_align_y_set(Evas_Object *obj, const char *part, const char *state, double align)
+{
+   GET_PD_OR_RETURN()
+   printf("SET ALIGN_Y of state '%s' [to: %f]\n", state, align);
+   pd->align.y = align;
+}
+//min & max
+EAPI int
+edje_edit_state_min_w_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   printf("GET MIN_W of state '%s' [%d]\n", state, pd->min.w);
+   return pd->min.w;
+}
+EAPI void
+edje_edit_state_min_w_set(Evas_Object *obj, const char *part, const char *state, int min_w)
+{
+   GET_PD_OR_RETURN()
+   printf("SET MIN_W of state '%s' [to: %d]\n", state, min_w);
+   pd->min.w = min_w;
+}
+EAPI int
+edje_edit_state_min_h_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   printf("GET MIN_H of state '%s' [%d]\n", state, pd->min.h);
+   return pd->min.h;
+}
+EAPI void
+edje_edit_state_min_h_set(Evas_Object *obj, const char *part, const char *state, int min_h)
+{
+   GET_PD_OR_RETURN()
+   printf("SET MIN_H of state '%s' [to: %d]\n", state, min_h);
+   pd->min.h = min_h;
+}
+
+EAPI int
+edje_edit_state_max_w_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   printf("GET MAX_W of state '%s' [%d]\n", state, pd->max.w);
+   return pd->max.w;
+}
+EAPI void
+edje_edit_state_max_w_set(Evas_Object *obj, const char *part, const char *state, int max_w)
+{
+   GET_PD_OR_RETURN()
+   printf("SET MAX_W of state '%s' [to: %d]\n", state, max_w);
+   pd->max.w = max_w;
+}
+EAPI int
+edje_edit_state_max_h_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   printf("GET MAX_H of state '%s' [%d]\n", state, pd->max.h);
+   return pd->max.h;
+}
+EAPI void
+edje_edit_state_max_h_set(Evas_Object *obj, const char *part, const char *state, int max_h)
+{
+   GET_PD_OR_RETURN()
+   printf("SET MAX_H of state '%s' [to: %d]\n", state, max_h);
+   pd->max.h = max_h;
+}
+//aspect
+EAPI double
+edje_edit_state_aspect_min_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   printf("GET ASPECT_MIN of state '%s' [%f]\n", state, pd->aspect.min);
+   return pd->aspect.min;
+}
+EAPI double
+edje_edit_state_aspect_max_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   printf("GET ASPECT_MAX of state '%s' [%f]\n", state, pd->aspect.max);
+   return pd->aspect.max;
+}
+EAPI void
+edje_edit_state_aspect_min_set(Evas_Object *obj, const char *part, const char *state, double aspect)
+{
+   GET_PD_OR_RETURN()
+   printf("SET ASPECT_MIN of state '%s' [to: %f]\n", state, aspect);
+   pd->aspect.min = aspect;
+}
+EAPI void
+edje_edit_state_aspect_max_set(Evas_Object *obj, const char *part, const char *state, double aspect)
+{
+   GET_PD_OR_RETURN()
+   printf("SET ASPECT_MAX of state '%s' [to: %f]\n", state, aspect);
+   pd->aspect.max = aspect;
+}
+EAPI unsigned char
+edje_edit_state_aspect_pref_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN()
+   printf("GET ASPECT_PREF of state '%s' [%d]\n", state, pd->aspect.prefer);
+   return pd->aspect.prefer;
+}
+EAPI void
+edje_edit_state_aspect_pref_set(Evas_Object *obj, const char *part, const char *state, unsigned char pref)
+{
+   GET_PD_OR_RETURN()
+   printf("SET ASPECT_PREF of state '%s' [to: %d]\n", state, pref);
+   pd->aspect.prefer = pref;
+}
+/**************/
+/*  TEXT API */
+/**************/
+
+EAPI const char*
+edje_edit_state_text_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN()
+   //printf("GET TEXT of state: %s\n", state);
+   
+   if (pd->text.text)
+      return evas_stringshare_add(pd->text.text);
+   
+   return NULL;
+}
+
+EAPI void
+edje_edit_state_text_set(Evas_Object *obj, const char *part, const char *state, const char *text)
+{
+   GET_PD_OR_RETURN()
+   //printf("SET TEXT of state: %s\n", state);
+   
+   if (!text) return;
+   
+   if (pd->text.text)
+      evas_stringshare_del(pd->text.text);
+   
+   pd->text.text = (char *)evas_stringshare_add(text);
+    
+   edje_object_calc_force(obj);
+}
+
+EAPI int
+edje_edit_state_text_size_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(-1)
+   //printf("GET TEXT_SIZE of state: %s [%d]\n", state, pd->text.size);
+   return pd->text.size;
+}
+
+EAPI void
+edje_edit_state_text_size_set(Evas_Object *obj, const char *part, const char *state, int size)
+{
+   GET_PD_OR_RETURN()
+   //printf("SET TEXT_SIZE of state: %s [%d]\n", state, size);
+   
+   if (size < 0) return;
+
+   pd->text.size = size;
+   
+   edje_object_calc_force(obj);
+}
+
+EAPI double
+edje_edit_state_text_align_x_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(0)
+   //printf("GET TEXT_ALIGN_X of state: %s [%f]\n", state, pd->text.align.x);
+   return pd->text.align.x;
+}
+
+EAPI void
+edje_edit_state_text_align_x_set(Evas_Object *obj, const char *part, const char *state, double align)
+{
+   GET_PD_OR_RETURN()
+   //printf("SET TEXT_ALIGN_X of state: %s [%f]\n", state, align);
+   
+   pd->text.align.x = align;
+   edje_object_calc_force(obj);
+}
+
+EAPI double
+edje_edit_state_text_align_y_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN()
+   //printf("GET TEXT_ALIGN_Y of state: %s [%f]\n", state, pd->text.align.x);
+   return pd->text.align.y;
+}
+
+EAPI void
+edje_edit_state_text_align_y_set(Evas_Object *obj, const char *part, const char *state, double align)
+{
+   GET_PD_OR_RETURN()
+   //printf("SET TEXT_ALIGN_Y of state: %s [%f]\n", state, align);
+   
+   pd->text.align.y = align;
+   edje_object_calc_force(obj);
+}
+
+EAPI Evas_List*
+edje_edit_fonts_list_get(Evas_Object *obj)
+{
+   Edje_Font_Directory_Entry *f;
+   Evas_List *fonts;
+   Evas_List *l;
+   
+   GET_ED_OR_RETURN(NULL)
+   
+   if (!ed->file) return NULL;
+   if (!ed->file->font_dir) return NULL;
+   
+   printf("GET FONT LIST for %s\n", ed->file->path);
+   
+   l = ed->file->font_dir->entries;
+   fonts = NULL;
+   while (l)
+   {
+      f = l->data;
+      fonts = evas_list_append(fonts, evas_stringshare_add(f->entry));
+      printf("   Font: %s (%s) \n", f->entry, f->path);
+      l = l->next;
+   }
+   
+   return fonts;
+}
+
+
+EAPI unsigned char
+edje_edit_font_add(Evas_Object *obj, const char* path)
+{
+   printf("ADD FONT: %s\n", path);
+   Font *fn;
+   Edje_Font_Directory_Entry *fnt;
+   Eet_File *eetf;
+   
+   GET_ED_OR_RETURN(0)
+   if (!path) return 0;
+   if (!ecore_file_can_read(path)) return 0;
+   if (!ed->file) return 0;
+   if (!ed->path) return 0;
+   
+   
+   /* Create Font_Directory if not exist */
+   if (!ed->file->font_dir)
+     ed->file->font_dir = mem_alloc(sizeof(Edje_Font_Directory));
+   
+   /* Create Font */
+   fn = mem_alloc(sizeof(Font));
+   if (!fn) return 0;
+   fn->file = (char *)ecore_file_file_get(path);
+   fn->name = (char *)ecore_file_file_get(path);
+   /*{
+      Evas_List *l;
+      
+      for (l = fonts; l; l = l->next)
+      {
+         Font *lfn;
+      
+         lfn = l->data;
+         if (!strcmp(lfn->name, fn->name))
+         {
+            free(fn->file);
+            free(fn->name);
+            free(fn);
+            return;
+         }
+      }
+   }
+   */
+   
+   /* Read font data from file */
+   FILE *f;
+   void *fdata = NULL;
+   int fsize = 0;
+   f = fopen(path, "rb");
+   if (f)
+   {
+      long pos;
+      
+      fseek(f, 0, SEEK_END);
+      pos = ftell(f);
+      rewind(f);
+      fdata = malloc(pos);
+      if (fdata)
+      {
+         if (fread(fdata, pos, 1, f) != 1)
+         {
+            fprintf(stderr, "Edje_Edit: Error. unable to read all of font file \"%s\"\n",
+                    path);
+            return 0;
+         }
+         fsize = pos;
+      }
+      fclose(f);
+   }
+   /* Write font to edje file */
+   char buf[4096];
+   snprintf(buf, sizeof(buf), "fonts/%s", fn->name);
+   
+   if (fdata)
+   {
+      /* open the eet file */
+      eetf = eet_open(ed->path, EET_FILE_MODE_READ_WRITE);
+      if (!eetf)
+      {
+         fprintf(stderr,
+                 "Edje_Edit: Error. unable to open \"%s\" for writing output\n",
+                 ed->path);
+         return 0;
+      }
+      
+      if (eet_write(eetf, buf, fdata, fsize, 1) <= 0)
+      {
+         fprintf(stderr, "Edje_Edit: Error. unable to write font part \"%s\" as \"%s\" part entry\n",
+                 path, buf);
+         eet_close(eetf);
+         free(fdata);
+         return 0;
+      }
+      
+      eet_close(eetf);
+      free(fdata);
+   }
+   
+   /* Create Edje_Font_Directory_Entry */
+   if (ed->file->font_dir)
+   {
+      fnt = mem_alloc(sizeof(Edje_Font_Directory_Entry));
+      fnt->entry = mem_strdup(fn->name);
+      fnt->path = mem_strdup(buf);
+      
+      ed->file->font_dir->entries = evas_list_append(ed->file->font_dir->entries, fnt);
+      ed->file->font_hash = evas_hash_direct_add(ed->file->font_hash, fnt->entry, fnt);
+   }
+   
+   
+   return 1;
+}
+
+EAPI const char*
+edje_edit_state_font_get(Evas_Object *obj, const char *part, const char *state)
+{
+   GET_PD_OR_RETURN(NULL)
+   printf("GET FONT of state: %s [%s]\n", state, pd->text.font);
+   if (!pd->text.font) return NULL;
+   return evas_stringshare_add(pd->text.font);
+}
+
+EAPI void
+edje_edit_state_font_set(Evas_Object *obj, const char *part, const char *state, const char *font)
+{
+   GET_PD_OR_RETURN()
+   printf("SET FONT of state: %s [%s]\n", state, font);
+   
+   if (pd->text.font) evas_stringshare_del(pd->text.font);
+   pd->text.font = (char *)evas_stringshare_add(font);
+    
+   edje_object_calc_force(obj);
+}
+
+EAPI unsigned char
+edje_edit_part_effect_get(Evas_Object *obj, const char *part)
+{
+   GET_RP_OR_RETURN(0)
+   printf("GET EFFECT of part: %s\n", part);
+   return rp->part->effect;
+}
+
+EAPI void
+edje_edit_part_effect_set(Evas_Object *obj, const char *part, unsigned char effect)
+{
+   GET_RP_OR_RETURN()
+   printf("SET EFFECT of part: %s [%d]\n", part, effect);
+   rp->part->effect = effect;
+   
+   edje_object_calc_force(obj);
+}
+
+/****************/
+/*  IMAGES API  */
+/****************/
+
+EAPI Evas_List*
+edje_edit_images_list_get(Evas_Object *obj)
+{
+   Edje_Image_Directory_Entry *i;
+   Evas_List *images;
+   Evas_List *l;
+   
+   GET_ED_OR_RETURN(NULL)
+   
+   if (!ed->file) return NULL;
+   if (!ed->file->image_dir) return NULL;
+   
+   printf("GET IMAGES LIST for %s\n", ed->file->path);
+   
+   l = ed->file->image_dir->entries;
+   images = NULL;
+   while (l)
+   {
+      i = l->data;
+      images = evas_list_append(images, evas_stringshare_add(i->entry));
+      printf("   Image: %s (type: %d param: %d id: %d) \n",
+             i->entry, i->source_type, i->source_param, i->id);
+      l = l->next;
+   }
+   
+   return images;
+}
+
+EAPI unsigned char
+edje_edit_image_add(Evas_Object *obj, const char* path)
+{
+   Evas_List *l;
+   Edje_Image_Directory_Entry *de;
+   int free_id;
+
+
+    
+   GET_ED_OR_RETURN(0)
+   if (!path) return 0;
+   if (!ed->file) return 0;
+   if (!ed->path) return 0;
+   
+   /* Create Image_Directory if not exist */
+   if (!ed->file->image_dir)
+     ed->file->image_dir = mem_alloc(sizeof(Edje_Image_Directory));
+   
+   /* Loop trough image directory to find if image exist */
+   printf("Add Image '%s' (total %d)\n", path,
+          evas_list_count(ed->file->image_dir->entries));
+   free_id = 0;
+   for (l = ed->file->image_dir->entries; l; l = l->next)
+   {
+      Edje_Image_Directory_Entry *i;
+      i = l->data;
+      if (!i) return 0;
+      if (i->id >= free_id) free_id = i->id + 1; /*TODO search for free (hole) id*/
+      printf("IMG: %s [%d]\n", i->entry, i->id);
+   }
+   printf("FREE ID: %d\n", free_id);
+   
+   /* Import image */
+   if (!_edje_import_image_file(ed, path, free_id))
+      return 0;
+   
+   /* Create Image Entry */
+   de = mem_alloc(sizeof(Edje_Image_Directory_Entry));
+   de->entry = mem_strdup(ecore_file_file_get(path)); //TODO need strdup??
+   de->id = free_id;
+   de->source_type = 1;
+   de->source_param = 1;
+   
+   /* Add image to Image Directory */
+   ed->file->image_dir->entries =
+        evas_list_append(ed->file->image_dir->entries, de);
+   
+   return 1;
+}
+
+EAPI int
+edje_edit_image_id_get(Evas_Object *obj, const char *image_name)
+{
+   return _edje_image_id_find(obj, image_name);
+}
+
+EAPI const char*
+edje_edit_state_image_get(Evas_Object *obj, const char *part, const char *state)
+{
+   char *image;
+   GET_PD_OR_RETURN(NULL)
+   
+   image = (char *)_edje_image_name_find(obj, pd->image.id);
+   if (!image) return NULL;
+   
+   //printf("GET IMAGE for %s [%s]\n", state, image);
+   return evas_stringshare_add(image);
+}
+
+EAPI void
+edje_edit_state_image_set(Evas_Object *obj, const char *part, const char *state, const char *image)
+{
+   int id;
+   GET_PD_OR_RETURN()
+   
+   if (!image) return;
+    
+   id = _edje_image_id_find(obj, image);
+   printf("SET IMAGE for %s [%s]\n", state, image);
+   
+   if (id > -1) pd->image.id = id;
+   
+   edje_object_calc_force(obj);
+}
+
+EAPI Evas_List*
+edje_edit_state_tweens_list_get(Evas_Object *obj, const char *part, const char *state)
+{
+   Edje_Part_Image_Id *i;
+   Evas_List *tweens, *l;
+   const char *name;
+   GET_PD_OR_RETURN(NULL)
+   //printf("GET TWEEN LIST for %s\n", state);
+   
+   l = pd->image.tween_list;
+   tweens = NULL;
+   while (l)
+   {
+      i = l->data;
+      name = _edje_image_name_find(obj, i->id);
+      //printf("   t: %s\n", name);
+      tweens = evas_list_append(tweens, evas_stringshare_add(name));
+      l = l->next;
+   }
+   
+   return tweens;
+}
+
+EAPI unsigned char
+edje_edit_state_tween_add(Evas_Object *obj, const char *part, const char *state, const char *tween)
+{
+   Edje_Part_Image_Id *i;
+   int id;
+   GET_PD_OR_RETURN(0)
+   
+   id = _edje_image_id_find(obj, tween);
+   if (id < 0) return 0;
+   
+   /* alloc Edje_Part_Image_Id */
+   i = mem_alloc(SZ(Edje_Part_Image_Id));
+   if (!i) return 0;
+   i->id = id;
+   
+   /* add to tween list */
+   pd->image.tween_list = evas_list_append(pd->image.tween_list, i);
+
+   return 1;
+}
+
+EAPI unsigned char
+edje_edit_state_tween_del(Evas_Object *obj, const char *part, const char *state, const char *tween)
+{
+   Evas_List *l;
+   int id;
+   GET_PD_OR_RETURN(0)
+
+   if (!pd->image.tween_list) return 0;
+   
+   id = _edje_image_id_find(obj, tween);
+   if (id < 0) return 0;
+   
+   l = pd->image.tween_list;
+   while (l)
+   {
+      Edje_Part_Image_Id *i;
+      i = l->data;
+      if (i->id == id)
+      {
+         pd->image.tween_list = evas_list_remove_list(pd->image.tween_list, l);
+         return 1;
+      }
+      l = l->next;
+   }
+   return 0;
+}
+
+EAPI void
+edje_edit_state_image_border_get(Evas_Object *obj, const char *part, const char *state, int *l, int *r, int *t, int *b)
+{
+   GET_PD_OR_RETURN()
+   //printf("GET IMAGE_BORDER of state '%s'\n", state);
+   
+   if (l) *l = pd->border.l;
+   if (r) *r = pd->border.r;
+   if (t) *t = pd->border.t;
+   if (b) *b = pd->border.b;
+}
+
+EAPI void
+edje_edit_state_image_border_set(Evas_Object *obj, const char *part, const char *state, int l, int r, int t, int b)
+{
+   GET_PD_OR_RETURN()
+   //printf("SET IMAGE_BORDER of state '%s'\n", state);
+
+   if (l > -1) pd->border.l = l;
+   if (r > -1) pd->border.r = r;
+   if (t > -1) pd->border.t = t;
+   if (b > -1) pd->border.b = b;
+    
+   edje_object_calc_force(obj);
+}
+
+/******************/
+/*  PROGRAMS API  */
+/******************/
+
+EAPI Evas_List *
+edje_edit_programs_list_get(Evas_Object *obj)
+{
+   Evas_List *progs;
+   int i;
+   
+   GET_ED_OR_RETURN(NULL)
+   
+   printf("EE: Found %d programs\n", ed->table_programs_size);
+   
+   progs = NULL;
+   for (i = 0; i < ed->table_programs_size; i++)
+   {
+      Edje_Program *epr;
+      epr = ed->table_programs[i];
+      progs = evas_list_append(progs, evas_stringshare_add(epr->name));
+   }
+
+   return progs;
+}
+
+Edje_Program*
+_edje_program_get_byname(Evas_Object *obj, const char *prog_name)
+{
+   Edje_Program *epr;
+   int i;
+   
+   GET_ED_OR_RETURN(NULL)
+
+   for (i = 0; i < ed->table_programs_size; i++)
+   {
+      epr = ed->table_programs[i];
+      if (strcmp(epr->name, prog_name) == 0)
+         return epr;
+   }
+   return NULL;
+}
+
+EAPI const char*
+edje_edit_program_source_get(Evas_Object *obj, const char *prog)
+{
+   GET_EPR_OR_RETURN(NULL)
+    
+   if (!epr->source) return NULL;
+   printf("GET SOURCE for program: %s [%s]\n", prog, epr->source);
+   return evas_stringshare_add(epr->source);
+}
+
+EAPI const char*
+edje_edit_program_signal_get(Evas_Object *obj, const char *prog)
+{
+   GET_EPR_OR_RETURN(NULL)
+    
+   if (!epr->signal) return NULL;
+   printf("GET SIGNAL for program: %s [%s]\n", prog, epr->signal);
+   return evas_stringshare_add(epr->signal);
+}
+
+EAPI const char*
+edje_edit_program_state_get(Evas_Object *obj, const char *prog)
+{
+   GET_EPR_OR_RETURN(NULL)
+   
+   if (!epr->state) return NULL;
+   printf("GET STATE for program: %s [%s %.2f]\n", prog, epr->state, epr->value);
+   return evas_stringshare_add(epr->state);
+}
+
+EAPI const char*
+edje_edit_program_state2_get(Evas_Object *obj, const char *prog)
+{
+   GET_EPR_OR_RETURN(NULL)
+   
+   if (!epr->state2) return NULL;
+   printf("GET STATE2 for program: %s [%s %.2f]\n", prog, epr->state2, epr->value2);
+   return evas_stringshare_add(epr->state2);
+}
+
+EAPI double
+edje_edit_program_value_get(Evas_Object *obj, const char *prog)
+{
+   GET_EPR_OR_RETURN(-1)
+   
+   printf("GET VALUE for program: %s [%s %.2f]\n", prog, epr->state, epr->value);
+   return epr->value;
+}
+
+EAPI double
+edje_edit_program_value2_get(Evas_Object *obj, const char *prog)
+{
+   GET_EPR_OR_RETURN(-1)
+   
+   printf("GET VALUE2 for program: %s [%s %.2f]\n", prog, epr->state2, epr->value2);
+   return epr->value2;
+}
+
+EAPI double
+edje_edit_program_in_from_get(Evas_Object *obj, const char *prog)
+{
+   GET_EPR_OR_RETURN(0)
+   printf("GET IN.FROM for program: %s [%f]\n", prog, epr->in.from);
+   return epr->in.from;
+}
+
+EAPI double
+edje_edit_program_in_range_get(Evas_Object *obj, const char *prog)
+{
+   GET_EPR_OR_RETURN(0)
+   printf("GET IN.RANGE for program: %s [%f]\n", prog, epr->in.range);
+   return epr->in.range;
+}
+
+EAPI int
+edje_edit_program_transition_get(Evas_Object *obj, const char *prog)
+{
+   GET_EPR_OR_RETURN(-1)
+   printf("GET TRANSITION for program: %s [%d]\n", prog, epr->tween.mode);
+   return epr->tween.mode;
+}
+
+EAPI double
+edje_edit_program_transition_time_get(Evas_Object *obj, const char *prog)
+{
+   GET_EPR_OR_RETURN(-1)
+   printf("GET TRANSITION_TIME for program: %s [%.4f]\n", prog, epr->tween.time);
+   return epr->tween.time;
+}
+
+EAPI int
+edje_edit_program_action_get(Evas_Object *obj, const char *prog)
+{
+   GET_EPR_OR_RETURN(-1)
+   printf("GET ACTION for program: %s [%d]\n", prog, epr->action);
+   return epr->action;
+}
+
+EAPI Evas_List*
+edje_edit_program_targets_get(Evas_Object *obj, const char *prog)
+{
+   Evas_List *l, *targets;
+   
+   GET_ED_OR_RETURN(NULL)
+   GET_EPR_OR_RETURN(NULL)
+   
+   printf("GET TARGETS for program: %s [count: %d]\n", prog, evas_list_count(epr->targets));
+   
+   l = epr->targets;
+   targets = NULL;
+   while (l)
+   {
+      Edje_Program_Target *t;
+      Edje_Real_Part *p = NULL;
+      
+      t = l->data;
+      p = ed->table_parts[t->id % ed->table_parts_size];
+      if (p && p->part && p->part->name)
+      {
+         printf("   t: %d name: %s\n", t->id, p->part->name);
+         targets = evas_list_append(targets, evas_stringshare_add(p->part->name));
+      }
+      l = l->next;
+   }
+   return targets;
+}
+
+EAPI Evas_List*
+edje_edit_program_afters_get(Evas_Object *obj, const char *prog)
+{
+   Evas_List *l, *afters;
+   
+   GET_ED_OR_RETURN(NULL)
+   GET_EPR_OR_RETURN(NULL)
+   
+   printf("GET AFTERS for program: %s [count: %d]\n", prog, evas_list_count(epr->after));
+   
+   l = epr->after;
+   afters = NULL;
+   while (l)
+   {
+      Edje_Program_After *a;
+      Edje_Program *p = NULL;
+      
+      a = l->data;
+      p = ed->table_programs[a->id % ed->table_programs_size];
+      if (p && p->name)
+      {
+         printf("   a: %d name: %s\n", a->id, p->name);
+         afters = evas_list_append(afters, evas_stringshare_add(p->name));
+      }
+      l = l->next;
+   }
+   return afters;
+}
+
+/*************************/
+/*  EMBRYO SCRIPTS  API  */
+/*************************/
+
+EAPI const char*
+edje_edit_script_get(Evas_Object *obj)
+{
+   Embryo_Program   *script = NULL;
+   
+   GET_ED_OR_RETURN(NULL)
+   
+   if (!ed->collection) return NULL;
+   if (!ed->collection->script) return NULL;
+   
+   script = ed->collection->script;
+   
+   printf("Get Script [%d] %d\n",script, embryo_program_recursion_get(script));
+   
+   
+   
+   return "ashdashd";
+}
+
+
+
+
+#define ABORT_WRITE2(eet_file) \
+   eet_close(eet_file); \
+   return 0;
+
+
+EAPI int
+edje_edit_save(Evas_Object *obj)
+{
+   Edje_File *ef;
+   Eet_File *eetf;
+   int bytes;
+   char buf[256];
+   char *progname = "Edje_Edit";
+    
+   GET_ED_OR_RETURN(0)
+   
+   ef = ed->file;
+   if (!ef) return 1;
+     
+
+   printf("***********  Saving file ******************\n");
+   printf("** path: %s\n", ef->path);
+   
+   eetf = eet_open(ef->path, EET_FILE_MODE_READ_WRITE);
+   if (!eetf)
+   {
+      fprintf(stderr, "%s: Error. unable to open \"%s\" for writing output\n",
+      progname, ef->path);
+      return 0;
+   }
+   
+   printf("** Writing Edje_File* ed->file\n");
+   bytes = eet_data_write(eetf, _edje_edd_edje_file, "edje_file", ef, 1);
+   if (bytes <= 0)
+   {
+      fprintf(stderr, "%s: Error. unable to write \"edje_file\" "
+                      "entry to \"%s\" \n", progname, ef->path);
+      ABORT_WRITE2(eetf);
+   }
+
+   if (ed->collection)
+   {
+      printf("** Writing Edje_Part_Collection* ed->collection "
+             "[id: %d]\n", ed->collection->id);
+      
+      snprintf(buf, sizeof(buf), "collections/%i", ed->collection->id);
+    
+      bytes = eet_data_write(eetf, _edje_edd_edje_part_collection,
+                             buf, ed->collection, 1);
+      if (bytes <= 0)
+      {
+         fprintf(stderr, "%s: Error. unable to write \"%s\" part entry to %s \n",
+                  progname, buf, ef->path);
+         ABORT_WRITE2(eetf);
+      }
+   }
+   
+   eet_close(eetf);
+   printf("***********  Saving DONE ******************\n");
+   return 1;
+}
+
Index: src/lib/edje_load.c
===================================================================
RCS file: /cvs/e/e17/libs/edje/src/lib/edje_load.c,v
retrieving revision 1.111
diff -u -r1.111 edje_load.c
--- src/lib/edje_load.c	18 Jan 2008 06:34:04 -0000	1.111
+++ src/lib/edje_load.c	16 Feb 2008 16:53:14 -0000
@@ -5,7 +5,7 @@
 #include "Edje.h"
 #include "edje_private.h"
 
-static void _edje_collection_free_part_description_free(Edje_Part_Description *desc);
+void _edje_collection_free_part_description_free(Edje_Part_Description *desc);
 static Evas_Bool _edje_file_collection_hash_foreach(Evas_Hash *hash, const char *key, void *data, void *fdata);
 #ifdef EDJE_PROGRAM_CACHE
 static int  _edje_collection_free_prog_cache_matches_free_cb(Evas_Hash *hash, const char *key, void *data, void *fdata);
@@ -916,7 +916,7 @@
    free(ec);
 }
 
-static void
+void
 _edje_collection_free_part_description_free(Edje_Part_Description *desc)
 {
    if (desc->state.name) evas_stringshare_del(desc->state.name);
