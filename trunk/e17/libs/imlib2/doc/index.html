<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.72 [en] (X11; U; Linux 2.2.16-3ext3 i686) [Netscape]">
   <meta name="Author" content="The Rasterman">
   <title>Imlib 2 - Documentation.</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EF" vlink="#51188E" alink="#FFFF00">

<center>
<h1>
<img SRC="imlib2.gif" ALT="Imlib2" height=128 width=256></h1></center>

<center><table BORDER=0 CELLSPACING=0 WIDTH="95%" BGCOLOR="#666666" NOSAVE ROWS="5" >
<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td ALIGN=CENTER VALIGN=CENTER NOSAVE><b><font color="#FFFFFF"><font size=+2>What
is it?</font></font></b></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td><img SRC="blank.gif" height=1 width=1></td>

<td VALIGN=TOP HEIGHT="100%" BGCOLOR="#CCCCCC" NOSAVE>Imlib 2 is the successor
to Imlib. It is NOT a newer version - it is a completely new library. Imlib
2 can be installed alongside Imlib 1.x without any problems since they
are effectively different libraries - BUT they Have very similar functionality.
<p>Imlib 2 does the following:
<ul>
<li>
Load image files from disk in one of many formats</li>

<li>
Save images to disk in one of many formats</li>

<li>
Render image data onto other images</li>

<li>
Render images to an X-Windows drawable</li>

<li>
Produce pixmaps and pixmap masks of Images</li>

<li>
Apply filters to images</li>

<li>
Rotate images</li>

<li>
Accept RGBA Data for images</li>

<li>
Scale images</li>

<li>
Alpha blend Images on other images or drawables</li>

<li>
Apply color correction and modification tables and factors to images</li>

<li>
Render images onto images with color correction and modification tables</li>

<li>
Render truetype anti-aliased text</li>

<li>
Render truetype anti-aliased text at any angle</li>

<li>
Render anti-aliased lines</li>

<li>
Render rectangles</li>

<li>
Render linear multi-coloured gradients</li>

<li>
Cache data intelligently for maximum performance</li>

<li>
Allocate colours automatically</li>

<li>
Allow full control over caching and colour allocation</li>

<li>
Provide highly optimized MMX assembly for core routines</li>

<li>
Provide plug-in filter interface</li>

<li>
Provide on-the-fly runtime plug-in image loading and saving interface</li>

<li>
Fastest image compositing, rendering and manipulation library for X</li>
</ul>
If what you want isn't in the list above somewhere then likely Imlib 2
does not do it. If it does it it likely does it faster than any other library
you can find (this includes gdk-pixbuf, gdkrgb, etc.) primarily because
of highly optimized code and a smart subsystem that does the dirty work
for you and picks up the pieces for you so you can be lazy and let all
the optimizations for FOR you.
<p>Imlib 2 can run without a display, so it can be easily used for background
image processing for websites or servers - it onyl requires the X libraries
to be installed - that is all - it does not require an Xserver to run unless
you wish to display images.
<p>The interface is simple - once you get used to it, the functions do
exactly what they say they do.</td>

<td><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>
</table></center>

<br>&nbsp;
<center><table BORDER=0 CELLSPACING=0 WIDTH="95%" BGCOLOR="#666666" NOSAVE ROWS="5" >
<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td ALIGN=CENTER VALIGN=CENTER NOSAVE><b><font color="#FFFFFF"><font size=+2>A
Simple Example</font></font></b></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td><img SRC="blank.gif" height=1 width=1></td>

<td VALIGN=TOP HEIGHT="100%" BGCOLOR="#CCCCCC" NOSAVE>The best way to start
is to show a simple example of an Imlib2 program. This one will load an
image of any format you have a loader installed for (all loaders are dynamic
code objects that imlib2 will use and update automatically runtime - anyone
is free to write a loader. All that has to be done is for the object to
be dropped into the loaders directory with the others and all imlib2 programs
will automatically be able to use it - without a restart).
<pre><tt><font color="#660000">/* standard headers */
#include &lt;X11/Xlib.h>
#include &lt;Imlib2.h>
#include &lt;stdio.h>
#include &lt;string.h>

/* main program */
int main(int argc, char **argv)
{
&nbsp; /* an image handle */
&nbsp; Imlib_Image image;
&nbsp;&nbsp;
&nbsp; /* if we provided &lt; 2 arguments after the command - exit */
&nbsp; if (argc != 3) exit(1);
&nbsp; /* load the image */
&nbsp; image = imlib_load_image(argv[1]);
&nbsp; /* if the load was successful */
&nbsp; if (image)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* set the image we loaded as the current context image to work on */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imlib_context_set_image(image);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* set the image format to be the format of the extension of our last */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* argument - ie .png = png, .tif = tiff etc. */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imlib_image_set_format(strrchr(argv[2], '.') + 1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* save the image */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imlib_save_image(argv[2]);
&nbsp;&nbsp;&nbsp; }
}</font></tt></pre>
Now to compile this
<pre><tt><font color="#000099">cc imlib2_convert.c -o imlib2_convert `imlib2-config --cflags` `imlib2-config --libs`</font></tt></pre>
You now have a program that if used as follows:
<pre><tt><font color="#000099">./imlib2_convert image1.jpg image2.png</font></tt></pre>
will convert image1.jpg into a png called image2.png. It is that simple.</td>

<td><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>
</table></center>

<br>&nbsp;
<center><table BORDER=0 CELLSPACING=0 WIDTH="95%" BGCOLOR="#666666" NOSAVE ROWS="5" >
<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td ALIGN=CENTER VALIGN=CENTER NOSAVE><b><font color="#FFFFFF"><font size=+2>How
Image Loading Works</font></font></b></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td><img SRC="blank.gif" height=1 width=1></td>

<td VALIGN=TOP HEIGHT="100%" BGCOLOR="#CCCCCC" NOSAVE>It is probably a
good idea to discuss how Imlib2 actually loads an Image so the programmer
knows what is going on, how to take advantage of the optimizations already
there and to explain why things work as they do.
<br>&nbsp;
<blockquote>
<h3>
Loading using imlib_load_image();</h3>
This is likey to be by far the most common way to load an image - when
you don't really care about the details of the loading process or why it
failed - all you care about is if you got a valid image handle.
<p>When you call this function Imlib2 attempts to find the file specified
as the parameter. This will involve Imlib2 first checking to see if that
file path already has been loaded and is in Imlib2's cache (a cache of
already decoded images in memory to save having to load and decode from
disk all the time). If there alrady is a copy in the cache (either already
active or speculatively cached from a previous load &amp; free) this copy
will have its handle returned instead of Imlib2 checking on disk (in some
circumstances this is not true - see later in this section to find out).
This means if your program blindly loads an Image, renders it, then frees
it - then soon afterwards loads the same image again, it will not be loaded
from disk at all, instead it will simply be re-refernced from the cache
- meaning the load will be almost instant. A great way to take full advantage
of this is to set the cache to some size you are happy with for the image
data being used by yout application and then all rendering o an image follows
the pseudocode:
<pre><tt><font color="#006600">set cache to some amount (eg 4 Mb)
...
rendering loop ...
&nbsp;&nbsp;&nbsp; load image
&nbsp;&nbsp;&nbsp; render image
&nbsp;&nbsp;&nbsp; free image
... continue loop</font></tt></pre>
This may normally sound silly - load image, render then free - EVERY time
we want to use it, BUT - it is actually the smartest way to use Imlib2
- since the caching will find the image for you in the cache - you do not
need to manage your own cache, or worry about filling up memory with image
data - only as much memory as you have set for the cache sizae will actually
ever be used to store image data - if you have lots of image data to work
with then increase the cache size for better perfromance, but this is the
only thing you need to worry about. you won't have problems fo accidentally
forgetting to free images later since you free them immediately after use.
<p>Now what happens if the file changes on disk while it's in cahe? By
default nothing. The file is ignored. This is an optimization (to avoid
hitting the disk to check if the file changed for every load if it's cached).
You can inform Imlib2 that you care about this by using the <tt><font color="#660000">imlib_image_set_changes_on_disk();
</font></tt><font color="#000000">call.
Do this whenever you load an Image that you expect will change on disk,
and the fact that it changes really matters. Remember this will marginally
reduce the caching performance.</font>
<p><font color="#000000">Now what actually happens when we try and load
an image using a filename? First the filename is broken down into 2 parts.
the filename before a colon (:) and the key after the colon. This means
when we have a filename like:</font>
<p><tt><font color="#000099">/path/to/file.jpg</font></tt>
<p><font color="#000000">the filename is:</font>
<p><tt><font color="#000099">/path/to/file.jpg</font></tt>
<p><font color="#000000">and the key is blank. If we have:</font>
<p><tt><font color="#000099">/path/to/file.db:key.value/blah</font></tt>
<p><font color="#000000">the filename is:</font>
<p><tt><font color="#000099">/path/to/file.db</font></tt>
<p><font color="#000000">and the key is:</font>
<p><tt><font color="#000099">key.value/blah</font></tt>
<p><font color="#000000">You may ask what is this thing with keys and filenames?
Well Imlib2 has loaders that are able to load data that is WITHIN a file
(the loader capable of this right now is the database loader that is able
to laod image data stroed with a key in a berkley-db database file). The
colon is used to delimit where the filename ends and the key begins. Fro
the majority of files you load you won't have to worry, but there is a
limit in this case that filenames cannot contain a color character.</font>
<p><font color="#000000">First Imlib2 checks to see if the file exists
and that you have permission to read it. If this fails it will abort the
load. Now that it has checked that this is the case it evaulates that it's
list of dynamically loaded loader modules it up to date then it runs through
the loader modules until one of them claims it can load this file. If this
is the case&nbsp; that loader is now used to decode the image and return
an Image handle to the calling program. If the loader is written correctly
and the file format sanely supports this, the laoder will NOT decode any
image data at this point. It will ONLY read the header of the image to
figure out its size, if it has an alpha channel, format and any other header
information. The loader is rememebred and it will be re-used to load the
image data itself later if and ONLY if the actual image data itself is
needed. This means you can scan vast directories of files figuring their
format and size and other such information just by loading and freeing
- and it will be fast because no image data is decoded. You can take advantage
of this by loading the image anc checkign its size to calculate the size
of an output area before you vere load the data. This means&nbsp; geometry
calculations can be doen fast ahead of time.</font>
<p><font color="#000000">If you desire more detailed information about
why a load failed you can use </font><tt><font color="#000099">imlib_load_image_with_error_return();
</font></tt><font color="#000000">and
it will return a detailed error return code.</font>
<p><font color="#000000">If you do not wish to have the image data loaded
later using the optimized "deferred" method of loading, you can force the
data to be decoded immediately with </font><tt><font color="#000099">imlib_load_image_immediately();</font></tt>
<p><font color="#000000">If you wish to bypass the cache when loading images
you can using </font><tt><font color="#000099">imlib_load_image_without_cache();
</font></tt><font color="#000000">and
</font><tt><font color="#000099">imlib_load_image_immediately_without_cache();</font></tt><font color="#000000">.</font>
<p><font color="#000000">Sometimes loading images can take a while. Often
it is a good idea to provide feedback to the user whilst this is happening.
This is when you set the progress function callback. Setting this to NULL
will mean no progress function is called during load - this is the default.
When it is set you set it to a function that will get called every so often
(depending on the progress granularity) during load. Use </font><tt><font color="#000099">imlib_context_set_progress_function();</font></tt><font color="#000000">
and </font><tt><font color="#000099">imlib_context_set_progress_granularity();
</font></tt><font color="#000000">to
set this up.</font></blockquote>
</td>

<td><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>
</table></center>

<br>&nbsp;
<center><table BORDER=0 CELLSPACING=0 WIDTH="95%" BGCOLOR="#666666" NOSAVE ROWS="5" >
<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td ALIGN=CENTER VALIGN=CENTER NOSAVE><b><font color="#FFFFFF"><font size=+2>Title</font></font></b></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td><img SRC="blank.gif" height=1 width=1></td>

<td VALIGN=TOP HEIGHT="100%" BGCOLOR="#CCCCCC" NOSAVE>Hello</td>

<td><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>
</table></center>

<br>&nbsp;
<center><table BORDER=0 CELLSPACING=0 WIDTH="95%" BGCOLOR="#666666" NOSAVE ROWS="5" >
<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td ALIGN=CENTER VALIGN=CENTER NOSAVE><b><font color="#FFFFFF"><font size=+2>API
Reference</font></font></b></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td>
<pre><img SRC="blank.gif" height=1 width=1></pre>
</td>

<td VALIGN=TOP HEIGHT="100%" BGCOLOR="#CCCCCC" NOSAVE>
<p>
This is a list of all the Imlib2 API calls and what each of them do. You
should familiarise yourself well with this API so you have a good idea of
what can be done.
<p>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_display(Display *display);
</font></font></tt></b></pre>
<blockquote>
Sets the current X display to be used for rendering of images to drawables.
You do not need to set this if you do not intend to render an image to an X
drawable. If you do you will need to set this. If you change displays just
set this to the new display pointer. Do not use a Display pointer if
you have closed that display already - also note that if you close a display
connection and continue to render using Imlib2 without setting the display
pointer to NULL or something new, crashes may occur.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_visual(Visual *visual);
</font></font></tt></b></pre>
<blockquote>
This sets the current visual to use when rendering images to drawables or
producing pixmaps. You need to set this for anything to render to a
drawable or produce any pixmaps (this can be the default visual).
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_colormap(Colormap colormap);
</font></font></tt></b></pre>
<blockquote>
Sets the colormap to use when rendering to drawables and allocating colours.
You must set this to the colormap you are using to render any images or 
produce any pixmaps (this can be the default colormap).
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_drawable(Drawable drawable);
</font></font></tt></b></pre>
<blockquote>
This sets the X drawable to wich images will be rendered when you call a
render call in Imlib2. This may be either a pixmap or a window. You must set
this to render anything.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_mask(Pixmap mask);
</font></font></tt></b></pre>
<blockquote>
This sets the 1-bit deep pixmap to be drawn to when rendering to generate a
mask pixmap. This is only useful if the image you are rendering has alpha.
Set this to 0 to not render a pixmap mask.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_dither_mask(char dither_mask);
</font></font></tt></b></pre>
<blockquote>
Selects if, you are rendering to a mask, or producing pixmap masks from
images, if the mask is to be dithered or not. passing in 1 for dither_mask
means the mask pixmap will be dithered, 0 means it will not be dithered.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_anti_alias(char anti_alias);
</font></font></tt></b></pre>
<blockquote>
Toggles "anit-aliased" scaling of images. This isn't quite correct since
it's actually super and sub pixel sampling that it turns on and off, but
anti-aliasing is used for having "smooth" edges to lines and shapes and
this means when images are scaled they will keep their smooth appearance.
Passing in 1 turns this on and 0 turns it off.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_dither(char dither);
</font></font></tt></b></pre>
<blockquote>
Sets the dithering flag for rendering to a drawable or when pixmaps are
produced. This affects the color image appearance by enabling dithering.
Dithering slows down rendering but produces considrably better results. this
option has no effect foe rendering in 24 bit and up, but in 16bit and lower
it will dither, producing smooht gradients and much better quality images.
setting dither to 1 enables it and 0 disables it.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_blend(char blend);
</font></font></tt></b></pre>
<blockquote>
When rendering an image to a drawable, imlib2 is able to blend the image
directly onto the drawable during rendering. setting this to 1 will enable
this. If the image has no alpha channel this has no effect. Setting it to 0
will disable this.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_color_modifier(Imlib_Color_Modifier color_modifier);
</font></font></tt></b></pre>
<blockquote>
This sets the current color modifier used for rendering pixmaps or images to
a drawable or images onto other images. Color modifiers are lookup tables
that map the values in the red, green, blue and alpha channels to toehr
values in the same channel when rendering, allowing for fades, color
correction etc. to be done whisl rendering. pass in NULL as the
color_modifier to disable the color modifier for rendering.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_operation(Imlib_Operation operation);
</font></font></tt></b></pre>
<blockquote>
When Imlib2 draws an image onto another or an image onto a drawable it is
able to do more than juts blend the result on using the given alpha channel
of the image. It is also able to do saturating additive, subtractive and a 
combination of the both (called reshade) rendering. The default mode is
IMLIB_OP_COPY. you can also set it to IMLIB_OP_ADD, IMLIB_OP_SUBTRACT or 
IMLIB_OP_RESHADE. Use this function to set the rendering operation.
IMLIB_OP_COPY perfroms basic alpha blending: DST = (SRC * A) + (DST * (1 -
A)). IMLIB_OP_ADD does DST = DST + (SRC * A). IMLIB_OP_SUBTRACT does
DST = DST - (SRC * A) and IMLIB_OP_RESHADE does DST = DST + (((SRC - 0.5) /
2) * A).
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_font(Imlib_Font font);
</font></font></tt></b></pre>
<blockquote>
This function sets the current font to use when rendering text. you should
load the font first with imlib_load_font().
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_direction(Imlib_Text_Direction direction);
</font></font></tt></b></pre>
<blockquote>
This sets the direction in which to draw text in terms of simple 90 degree
orientations or an arbitary angle. The direction can be one of 
IMLIB_TEXT_TO_RIGHT, IMLIB_TEXT_TO_LEFT, IMLIB_TEXT_TO_DOWN, IMLIB_TEXT_TO_UP
or IMLIB_TEXT_TO_ANGLE. The default is IMLIB_TEXT_TO_RIGHT. If you use
IMLIB_TEXT_TO_ANGLE, you will also have to set the angle with
imlib_context_set_angle().
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_angle(double angle);
</font></font></tt></b></pre>
<blockquote>
This sets the angle at which text strings will be drawn if the text
direction has been set to IMLIB_TEXT_TO_ANGLE with
imlib_context_set_direction().
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_color(int red, 
                             int green, 
			     int blue, 
			     int alpha);
</font></font></tt></b></pre>
<blockquote>
This sets the colour with wich text, lines and rectangles are drawn when
being rendered onto an image. Values for red, green, blue and alpha are
between 0 and 255 - any other values have undefined results.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_color_range(Imlib_Color_Range color_range);
</font></font></tt></b></pre>
<blockquote>
This sets the current colour range to use for rendering gradients.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_progress_function(Imlib_Progress_Function progress_function);
</font></font></tt></b></pre>
<blockquote>
This sets the progress function to be called back whilst loading images. Set
this to the function to be called, or set it to NULL to disable progress
callbacks whilst loading.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_progress_granularity(char progress_granularity);
</font></font></tt></b></pre>
<blockquote>
This hints as to how often to call the progress callback. 0 means as often
as possible. 1 means whenever 15 more of the image has been decoded, 10
means every 10% of the image decoding, 50 means every 50% and 100 means only
call at the end. Values outside of the range 0-100 are undefined.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_image(Imlib_Image image);
</font></font></tt></b></pre>
<blockquote>
This sets the current image imlib2 will be using with its function calls.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_set_filter(Imlib_Filter filter);
</font></font></tt></b></pre>
<blockquote>
This sets the current filter to be used when applying filters to images. Set
ths to NULL to disable filters.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Display *imlib_context_get_display(void);
</font></font></tt></b></pre>
<blockquote>
This returns the current display used for Imlib2's display context.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Visual *imlib_context_get_visual(void);
</font></font></tt></b></pre>
<blockquote>
Returns the current visual used for imlib2's context.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Colormap imlib_context_get_colormap(void);
</font></font></tt></b></pre>
<blockquote>
Returns the current Colormap used for Imlib2's context.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Drawable imlib_context_get_drawable(void);
</font></font></tt></b></pre>
<blockquote>
Returns the current Drawable used for Imlib2's context.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Pixmap imlib_context_get_mask(void);
</font></font></tt></b></pre>
<blockquote>
Retruns the current pixmap destination to be used to render a mask into.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
char imlib_context_get_dither_mask(void);
</font></font></tt></b></pre>
<blockquote>
Returns the current mode for dithering pixmap masks. 1 means dithering is
enabled and 0 means it is not.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
char imlib_context_get_anti_alias(void);
</font></font></tt></b></pre>
<blockquote>
Returns if Imlib2 currently will smoothly scale images. 1 means it will and 0 
means it will not.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
char imlib_context_get_dither(void);
</font></font></tt></b></pre>
<blockquote>
Returns if image data is rendered with dithering currently. 1 means yes and
0 means no.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
char imlib_context_get_blend(void);
</font></font></tt></b></pre>
<blockquote>
Returns if Imlib2 will blend images onto a drawable whilst rendering to that
drawable. 1 means yes and 0 means no.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Color_Modifier imlib_context_get_color_modifier(void);
</font></font></tt></b></pre>
<blockquote>
Returns the current colormodifier being used.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Operation imlib_context_get_operation(void);
</font></font></tt></b></pre>
<blockquote>
Returns the current operation mode.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Font imlib_context_get_font(void);
</font></font></tt></b></pre>
<blockquote>
Returns the current font.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
double imlib_context_get_angle(void);
</font></font></tt></b></pre>
<blockquote>
Returns the current angle used to render text at if the direction is
IMLIB_TEXT_TO_ANGLE.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Text_Direction imlib_context_get_direction(void);
</font></font></tt></b></pre>
<blockquote>
Returns the current direction to render text in.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_context_get_color(int *red, int *green, int *blue, int *alpha);
</font></font></tt></b></pre>
<blockquote>
Returns the current colour for rendering text, rectangles and lines.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Color *imlib_context_get_imlib_color(void);
</font></font></tt></b></pre>
<blockquote>
Returns the current color as a color struct. Do NOT free this pointer.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Color_Range imlib_context_get_color_range(void);
</font></font></tt></b></pre>
<blockquote>
Return the current colro range being used for gradients.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Progress_Function imlib_context_get_progress_function(void);
</font></font></tt></b></pre>
<blockquote>
Return the current progress function being used.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
char imlib_context_get_progress_granularity(void);
</font></font></tt></b></pre>
<blockquote>
Get the current progress granularity being used.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_context_get_image(void);
</font></font></tt></b></pre>
<blockquote>
Return the current context image.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Filter imlib_context_get_filter(void);
</font></font></tt></b></pre>
<blockquote>
Get the current context image filter.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
int imlib_get_cache_size(void);
</font></font></tt></b></pre>
<blockquote>
Return the current size of the image cache in bytes. The cache is a unified
cahce used for image data AND pixmaps.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_set_cache_size(int bytes);
</font></font></tt></b></pre>
<blockquote>
Set the cache size. The size is in bytes. Setting the cache size to 0
effectively flushes the cache and keeps the cache size at 0 until set to
another value. Whenever you set the cache size Imlib2 will flush as many old
images and pixmap from the cache as needed until the curretn cache useage is
less than or equal to the cache size.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
int imlib_get_color_usage(void);
</font></font></tt></b></pre>
<blockquote>
Get the number of colros Imlib2 currently at a maximum is allowed to
allocate for rendering. The default is 256.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_set_color_usage(int max);
</font></font></tt></b></pre>
<blockquote>
Set the maximum number of colors you would like Imlib2 to allocate for you
when rendering. The default ids 256. This has no effect in depths greater
than 8 bit.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_flush_loaders(void);
</font></font></tt></b></pre>
<blockquote>
If you want Imlib2 to forcibly flush any cached loaders it has and re-load
them from disk (this is useful if the program just installed a new loader
and does not want to wait till Imlib2 deems it an optimal time to rescan
the loaders)
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
int imlib_get_visual_depth(Display *display, 
                           Visual *visual);
</font></font></tt></b></pre>
<blockquote>
Conveneince function that returns the depth of a visual for that display.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Visual *imlib_get_best_visual(Display *display, 
                              int screen, 
			      int *depth_return);
</font></font></tt></b></pre>
<blockquote>
Returns the visual for that display and screen that Imlib2 thinks will give
you the best quality output. depth_return should point to an int that will
be filled with the depth of that visual too.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_load_image(const char *file);
</font></font></tt></b></pre>
<blockquote>
This function loads an image from disk located at the path specified by
file. Please see the "How image loading works" section for more detail.
Returns an image handle on success or NULL on failure.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_load_image_immediately(const char *file);
</font></font></tt></b></pre>
<blockquote>
Loads an image from disk located at the path specified by file. This forces
the image data to be decoded at load time too, instead of decoding being
deferred until it is needed. Returns an image handle on success or NULL on
failure.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_load_image_without_cache(const char *file);
</font></font></tt></b></pre>
<blockquote>
This loads the image without looking in the cache first. Returns an image
handle on success or NULL on failure.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_load_image_immediately_without_cache(const char *file);
</font></font></tt></b></pre>
<blockquote>
Loads the image withotu deferred image data decoding (ie it is decoded
straight away) and without looking in the cache. Returns an image handle on
success or NULL on failure.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_load_image_with_error_return(const char *file, 
                                               Imlib_Load_Error *error_return);
</font></font></tt></b></pre>
<blockquote>
This loads an image at the path file on disk. If it succedds it returns a
valid image handle, if not NULL is returned and the error_return pointed to
is set to the detail of the error.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_free_image(void);
</font></font></tt></b></pre>
<blockquote>
This frees the image that is set as the current image in Imlib2's context.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_free_image_and_decache(void);
</font></font></tt></b></pre>
<blockquote>
Frees the current image in Imlib2's context AND removes it from the cache.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
int imlib_image_get_width(void);
</font></font></tt></b></pre>
<blockquote>
Returns the width in pixels of the current image in Imlib2's context.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
int imlib_image_get_height(void);
</font></font></tt></b></pre>
<blockquote>
Returns the height in pixels of the current image in Imlib2's context.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
const char *imlib_image_get_filename(void);
</font></font></tt></b></pre>
<blockquote>
This returns the filename for the file that is set as the current context.
The pointer returned is only valid as long as no operations cause the 
filename of the image to change. Saving the file with a different name would 
cause this. It is sugested you duplicate the string if you wish to continue 
to use the string for later processing. Do not free the string pointer 
returned by this function.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
DATA32 *imlib_image_get_data(void);
</font></font></tt></b></pre>
<blockquote>
This returns a pointer to the image data in the image set as the image for
the current context. When you get this pointer it is assumed you are
planning on writing to the data, thus once  you do this the image can no
longer be used for caching - in fact all images cached from this one will
also be affected when you put the data back. If this matters it is suggested
you clone the image first before playing with the image data. The image data
is returned in the format of a DATA32 (32 bits) per pixel in a linear array
ordered from the top-left of the image to the bottom right going from left
to right each line. Each pixel has the upper 8 bits as the alpha channel and
the lower 8 bits are the blue channel - so a pixel's bits are ARGB (from
most to least significant, 8 bits per channel). You must put the data back
at some point.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
DATA32 *imlib_image_get_data_for_reading_only(void);
</font></font></tt></b></pre>
<blockquote>
This functions the same way as imlib_image_get_data(), but returns a poitner
expecting the program to NOT write to the data returned (it is for
einspection pruposes only). Writing to this data has undefined results. The
data does not need to be put back.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_put_back_data(DATA32 *data);
</font></font></tt></b></pre>
<blockquote>
This will put back data when it was obtained by imlib_image_get_data(). The
data must be the same pointer returned by imlib_image_get_data(). This
operated on the current context image.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
char imlib_image_has_alpha(void);
</font></font></tt></b></pre>
<blockquote>
Returns 1 if the current context image has an alpha channel, or 0 if it does
not (the alpha data space is still there and available - just "unused").
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_set_changes_on_disk(void);
</font></font></tt></b></pre>
<blockquote>
By default imlib2 will not check the timestamp of an image on disk and
comapre it with the image in its cache - this is to minimise disk activity
when using the cache. Call this function and it will flag the current
context image as being liable to change on disk and imlib2 will check the
timestamp of the image file on disk and compare it with the cached image
when it next needs to use this image in the cache.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_get_border(Imlib_Border *border);
</font></font></tt></b></pre>
<blockquote>
This function fills the Imlib_Border structure to which border points to
with the values of the border of the current context image. The border is
the area att he edge of the image that does not scale witht he rest of the
image when resized - the borders remain constant in size. This is useful for
scaling bevels at the edge of images differently to the image center.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_set_border(Imlib_Border *border);
</font></font></tt></b></pre>
<blockquote>
This sets the border of the current context image to the values contained in
the Imlib_Border structure border points to.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_set_format(const char *format);
</font></font></tt></b></pre>
<blockquote>
This sets the format of the current image. This is used for when you wish to
save an image in a different format that it was loaded in, or if the image
currently has no file format associated with it.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_set_irrelevant_format(char irrelevant);
</font></font></tt></b></pre>
<blockquote>
This sets if the fromat value of the current image is irrelevant for caching 
purposes - by default it is. pass irrelevant as 1 to make it irrelevant and 
0 to make it relevant for caching.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_set_irrelevant_border(char irrelevant);
</font></font></tt></b></pre>
<blockquote>
This sets if the border of the current image is irrelevant for cachng purposes.
By default it is. Set irrelevant to 1 to make it irrelevant, and 0 to make
it relevant.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_set_irrelevant_alpha(char irrelevant);
</font></font></tt></b></pre>
<blockquote>
This sets if the alpha channel status of the current image (ie if there is or 
is not one) is important for caching purposes. By default it is not. Set 
irrelevant to 1 to make it irrelevant and 0 to make it relevant.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
char *imlib_image_format(void);
</font></font></tt></b></pre>
<blockquote>
This returns the current image's format. Do not free this string. Duplicate
it if you need it for later use.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_set_has_alpha(char has_alpha);
</font></font></tt></b></pre>
<blockquote>
Sets the alpha flag for the current image. Set has_alpha to 1 to enable the
alpha channel in the current imagem or 0 to disable it.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_render_pixmaps_for_whole_image(Pixmap *pixmap_return, 
                                          Pixmap *mask_return);
</font></font></tt></b></pre>
<blockquote>
This function will create a pixmap of the current image (and a mask if the 
image has an alpha value) and return the id's of the pixmap and mask to the 
pixmap_return and mask_return pximap id's. You must free these pixmaps using 
Imlib2's free function imlib_free_pixmap_and_mask();.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_render_pixmaps_for_whole_image_at_size(Pixmap *pixmap_return, 
                                                  Pixmap *mask_return, 
						  int width, 
						  int height);
</font></font></tt></b></pre>
<blockquote>
This function works just like imlib_render_pixmaps_for_whole_image(), but
will scale the output result to the width and height specified. Scaling is
done before depth conversion so pixels used for dithering don't grow large.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_free_pixmap_and_mask(Pixmap pixmap);
</font></font></tt></b></pre>
<blockquote>
This will free the pixmap (and any mask generated in association with that
pixmap). The pixmap will remain cached until the image the pixmap was
generated from is dirtied or decached, or the cache is flushed.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_render_image_on_drawable(int x, int y);
</font></font></tt></b></pre>
<blockquote>
This renders the current image onto the current drawable at the x, y pixel
location specified without scaling.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_render_image_on_drawable_at_size(int x, 
                                            int y, 
					    int width, 
					    int height);
</font></font></tt></b></pre>
<blockquote>
Thsi will render the current image onto the current drawable at the x, y
location specified AND scale the image to the width and height specified.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_render_image_part_on_drawable_at_size(int source_x, 
                                                 int source_y, 
						 int source_width, 
						 int source_height, 
						 int x, 
						 int y, 
						 int width, 
						 int height);
</font></font></tt></b></pre>
<blockquote>
This renders the source x,y, width, height pixel rectangle from the current
image onto the current drawable at the x, y location scaled to the width and
height specified.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
void imlib_blend_image_onto_image(Imlib_Image source_image, 
                                  char merge_alpha, 
				  int source_x, 
				  int source_y, 
				  int source_width, 
				  int source_height, 
				  int destination_x, 
				  int destination_y, 
				  int destination_width, 
				  int destination_height);
</font></font></tt></b></pre>
<blockquote>
This will blend the source rectangle x, y, width, height fromn the 
source_image onto the current image at the destination x, y location scaled
to the width and height specified. If merge_alpha is set to 1 it will also
modify the destination image alpha channel, otherwise the destination alpha
channel is left untouched.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_create_image(int width, 
                               int height);
</font></font></tt></b></pre>
<blockquote>
This creates a new blank image of size width and height. The contents of
this image at creation time are undefined (they could be garbage memory).
You are free to do whatever you like with this image. It is not cached. On
success an image handle is returned - on failure NULL is returned.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_create_image_using_data(int width, 
                                          int height, 
					  DATA32 *data);
</font></font></tt></b></pre>
<blockquote>
This creates an image frm the image data specified with the width and height
specified. The image data must be in the same format as
imlib_image_get_data() would return. You are responsible for freeing this
image data once the image is freed - Imlib2 will not do that for you. This
is useful for when you alreay dhave static buffers of the same format Imlib2
uses (many video grabbing devices use such a format) and wish to use Imlib2
to render the results onto another image, or X drawable. You shoudl free the
image when you are done with it. Imlib2 returns a valid image handle on
success or NULL on failure
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_create_image_using_copied_data(int width, 
                                                 int height, 
						 DATA32 *data);
</font></font></tt></b></pre>
<blockquote>
This works the same way as imlib_create_image_using_data() but Imlib2 copies
the image data to the image structure. You may now do whatever you wish with
the original data as it will not be needed anymore. Imlib2 returns a valid
image handle on success or NULL on failure.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_create_image_from_drawable(Pixmap mask, 
                                             int x, 
					     int y, 
					     int width, 
					     int height, 
					     char need_to_grab_x);
</font></font></tt></b></pre>
<blockquote>
This will return an image (using the mask to determine the alpha channel)
from the current drawable. If the mask is 0 it will not create a useful
alpha channel in the image. It will creat an image from the x, y, widht ,
height rectangle in the drawable. If need_to_grab_x is 1 it will also grab
the X Server to avoid possible race conditions in grabbing. If you have not
already grabbed the server you MUST set this to 1. Imlib2 returns a valid
image handle on success or NULL on failure.
</blockquote>
<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_create_scaled_image_from_drawable(Pixmap mask, 
                                                    int source_x, 
						    int source_y, 
						    int source_width, 
						    int source_height, 
						    int destination_width, 
						    int destination_height, 
						    char need_to_grab_x, 
						    char get_mask_from_shape);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
char imlib_copy_drawable_to_image(Pixmap mask, 
                                  int x, 
				  int y, 
				  int width, 
				  int height, 
				  int destination_x, 
				  int destination_y, 
				  char need_to_grab_x);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_clone_image(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_create_cropped_image(int x, 
                                       int y, 
				       int width, 
				       int height);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_create_cropped_scaled_image(int source_x, 
                                              int source_y, 
					      int source_width, 
					      int source_height, 
					      int destination_width, 
					      int destination_height);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Updates imlib_updates_clone(Imlib_Updates updates);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Updates imlib_update_append_rect(Imlib_Updates updates, 
                                       int x, 
				       int y, 
				       int w, 
				       int h);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Updates imlib_updates_merge(Imlib_Updates updates, 
                                  int w, 
				  int h);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Updates imlib_updates_merge_for_rendering(Imlib_Updates updates, 
                                                int w, 
						int h);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_updates_free(Imlib_Updates updates);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Updates imlib_updates_get_next(Imlib_Updates updates);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_updates_get_coordinates(Imlib_Updates updates, 
                                   int *x_return, 
				   int *y_return, 
				   int *width_return, 
				   int *height_return);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_updates_set_coordinates(Imlib_Updates updates, 
                                   int x, 
				   int y, 
				   int width, 
				   int height);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_render_image_updates_on_drawable(Imlib_Updates updates, 
                                            int x, 
					    int y);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Updates imlib_updates_init(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Updates imlib_updates_append_updates(Imlib_Updates updates, 
                                           Imlib_Updates appended_updates);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_flip_horizontal(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_flip_vertical(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_flip_diagonal(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_orientate(int orientation);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_blur(int radius);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_sharpen(int radius);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_tile_horizontal(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_tile_vertical(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_tile(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Font imlib_load_font(const char *font_name);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_free_font(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_text_draw(int x, int y, const char *text);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_text_draw_with_return_metrics(int x, 
                                         int y, 
					 const char *text, 
					 int *width_return, 
					 int *height_return, 
					 int *horizontal_advance_return, 
					 int *vertical_advance_return);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_get_text_size(const char *text, 
                         int *width_return, 
			 int *height_return);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_add_path_to_font_path(const char *path);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_remove_path_from_font_path(const char *path);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
char **imlib_list_font_path(int *number_return);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
int imlib_text_get_index_and_location(const char *text, 
                                      int x, 
				      int y, 
				      int *char_x_return, 
				      int *char_y_return, 
				      int *char_width_return, 
				      int *char_height_return);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_text_get_location_at_index(const char *text, 
                                      int index, 
				      int *char_x_return, 
				      int *char_y_return, 
				      int *char_width_return, 
				      int *char_height_return);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
char **imlib_list_fonts(int *number_return);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_free_font_list(char **font_list, 
                          int number);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
int imlib_get_font_cache_size(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_set_font_cache_size(int bytes);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_flush_font_cache(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
int imlib_get_font_ascent(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
int imlib_get_font_descent(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
int imlib_get_maximum_font_ascent(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
int imlib_get_maximum_font_descent(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Color_Modifier imlib_create_color_modifier(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_free_color_modifier(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_modify_color_modifier_gamma(double gamma_value);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_modify_color_modifier_brightness(double brightness_value);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_modify_color_modifier_contrast(double contrast_value);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_set_color_modifier_tables(DATA8 *red_table, 
                                     DATA8 *green_table, 
				     DATA8 *blue_table, 
				     DATA8 *alpha_table);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_get_color_modifier_tables(DATA8 *red_table, 
                                     DATA8 *green_table, 
				     DATA8 *blue_table, 
				     DATA8 *alpha_table);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_reset_color_modifier(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_apply_color_modifier(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_apply_color_modifier_to_rectangle(int x, 
                                             int y, 
					     int width, 
					     int height);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Updates imlib_image_draw_line(int x1, 
                                    int y1, 
				    int x2, 
				    int y2, 
				    char make_updates);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_draw_rectangle(int x, 
                                int y, 
				int width, 
				int height);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_fill_rectangle(int x, 
                                int y, 
				int width, 
				int height);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_copy_alpha_to_image(Imlib_Image image_source, 
                                     int x, 
				     int y);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_copy_alpha_rectangle_to_image(Imlib_Image image_source, 
                                               int x, 
					       int y, 
					       int width, 
					       int height, 
					       int destination_x, 
					       int destination_y);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_scroll_rect(int x, 
                             int y, 
			     int width, 
			     int height, 
			     int delta_x, 
			     int delta_y);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_copy_rect(int x, 
                           int y, 
			   int width, 
			   int height, 
			   int new_x, 
			   int new_y);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Color_Range imlib_create_color_range(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_free_color_range(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_add_color_to_color_range(int distance_away);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_fill_color_range_rectangle(int x, 
                                            int y, 
					    int width, 
					    int height, 
					    double angle);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_query_pixel(int x, 
                             int y, 
			     Imlib_Color *color_return);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_attach_data_value(const char *key, 
                                   void *data, 
				   int value, 
				   Imlib_Data_Destructor_Function destructor_function);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void *imlib_image_get_attached_data(const char *key);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
int imlib_image_get_attached_value(const char *key);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_remove_attached_data_value(const char *key);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_remove_and_free_attached_data_value(const char *key);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_save_image(const char *filename);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_save_image_with_error_return(const char *filename, 
                                        Imlib_Load_Error *error_return);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Image imlib_create_rotated_image(double angle);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_blend_image_onto_image_at_angle(Imlib_Image source_image, 
                                           char merge_alpha, 
					   int source_x, 
					   int source_y, 
					   int source_width, 
					   int source_height, 
					   int destination_x, 
					   int destination_y, 
					   int angle_x, 
					   int angle_y);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_blend_image_onto_image_skewed(Imlib_Image source_image, 
                                         char merge_alpha, 
					 int source_x, 
					 int source_y, 
					 int source_width, 
					 int source_height, 
					 int destination_x, 
					 int destination_y, 
					 int h_angle_x, 
					 int h_angle_y, 
					 int v_angle_x, 
					 int v_angle_y);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_render_image_on_drawable_skewed(int source_x, 
                                           int source_y, 
					   int source_width, 
					   int source_height, 
					   int destination_x, 
					   int destination_y, 
					   int h_angle_x, 
					   int h_angle_y, 
					   int v_angle_x, 
					   int v_angle_y);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_render_image_on_drawable_at_angle(int source_x, 
                                             int source_y, 
					     int source_width, 
					     int source_height, 
					     int destination_x, 
					     int destination_y, 
					     int angle_x, 
					     int angle_y);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_image_filter(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
Imlib_Filter imlib_create_filter(int initsize);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_free_filter(void);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_filter_set(int xoff, 
                      int yoff, 
		      int a, 
		      int r, 
		      int g, 
		      int b);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_filter_set_alpha(int xoff, 
                            int yoff, 
			    int a, 
			    int r, 
			    int g, 
			    int b);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_filter_set_red(int xoff, 
                          int yoff, 
			  int a, 
			  int r, 
			  int g, 
			  int b);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_filter_set_green(int xoff, 
                            int yoff, 
			    int a, 
			    int r, 
			    int g, 
			    int b);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_filter_set_blue(int xoff, 
                           int yoff, 
			   int a, 
			   int r, 
			   int g, 
			   int b);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_filter_constants(int a, 
                            int r, 
			    int g, 
			    int b);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_filter_divisors(int a, 
                           int r, 
			   int g, 
			   int b);
</font></font></tt></b></pre>

<pre><b><tt><font color="#660000"><font size=+2>
void imlib_apply_filter( char *script, ... );
</font></font></tt></b></pre>
</td>

<td><img SRC="blank.gif" height=1 width=1></td>
</tr>

<tr NOSAVE>
<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td NOSAVE><img SRC="blank.gif" height=1 width=1></td>

<td WIDTH="1" NOSAVE><img SRC="blank.gif" height=1 width=1></td>
</tr>
</table></center>

</body>
</html>
