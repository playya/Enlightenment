<chapter>
    <title>Introduction to Widgets</title>

    <para>
        Interfaces are used to display information to the user in multiple
        states and to allow the user to interact with said information.
        Functions to display information in multiple state are trivial to
        implement using the concepts reviewed in the previous chapters and,
        to some extent, so are functions dealing with interaction. But as
        complexity in our application increases, the number of abstract
        functions related only to certain interface object will grow as well.
        The collection of these abstract functions and the object they relate
        to is known as "widget".
    </para>

    <para>
        Widgets don't need to be created by the application developer. Many
        libraries already provide predefined widgets. In many cases predefined
        widgets might be the best choice. This chapter deals with a simple
        example, a hypotetical music player, were predefined widgets are not.
    </para>

    <para>
        Music players these days play music from multiple sources and they all
        implement a method to select these sources in a similar fashion.
        Our hypotetical music player also has this capabilty. The developer
        decides to implement it using two lists on top of another. At
        the top there is a list of sources and at the bottom a list of
        resources from the source selected on the top list. In the following
        figure we can see the different visions for the same interface element.
    </para>

    <figure>
        <title>Hypotetical music player source list</title>
        <mediaobject><imageobject>
            <imagedata fileref="img/custom_music_player_sources.png" format="png" ScaleFit="1" width="100%"></imagedata>
        </imageobject></mediaobject>
    </figure>

    <para>
        With a common toolkit/widget library it would be impossible for
        "Artist 2" to implement the source list he envisioned. The developer
        would have to program a new widget using the same, complex, in the view
        of the artist, programming language that the library uses. The
        developer would also have to alter the code of the application for it
        to change the widget depending on the theme selected by the user. If he
        used Edje this issue would not exist.
    </para>

    <para>
        Before we dive into the specifics of how can we implement such widget
        with Edje it would be better to review the design of the widget in
        generic terms. The widget works like a small application inside our
        interface. In the first chapter of this book, the figure 2.1 describes
        the route of communication for the average GUI based application. If we
        were to plug any widget into said application the library would have
        to alter the route of communication for those objects that compose it.
    </para>

    <para>
        In the figure 5.3 we can se the effects of including a combox widget in
        the average application. The widget library would have to register
        handlers for the input signals ocurring on its primitive objects. The
        widget library would also register a new signal type with the Event
        loop representing the selection of a item. If the widget library is not
        based on Edje it would also have to implement functions to draw itself
        and the necessary visual feedback for the different states.
    </para>
    
    <figure>
        <title>The average GUI application + a widget</title>
        <mediaobject><imageobject>
                <imagedata fileref="img/graphical_application_components_widget.png" format="png" ScaleFit="1" width="100%"></imagedata>
            </imageobject></mediaobject>
    </figure>

    <para>In more general terms, to implement a new widget from scratch the
        developer has to implment functions that:
        <itemizedlist>
            <listitem>Deal with the drawing device and library to draw the
                widget's shape and feedback.</listitem>
            <listitem>Load information into the widget and fetch the results
                of the interaction with the user.</listitem>
            <listitem>Implement and register handlers for the signals emitted
                by its primitive objects.</listitem>
            <listitem>Implement and register new signal types to be emitted by
                the widget and handled by the application.</listitem>
        </itemizedlist>
    </para>
    
</chapter>