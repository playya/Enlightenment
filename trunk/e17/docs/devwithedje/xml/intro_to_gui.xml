<chapter>
    <title>Structure of a graphical application</title>
    
    <para>Someday someone might want to create a new application and he might
          feel overwhelmed by the large number of development libraries
          available just for the interface. Looking through the source code of
          some of his favorites open source applications he will realize that
          regardless of those small incompatible differences, all these
          applications share a common structure. In this chapter we will
          review that structure before we procede to put some more mango in
          the fruit salad that is today's averange desktop.</para>

    <para>Its also convenient to note that the concepts seen in this book and
          the applications resulting from them translate painlessly to special
          purpose computers or embed devices running under alternative
          architectures like ARM or PPC. Edje and related libraries are not
          only small but portable.</para>

    <para>The structure of the averange graphical application is built around a
          concept known as event (or signal) driven execution. Event driven
          applications are persistent and depend on a gate guardian to call the
          appropriate functions in the appropriate moment. This gate guardian
          is known as the Event loop (or main loop).</para>

    <figure>
          <title>The average GUI application</title>
          <mediaobject><imageobject>
                  <imagedata fileref="img/graphical_application_components.png" format="png" ScaleFit="1" width="100%"></imagedata>
              </imageobject></mediaobject>
    </figure>

    <para>The functions that form a event driven application with a GUI can be
          split among two groups, backend and frontend. On one side we find the
          backend functions, these functions deal with the actual purpose of
          the application, crunching numbers, decoding media files, etc. On the
          other side we have the frontend functions, their purpose is to
          present the results to their human overlords and to receive their
          orders.</para>

    <para>Between the backend and the frontend is where the Event loop lives,
          its mission is to connect both ends of the application. Not only
          between them but also with their environment. The Event loop mantains
          a list of signals to look out for and functions related to them. When
          a signal is received, the Event loop looks through the list and
          executes the corresponding function or functions.</para>

    <para>For the application to work, the Event loop needs to be aware of
          events in the interface thus it is  usually provided by the same
          library that provides the GUI elements. It also needs to be aware of
          events in the system where the application is running. Even when the
          concept is simple, creating a portable and properly abstracted event
          loop is no simple task.</para>
    
    <section>
        <title>Decomposing the frontend</title>

        <para>There are many libraries that aid creation of a GUI. From a plain
              canvas consisting of primitive design objects to a interface
              consisting of complex predefined widgets, the latter is commonly
              known as "toolkit", in a toolkit the canvas is just another
              widget.</para>

        <para>Regardless of the method of choice, the resulting GUI has to
              provide the same resources to the rest of the application. A
              mechanism to manage the interface, a mechanism to manage objects
              in the interface and a mechanism to manage the signals emitted by
              the objects in the interface.</para>

        <para>In the case of the plain canvas the application developer must
              assemble the interface objects using primitive objects, for
              example a very simple text entry could consist of a rectangle and
              a string of text. In this case, the application must also
              discriminate between the signals emitted by each primitive and
              how it affects the interface element they conform. The developer
              would decide if, for example, a click in the rectangle would set
              the cursor at the end of the string or if all clicks outside the
              area of the text string should be ignored.</para>

        <para>In the case of a toolkit library the application would simply
              include the the "text entry" object. The behavior of this object
              would be dealt with in terms of the object as a whole instead of
              each primitive object that conforms it.</para>

        <para>Deciding which approach to use is, of course, up to the developer
              to decide as each one provide capabilities useful for different
              types of applications. But as we will find out further ahead in
              this book, these examples only represent opposite extremes and
              there is a method that sits comfortably in the middle.</para>
    </section>
    
</chapter>