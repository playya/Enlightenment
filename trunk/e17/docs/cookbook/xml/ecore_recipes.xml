<!-- Ecore & Modules Recipes -->
<!-- 
###################################################
This example section is commented out:

<section>
<title>Recipe: Example</title>

<para>
This is the first paragraph of the recipe.
</para>

<example>
<title>Code Example Title</title>
<programlisting>
// Sample EDC
images {
        image,  "background.png" LOSSY 95;
}

collections {
   group {
      name, "test";
      min, 32 32;
      max, 1024 768;
	...
</programlisting>               
</example> 

<para>
Another paragraph.  Don't forget to replace less-than and greater-than 
symbols with the proper &lt; and &gt; even in your program listings.
</para>
</section>
#################################################
-->

<!--	\/ \/ \/ CONTENT \/ \/ \/	-->

<chapter>
<title>Ecore</title>

<para>
What is Ecore? Ecore is the core event abstraction layer and X abstraction 
layer that makes doing selections, Xdnd, general X stuff, and event loops, 
timeouts and idle handlers fast, optimized, and convenient. It's a 
separate library so anyone can make use of the work put into Ecore to 
make this job easy for applications.
</para>

<para>
Ecore is completely modular. At its base is the event handlers and 
timers, and initialization and shutdown functions. The abstraction 
modules for Ecore include:
</para>

<itemizedlist mark="bullet" spacing="compact">
 <listitem>
  Ecore X
 </listitem>
 <listitem>
  Ecore FB
 </listitem>
 <listitem>
  Ecore EVAS
 </listitem>
 <listitem>
  Ecore TXT
 </listitem>
 <listitem>
  Ecore Job
 </listitem>
 <listitem>
  Ecore IPC
 </listitem>
 <listitem>
  Ecore Con
 </listitem>
 <listitem>
  Ecore Config
 </listitem>
</itemizedlist>

<para>
Ecore is so modular and powerful that it can be extremely useful even 
in non-graphics programing by itself. As an example, several web servers 
have been written that were based solely on Ecore and the Ecore_Con module 
for abstract socket communication. 
</para>

<!--
#######################################
Introduction to Ecore_Config
#######################################
-->
<section>
<sectioninfo>
  <author>
    <firstname>dan</firstname>
    <surname>sinclair</surname>
    <email>zero@perplexity.org</email>
    <othername>dj2</othername>
  </author>
  <date>25 April 2004</date>
</sectioninfo>

<title>Recipe: Ecore Config Introduction</title>

<para>
The Ecore_Config module provides the programmer with a very simple way to setup
configuration files for their program. This recipe will give an example of how to
integrate the beginnings of Ecore_Config into your program and use it to get
configuration data.
</para>

<example>
<title>Simple Ecore_Config program</title>
<programlisting>
#include &lt;Ecore_Config.h&gt;

int main(int argc, char ** argv) {
    int i;
    float j;
    char *str;

    if (ecore_config_init("foo") != ECORE_CONFIG_ERR_SUCC) {
        printf("Cannot init Ecore_Config");
        return 1;
    }

    ecore_config_int_default("/int_example", 1);
    ecore_config_string_default("/this/is/a/string/example", "String");
    ecore_config_float_default("/float/example", 2.22);

    ecore_config_load();

    i = ecore_config_int_get("/int_example");
    str = ecore_config_string_get("/this/is/a/string/example");
    j = ecore_config_float_get("/float/example");

    printf("str is (%s)\n", str);
    printf("i is (%d)\n", i);
    printf("j is (%f)\n", j);

    free(str);

    ecore_config_shutdown();
    return 0;
}
</programlisting>
</example>
<para>
As you can see from this example the basic usage of Ecore_Config is simple. The system is initialized with
a call to ecore_config_init(PROGRAM_NAME). The program name setting control where Ecore_Config will look for
your configuration database. The directory and file name are: ~/.e/apps/PROGRAM_NAME/config.db.
</para>

<para>
For each configuration variable you are getting from Ecore_Config, you can assign a default value in the case
that the user does not have a config.db file. The defaults are assigned with the ecore_config_*_default where *
is one of the Ecore_Config types. The first parameter is the key under which this is to be accessed. These keys
must be unique over your program. The value passed is of the type appropriated for this call.
</para>

<para>
The ecore_config_load call will read the values from the config.db file into Ecore_Config. After which we can
access the files with the ecore_config_*_get methods (again * is the type of data desired). These routines
take the key name for this item and return the value associated with that key. Each function returns a type
that corresponds to the function call name.
</para>

<para>
ecore_config_shutdown is then called to shutdown the Ecore_Config system before the program exits.
</para>

<example>
<title>Compilation command</title>
<programlisting>
gcc -o ecore_config_example ecore_config_example.c `ecore-config --cflags --libs`
</programlisting>
</example>
<para>
To compile the program you can use the ecore-config script to get all of the required linking and library information
for Ecore_Config.

If you run this program as is you will receive the values put into ecore_config as the defaults as output.
Once you know the program is working, you can create a simple config.db file to read the values.
</para>

<example>
<title>Simple config.db script (build_cfg_db.sh)</title>
<programlisting>
#!/bin/sh

DB=config.db

edb_ed $DB add /int_example int 2
edb_ed $DB add /this/is/a/string/example str "this is a string"
edb_ed $DB add /float/example float 42.10101
</programlisting>
</example>
<para>
When build_cfg_db.sh is executed it will create a config.db file in the current directory. This file can
then be copied into ~/.e/apps/PROGRAM_NAME/config.db where PROGRAM_NAME is the value passed into 
ecore_config_init. Once the file is copied in place, executing the test program again will show the values
given in the config file instead of the defaults. You can specify as many, or as few of the configuration
keys in the config file and Ecore_Config will either show the user value or the default value.
</para>
</section>

<!--
#######################################
Introduction to Ecore_Ipc
#######################################
-->
<section>
<sectioninfo>
  <author>
    <firstname>dan</firstname>
    <surname>sinclair</surname>
    <email>zero@perplexity.org</email>
    <othername>dj2</othername>
  </author>
  <date>14 June 2004</date>
</sectioninfo>

<title>Recipe: Ecore Ipc Introduction</title>
<para>
The Ecore_Ipc library provides a robust and efficient wrapper around the Ecore_Con module.
Ecore_Ipc allows you to set up your server communications and handles all of the tricky stuff
under the hood. This recipe will give a simple example of an Ecore client and an Ecore server.
</para>

<para>
When working with Ecore_Ipc, when writing a client or a server app an Ecore_Ipc_Server
object will be created. This is because in either case it is a server being manipulated,
either the one being setup, or the one being communicated with. After that, everything 
is easy.
</para>

<example>
<title>Ecore_Ipc client: preamble</title>
<programlisting>
#include &lt;Ecore.h&gt;
#include &lt;Ecore_Ipc.h&gt;

int sig_exit_cb(void *data, int ev_type, void *ev);
int handler_server_add(void *data, int ev_type, void *ev);
int handler_server_del(void *data, int ev_type, void *ev);
int handler_server_data(void *data, int ev_type, void *ev);
</programlisting>
</example>
<para>
The Ecore.h file is included so we can have access to the exit signal type. The functions
will be explained later when their callbacks are hooked up.
</para>

<example>
<title>Ecore_Ipc client: main setup</title>
<programlisting>
int main(int argc, char ** argv) {
    Ecore_Ipc_Server *server;

    if (!ecore_init()) {
        printf("unable to init ecore\n");
        return 1;
    }

    if (!ecore_ipc_init()) {
        printf("unable to init ecore_con\n");
        ecore_shutdown();
        return 1;
    }
    ecore_event_handler_add(ECORE_EVENT_SIGNAL_EXIT, sig_exit_cb, NULL);
</programlisting>
</example>
<para>
As mentioned earlier, even though we are writing a client app, we still use an Ecore_Ipc_Server
object.  Using Ecore_Ipc requires the setup of Ecore itself. This is done with a simple call to ecore_init().
Ecore_Ipc is then setup with a call to ecore_ipc_init(). If either of these return 0, the appropriate
action is taken to undo any initialization take to this point. The ECORE_EVENT_SIGNAL_EXIT callback
is hooked up so we can exit gracefully if required.
</para>

<example>
<title>Ecore_Ipc client: main creating client</title>
<programlisting>
    server = ecore_ipc_server_connect(ECORE_IPC_REMOTE_SYSTEM, 
                                        "localhost", 9999, NULL);
    ecore_event_handler_add(ECORE_IPC_EVENT_SERVER_ADD, 
                                        handler_server_add, NULL);
    ecore_event_handler_add(ECORE_IPC_EVENT_SERVER_DEL, 
                                        handler_server_del, NULL);
    ecore_event_handler_add(ECORE_IPC_EVENT_SERVER_DATA, 
                                        handler_server_data, NULL);
</programlisting>
</example>
<para>
In this example we are creating a remote connection to the server named "localhost" on the port 9999. This
is done with the ecore_ipc_server_connect() method. The first parameter is the type of connection being made,
which can be one of: ECORE_IPC_REMOTE_SYSTEM, ECORE_IPC_LOCAL_SYSTEM, or ECORE_IPC_LOCAL_USER. If 
OpenSSL was available when Ecore_Ipc was compiled, ECORE_IPC_USE_SSL can be or'd with the connection type
to create an SSL connection.
</para>

<para>
The three calls to ecore_event_handler_add() setup the callbacks for the different types of events
we will be receiving from the server. A server was added, a server was deleted, or the server
sent us data.
</para>

<example>
<title>Ecore_Ipc client: main end</title>
<programlisting>
    ecore_ipc_server_send(server, 3, 4, 0, 0, 0, "Look ma, no pants", 17);

    ecore_main_loop_begin();

    ecore_ipc_server_del(server);
    ecore_ipc_shutdown();
    ecore_shutdown();
    return 0;
}
</programlisting>
</example>
<para>
For the purposes of this example, the client is sending a message on startup to the server, which
the server will respond to. The client message is sent with the ecore_ipc_server_send() command.
ecore_ipc_server_send() takes the server to send to, the message major, message minor, a reference, 
a reference to, a response, the data and a size. These parameters, except for the server are up the 
the client and can refer to anything required. This hopefully gives the maximum flexibility 
in creating client/server IPC apps.
</para>

<para>
After the server message is sent we enter into the main ecore loop and wait for events. If 
the main loop is exited we delete the server object, shutdown Ecore_Ipc with a call to 
ecore_ipc_shutdown(), and shutdown ecore through ecore_shutdown().
</para>

<example>
<title>Ecore_Ipc client: sig_exit_cb</title>
<programlisting>
int sig_exit_cb(void *data, int ev_type, void *ev) {
    ecore_main_loop_quit();
    return 1;
}
</programlisting>
</example>
<para>
The sig_exit_cb() just tells ecore to quit the main loop.
</para>

<example>
<title>Ecore_Ipc client: the callbacks</title>
<programlisting>
int handler_server_add(void *data, int ev_type, void *ev) {
    Ecore_Ipc_Event_Server_Add *e = (Ecore_Ipc_Event_Server_Add *)ev;
    printf("Got a server add %p\n", e->server);
    return 1;
}

int handler_server_del(void *data, int ev_type, void *ev) {
    Ecore_Ipc_Event_Server_Del *e = (Ecore_Ipc_Event_Server_Del *)ev;
    printf("Got a server del %p\n", e->server);
    return 1;
}

int handler_server_data(void *data, int ev_type, void *ev) {
    Ecore_Ipc_Event_Server_Data *e = (Ecore_Ipc_Event_Server_Data *)ev;
    printf("Got server data %p [%i] [%i] [%i] (%s)\n", e->server, e->major,
                                e->minor, e->size, (char *)e->data);
    return 1;
}
</programlisting>
</example>
<para>
These three callbacks, handler_server_add(), handler_server_del(), and handler_server_data()
are body of the client handling all events related to the server we are connected to. Each
of the callbacks has an associated event structure, Ecore_Ipc_Event_Server_Add, 
Ecore_Ipc_Event_Server_Del and Ecore_Ipc_Event_Server_Data containing information on the
event itself.
</para>

<para>
When we first connect to the server the handler_server_add() callback will be executed
allowing any setup to be accomplished.
</para>

<para>
If the server breaks the connection the handler_server_del() callback will be executed
allowing any required cleanup.
</para>

<para>
When the server sends data to the client the handler_server_data callback will the executed.
Which in this example just prints some information about the message itself and the 
message body.
</para>

<para>
And thats the client. The code itself is pretty simple thanks to the abstractions provided by
Ecore.
</para>

<example>
<title>Ecore_Ipc server: preamble</title>
<programlisting>
#include &lt;Ecore.h&gt;
#include &lt;Ecore_Ipc.h&gt;

int sig_exit_cb(void *data, int ev_type, void *ev);
int handler_client_add(void *data, int ev_type, void *ev);
int handler_client_del(void *data, int ev_type, void *ev);
int handler_client_data(void *data, int ev_type, void *ev);
</programlisting>
</example>
<para>
As with the client, the Ecore.h header is included to get access the to the exit signal. 
The Ecore_Ipc.h header is required for apps making use of the Ecore_Ipc library. Each
sign handler will be explained with its code.
</para>

<example>
<title>Ecore_Ipc server: main setup</title>
<programlisting>
int main(int argc, char ** argv) { 
    Ecore_Ipc_Server *server;
    
    if (!ecore_init()) {
        printf("Failed to init ecore\n");
        return 1;
    }
    
    if (!ecore_ipc_init()) {
        printf("failed to init ecore_con\n");
        ecore_shutdown();
        return 1;
    }
    
    ecore_event_handler_add(ECORE_EVENT_SIGNAL_EXIT, sig_exit_cb, NULL);
</programlisting>
</example>
<para>
This is the same as the client setup above.
</para>

<example>
<title>Ecore_Ipc server: main creating server</title>
<programlisting>
    server = ecore_ipc_server_add(ECORE_IPC_REMOTE_SYSTEM, "localhost", 9999, NULL);
    ecore_event_handler_add(ECORE_IPC_EVENT_CLIENT_ADD, handler_client_add, NULL);
    ecore_event_handler_add(ECORE_IPC_EVENT_CLIENT_DEL, handler_client_del, NULL);
    ecore_event_handler_add(ECORE_IPC_EVENT_CLIENT_DATA, handler_client_data, NULL);
</programlisting>
</example>
<para>
Unlike the client, for the server we add a listener to port 9999 on the machine "localhost" through
the call ecore_ipc_server_add(). This will create and return the server object to us.
We then hook in the required signal handlers, the difference to the client being we want
CLIENT events this time instead of SERVER events.
</para>

<example>
<title>Ecore_Ipc client: main end</title>
<programlisting>
    ecore_main_loop_begin();

    ecore_ipc_server_del(server);
    ecore_ipc_shutdown();
    ecore_shutdown();
    return 0;
}
</programlisting>
</example>
<para>
This again is identical to the client shutdown, minus the sending of data to the server.
</para>

<example>
<title>Ecore_Ipc server: sig_exit callback</title>
<programlisting>
</programlisting>
</example>
<para>
The sig_exit_cb() is again identical to that seen in the client.
</para>

<example>
<title>Ecore_Ipc server: the callbacks</title>
<programlisting>
int handler_client_add(void *data, int ev_type, void *ev) {
    Ecore_Ipc_Event_Client_Add *e = (Ecore_Ipc_Event_Client_Add *)ev;
    printf("client %p connected to server\n", e->client);
    return 1;
}

int handler_client_del(void *data, int ev_type, void *ev) {
    Ecore_Ipc_Event_Client_Del *e = (Ecore_Ipc_Event_Client_Del *)ev;
    printf("client %p disconnected from server\n", e->client);
    return 1;
}

int handler_client_data(void *data, int ev_type, void *ev) {
    Ecore_Ipc_Event_Client_Data *e = (Ecore_Ipc_Event_Client_Data *)ev;
    printf("client %p sent [%i] [%i] [%i] (%s)\n", e->client, e->major,
                                e->minor, e->size, (char *)e->data);
    
    ecore_ipc_client_send(e->client, 3, 4, 0, 0, 0, "Pants On!", 9);
    return 1;
}
</programlisting>
</example>
<para>
The event callbacks are similar to those seen in the client app. The main
difference is that the events are _Client_ events instead of _Server_ events.
</para>

<para>
The add callback is when a client connects to our server, with the del callback
being its opposite when the client disconnects. The data callback is for
when a client sends data to the server.
</para>

<para>
At the end of the handler_client_data callback we do a call to ecore_ipc_client_send().
This sends data to the client. As with sending data to the server, the parameters are:
the client to send to, major number, minor number, reference, reference to, response, 
data and the data size.
</para>

<example>
<title>Ecore_Ipc: compilation</title>
<programlisting>
CC = gcc
    
all: server client

server: server.c
    $(CC) -o server server.c `ecore-config --cflags --libs`
    
client: client.c
    $(CC) -o client client.c `ecore-config --cflags --libs`

clean:
    rm server client
</programlisting>
</example>
<para>
As with other ecore apps, it is very easy to compile an Ecore_Ipc app. As long as your
Ecore was compiled with Ecore_Ipc, simply invoking the 'ecore-config --cflags --libs' command
will add all of the required library paths and linker information.
</para>

<para>
As seen in this example, Ecore_Ipc is an easy to use library to create client/server
apps.
</para>


</section>

</chapter>
