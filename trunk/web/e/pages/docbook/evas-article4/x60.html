<HTML
><HEAD
><TITLE
>Creating and tweaking canvases</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Evas Presentation, Part 4: mouse events processing and canvases"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Processing mouse events"
HREF="x19.html"><LINK
REL="NEXT"
TITLE="Next time"
HREF="x106.html"></HEAD
><BODY
CLASS="SECTION"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Evas Presentation, Part 4: mouse events processing and canvases</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x19.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x106.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="AEN60">2. Creating and tweaking canvases</H1
><P
>In all our examples, we've always used evas_new() to  create a canvas,
and then other functions to modify it. There is however a much more powerful
function to create a canvas and initialize its parameters all at the same time:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Evas evas_new_all(Display *display, Window parent_window,
                  int x, int y,
                  int width, int height,
                  Evas_Render_Method render_method,
                  int colors,
                  int font_cache, int image_cache,
                  char *font_directory);</PRE
></FONT
></TD
></TR
></TABLE
><P
>The 'display' parameter is the link to the X server. The actual value can be
set by a call to XOpenDisplay(), just like for any program that uses the
X Window System. 'parent_window' is the window in which Evas' rendering window
will be created. If this window has to be managed by the window manager, just
use RootWindow(display,DefaultScreen(display)) instead of 'parent_window'.</P
><P
>The 'x','y','width' and 'height' parameters define the location and size of
our new window inside its parent window.</P
><P
>The 'render_method' parameter tells Evas which rendering method to use to 
display the canvas in the window. The type of 'render_method' is 
Evas_Render_Method, and the possible values are:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>RENDER_METHOD_ALPHA_SOFTWARE, which uses Imlib2: good quality rendering, but
quite slow.
RENDER_METHOD_BASIC_HARDWARE, which uses X11: bad quality rendering (no 
transparency), but much faster.
RENDER_METHOD_3D_HARDWARE, which uses OpenGL: good quality rendering, very
fast if a 3D card is present and very slow if not.
RENDER_METHOD_IMAGE, which uses Imlib2: reserved for canvases which are not
tied to a window. Hardly ever used. </PRE
></FONT
></TD
></TR
></TABLE
><P
>The 'colors' parameter is used only if X isn't able of displaying more than 256
colors. It tells Evas the number of available colors for the rendering. The
value ranges from 2 to 256.</P
><P
>The 'font_cache' and 'image_cache' indicate how many bytes Evas must
reserve to accelerate the rendering. In more details, 'font_cache' is the 
size in bytes of a pixel area Evas can use to compute and store the rendering of
letters. If the same text must be displayed several times, this can
accelerate a lot the rendering. 'image_cache' does the same for images. </P
><P
>Finally, 'font_directory' specifies in which directory to look for the fonts
used by this canvas.</P
><P
>Of course, it is possible to get the parameters of an existing canvas. For
example, the rendering window is returned by this function:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Window evas_get_window(Evas canvas);</PRE
></FONT
></TD
></TR
></TABLE
><P
>In the same way, the following functions return the display, the visual
(which is an X11 descriptor that specifies the number of available colors,
whether these colors are indexed or not, etc) and the color map associated
to a canvas:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Display *evas_get_display(Evas canvas);
Visual *evas_get_visual(Evas canvas);
Colormap evas_get_colormap(Evas canvas);</PRE
></FONT
></TD
></TR
></TABLE
><P
>Some X servers are able to use several visuals or color maps at the same
time. However there is always a better combination. These functions return
the best visual and the best colormap to use for a given canvas and display:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Visual *evas_get_optimal_visual(Evas canvas, Display *display);
Colormap evas_get_optimal_colormap(Evas canvas, Display *display);</PRE
></FONT
></TD
></TR
></TABLE
><P
>In the case of a rendering on a visual that uses indexed colors, this function
returns the number of colors allocated by a canvas:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>int evas_get_colors(Evas canevas);</PRE
></FONT
></TD
></TR
></TABLE
><P
>The rendering method used by a canvas is returned by this function:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Evas_Render_Method evas_get_output_method(Evas canvas);</PRE
></FONT
></TD
></TR
></TABLE
><P
>This function returns the size of the rendering window:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_get_drawable_size(Evas canevas, int *width, int *height);</PRE
></FONT
></TD
></TR
></TABLE
><P
>And the canvas part that is currently displayed in the window is returned by:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_get_viewport(Evas canevas,
                       double *x, double *y,
                       double *width, double *height);</PRE
></FONT
></TD
></TR
></TABLE
><P
>This function is useful because a canvas isn't always displayed in whole in a
window: it can be zoomed on or scrolled, for example. The 'x' and 'y' 
coordinates, and the size of the window are returned in the canvas'
coordinate space.</P
><P
>All these properties can also be modified later in the program. This function:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_set_output(Evas canvas,
                     Display *display, Drawable drawable,
                     Visual *visual, Colormap color_map);</PRE
></FONT
></TD
></TR
></TABLE
><P
>can be used to change the window (drawable), the display as well as the visual
and colormap associated to a canvas. This makes it possible to display the
same canvas in two different windows.</P
><P
>The number of colors used by a canvas can also be changed:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_set_output_colors(Evas canvas, int colors);</PRE
></FONT
></TD
></TR
></TABLE
><P
>If the size of a canvas is modified during the execution of a program, Evas
must be informed:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_set_output_size(Evas canvas,
                          int width, int height);</PRE
></FONT
></TD
></TR
></TABLE
><P
>As mentioned above, it is possible to display only a part of a canvas in the
rendering window:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_set_output_viewport(Evas canvas,
                              double x, double y,
                              double width, double height);</PRE
></FONT
></TD
></TR
></TABLE
><P
>The 'x' and 'y' parameters are the upper left corner of the window in the
canvas, and 'width' and 'height' are the size of the window in the canvas.
To do this, Evas can stretch or shrink the pixels of the canvas in order
to make fit the requested area in the window.</P
><P
>By default, when Evas zooms (in or out), in order to reduce aliasing, it smoothes the object, the result being usually much nicer to the eye.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>This function (de)activates the smoothing effect on a canves:
void evas_set_scale_smoothness(Evas canevas, int smoothing);
If 'smoothing' is set to 0, Evas won't smoothe the objects. </PRE
></FONT
></TD
></TR
></TABLE
><P
>Finally, the rendering method also can be changed:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_set_output_method(Evas canvas, Evas_Render_Method method);</PRE
></FONT
></TD
></TR
></TABLE
><P
>When a canvas isn't used anymore, the memory it allocated should be freed:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_free(Evas canvas);</PRE
></FONT
></TD
></TR
></TABLE
><P
>Let's now see an example program that uses some of the functions described 
above:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/* mouse events processing */
#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;
#include &#60;Evas.h&#62;

/* highlight : shades the button in blue when the mouse pointer is over it */
void highlight(void *rectangle, Evas canvas, Evas_Object object,
                  int button, int x, int y)
{
  evas_set_color(canvas, rectangle, 0,  0,  255, 180);
}

/* my_exit: this function is called when the rectangle is clicked */
void my_exit(void *data, Evas canvas, Evas_Object object,
            int button, int x, int y)
{
  printf("exit\n");
  exit(0);
}

int main(int argc, char *argv[])
{
  Display     *display;
  Window       window;
  Evas         canvas;
  Evas_Object  rectangle, text;

  /* Canvas creation */
  display = XOpenDisplay(NULL);
  canvas = evas_new_all(display,
                         RootWindow(display, DefaultScreen(display)),
                         100, 100, 300, 200,
                         RENDER_METHOD_ALPHA_SOFTWARE,
                         256, 0, 0, "./");
  window = evas_get_window(canvas);
  XSelectInput(display, window, ButtonPressMask | ButtonReleaseMask 
                  | PointerMotionMask);
  XMapWindow(display, window);
  XSync(display, False);
  /* setting the size of the canvas to that of the window */
  evas_set_output_size(canvas, 300, 200);
  
  /* some text */
  text = evas_add_text(canvas, "grunge", 20, "Vive Evas !");
  evas_show(canvas, text);
  evas_set_color(canvas, text, 255, 255, 255, 255);
  evas_move(canvas, text, 50, 70);

  /* this rectangle will be used as a button */
  rectangle = evas_add_rectangle(canvas);
  evas_show(canvas, rectangle);
  evas_set_color(canvas, rectangle, 0, 255, 0, 180);
  evas_move(canvas, rectangle, 50, 50);
  evas_resize(canvas, rectangle, 200, 100);

  /* connecting callback functions to our rectangle */
  evas_callback_add(canvas, rectangle, CALLBACK_MOUSE_DOWN, my_exit, NULL);
  evas_callback_add(canvas, rectangle, CALLBACK_MOUSE_MOVE, highlight, rectangle);

  /* updating */
  evas_update_rect(canvas, 0, 0, 300, 200);
  evas_render(canvas);

  /* event processing loop */
  for (;;)
  {
    XEvent ev;

    /* waiting for the next event */
    XNextEvent(display, );
    switch (ev.type)
    {
      case MotionNotify: /* the mouse moved */
        evas_set_color(canvas, rectangle, 0,  255, 0, 180);
        evas_event_move(canvas, ev.xmotion.x, ev.xmotion.y);
        break;

      case ButtonPress: /* a mouse button has been pressed */
        evas_event_button_down(canvas, ev.xbutton.x, ev.xbutton.y, ev.xbutton.button);
        break;

      case ButtonRelease: /* a mouse button has been released */
        evas_event_button_up(canvas, ev.xbutton.x, ev.xbutton.y, ev.xbutton.button);
        break;
      default:
        break;
    }
    evas_update_rect(canvas, 0, 0, 300, 200);
    evas_render(canvas);
  }
  return 0;
}</PRE
></FONT
></TD
></TR
></TABLE
><P
>compile as usual with this command in your favorite shell:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>gcc mouse.c -o mouse -O2 -g -Wall `evas-config --cflags --libs`</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x19.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x106.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Processing mouse events</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Next time</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>