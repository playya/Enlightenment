<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN">

<article>

<articleinfo>
        <title>Evas Presentation, Part 4: mouse events processing and canvases</title>

        <author>
                <firstname>David</firstname>
                <surname>Odin</surname>
		<affiliation>
                	<address><email>David@dindinx.org</email></address>
		</affiliation>
        </author>

	<othercredit>
    		<firstname>Romain</firstname>
    		<surname>Lerallut</surname>
    		<contrib>Translation to English</contrib>
		 <affiliation>
                        <address><email>rlerallut@free.fr</email></address>
                </affiliation>
	</othercredit>

        <abstract>
        <para>
In the past articles, we saw that Evas could display several
kinds of graphical objects, get and set these objects' properties, etc.
Evas also has support for processing mouse events. Furthermore, functions
exist to fine-tune Evas' behavior. This is what we'll see this month.
        </para>
        </abstract>
</articleinfo>


<section>
<title>Processing mouse events</title>

<para>
Evas has support for simple mouse operations. For a start, it is possible to
know whether the mouse is currently over a given canvas:
</para>

<screen>
int evas_pointer_in(Evas canvas);
</screen>

<para>
This function returns 1 if the mouse is over the canvas, and 0 if not.
</para>


<para>
If the mouse pointer is over a canvas, the following function returns the 
object located under it:
</para>
<screen>
Evas_Object evas_get_object_under_mouse(Evas canvas);
</screen>

<para>
The return value is NULL if the pointer isn't over an object, or else it is
a pointer to that object.
</para>

<para>
For more precision, the mouse pointer's coordinates over a canvas can be
found by calling this function:
</para>

<screen>
void evas_pointer_pos(Evas canvas, int *x, int *y);
</screen>

<para>
After the call, the integers x and y point to will be set to the mouse's
position in the canvas.
</para>

<para>
It is also possible to know whether a button is pressed:
</para>
<screen>
int evas_pointer_buttons(Evas canvas);
</screen>

<para>
The return value must be interpreted as a bitfield: bit 0 is the left button,
bit 1 the middle button and bit 2 the right button. The following bit of code
illustrates how this function could be used:
</para>

<screen>  
   int buttons;
   ...
   buttons = evas_pointer_buttons(canvas);

   if (buttons & 1) /* Note: 1 ==  1 << 0  , so we just write 1 */
   { /* the left mouse button is pressed */

   }

   if (buttons & 1<<2)
   { /* the right mouse button is pressed */

   }
 /***************************************************/
</screen>

<para>
Actually, Evas doesn't directly know where the mouse pointer is, or whether
the buttons are pressed or not. And so there are functions that can give
Evas these informations. The first one is:
</para>

<screen>
void evas_event_button_down(Evas canvas, int x, int y, int button);
</screen>

<para>
This function informs Evas that a button of the mouse has been pressed while
the pointer was at (x,y) over the 'canvas' canvas. The 'button' parameter
indicates which button has been pressed. It must be between 1 and 32 (just
in case you have a 32-button mouse !). This function only supports 
single-button presses.
</para>

<para>
Evas considers the button to be pressed (and will tell us that it is with
evas_pointer_buttons()) until the following function is called with the same
button number as argument:
</para>
<screen>
void evas_event_button_up(Evas canvas, int x, int y, int button);
</screen>

<para>
The job of that function is to inform Evas that the 'button' button has been
released at (x,y) on the 'canvas' canvas.
</para>

<para>
In the same fashion, Evas can be informed of the mouse pointer's current position:
</para>

<screen>
void evas_event_move(Evas canvas, int x, int y);
</screen>


<para>
However, one must keep in mind that the coordinates of the screen (and thus
of the mouse) are not necessarily those of the canvas (which can have been
moved or resized). The following functions can be used to switch between to
coordinates systems.
</para>

<para>
These two convert the horizontal and vertical coordinates on the canvas to
screen coordinates:
</para>

<screen>
int evas_world_x_to_screen(Evas canvas, double x);
int evas_world_y_to_screen(Evas canvas, double y);
</screen>

<para>
Whereas these two have the opposite job:
</para>

<screen>
double evas_screen_x_to_world(Evas canvas, int x);
double evas_screen_y_to_world(Evas canvas, int y);
</screen>

<para>
The last information about the mouse Evas can be given are when the pointer
enters or leaves a canvas:
</para>

<screen>
void evas_event_enter(Evas canvas);
void evas_event_leave(Evas canvas);
</screen>

   
<para>
At first sight, it seems extremely stupid to have to tell Evas where the mouse
pointer is , to be able to ask it again. Actually, it hides a very powerful
feature. To understand it all, let's examine the following function:
</para>

<screen>
void evas_callback_add(Evas canvas,
                       Evas_Object object,
                       Evas_Callback_Type callback,
                       void (*function) (),
                       void *extra_data);
</screen>

<para>
This functions attaches function 'function' to object 'object' on the 
'canvas' canvas. This way, the function will be automatically called 
when evas_event_*() functions are called, if they correspond to the 
callback type specified. This parameter can take the following values:
</para>

<screen>
CALLBACK_MOUSE_IN, corresponding to the function evas_event_enter();
CALLBACK_MOUSE_OUT, corresponding to the function evas_event_leave(); 
CALLBACK_MOUSE_DOWN, corresponding to the function evas_event_button_down();
CALLBACK_MOUSE_UP, corresponding to the function evas_event_button_up();
CALLBACK_MOUSE_MOVE, corresponding to the function evas_event_move();
CALLBACK_FREE, when the object is destroyed.
</screen>


<para>
For example, if we call evas_callback_add() with these arguments:
</para>

<screen>
evas_callback_add(my_canvas, my_object,
                  CALLBACK_MOUSE_DOWN,
                  function, extra_data);
</screen>

<para>
Then the next time that evas_event_button_down() is called for a mouse click
on 'my_object' the function 'function' will be called. The prototype of
'function' must be:
</para>

<screen>
void fonction(void *extra_data, Evas canvas, Evas_Object object,
              int button, int x, int y);
</screen>

<para>
This system can be compared to callback functions system in GTK+.
</para>

<para>
To remove the association between a function, a type of  event and an object,
use this function:
</para>

<screen>
void evas_callback_del(Evas canvas, Evas_Object object,
                       Evas_Callback_Type callback);
</screen>

</section>

<section>
<title>Creating and tweaking canvases</title>

<para>
In all our examples, we've always used evas_new() to  create a canvas,
and then other functions to modify it. There is however a much more powerful
function to create a canvas and initialize its parameters all at the same time:
</para>

<screen>
Evas evas_new_all(Display *display, Window parent_window,
                  int x, int y,
                  int width, int height,
                  Evas_Render_Method render_method,
                  int colors,
                  int font_cache, int image_cache,
                  char *font_directory);
</screen>

<para>
The 'display' parameter is the link to the X server. The actual value can be
set by a call to XOpenDisplay(), just like for any program that uses the
X Window System. 'parent_window' is the window in which Evas' rendering window
will be created. If this window has to be managed by the window manager, just
use RootWindow(display,DefaultScreen(display)) instead of 'parent_window'.
</para>

<para>
The 'x','y','width' and 'height' parameters define the location and size of
our new window inside its parent window.
</para>

<para>
The 'render_method' parameter tells Evas which rendering method to use to 
display the canvas in the window. The type of 'render_method' is 
Evas_Render_Method, and the possible values are:
</para>

<screen>
RENDER_METHOD_ALPHA_SOFTWARE, which uses Imlib2: good quality rendering, but
quite slow.
RENDER_METHOD_BASIC_HARDWARE, which uses X11: bad quality rendering (no 
transparency), but much faster.
RENDER_METHOD_3D_HARDWARE, which uses OpenGL: good quality rendering, very
fast if a 3D card is present and very slow if not.
RENDER_METHOD_IMAGE, which uses Imlib2: reserved for canvases which are not
tied to a window. Hardly ever used. 
</screen>

<para>
The 'colors' parameter is used only if X isn't able of displaying more than 256
colors. It tells Evas the number of available colors for the rendering. The
value ranges from 2 to 256.
</para>

<para>
The 'font_cache' and 'image_cache' indicate how many bytes Evas must
reserve to accelerate the rendering. In more details, 'font_cache' is the 
size in bytes of a pixel area Evas can use to compute and store the rendering of
letters. If the same text must be displayed several times, this can
accelerate a lot the rendering. 'image_cache' does the same for images. 
</para>

<para>
Finally, 'font_directory' specifies in which directory to look for the fonts
used by this canvas.
</para>

<para>
Of course, it is possible to get the parameters of an existing canvas. For
example, the rendering window is returned by this function:
</para>

<screen>
Window evas_get_window(Evas canvas);
</screen>

<para>
In the same way, the following functions return the display, the visual
(which is an X11 descriptor that specifies the number of available colors,
whether these colors are indexed or not, etc) and the color map associated
to a canvas:
</para>

<screen>
Display *evas_get_display(Evas canvas);
Visual *evas_get_visual(Evas canvas);
Colormap evas_get_colormap(Evas canvas);
</screen>

<para>
Some X servers are able to use several visuals or color maps at the same
time. However there is always a better combination. These functions return
the best visual and the best colormap to use for a given canvas and display:
</para>
<screen>
Visual *evas_get_optimal_visual(Evas canvas, Display *display);
Colormap evas_get_optimal_colormap(Evas canvas, Display *display);
</screen>

<para>
In the case of a rendering on a visual that uses indexed colors, this function
returns the number of colors allocated by a canvas:
</para>

<screen>
int evas_get_colors(Evas canevas);
</screen>

<para>
The rendering method used by a canvas is returned by this function:
</para>

<screen>
Evas_Render_Method evas_get_output_method(Evas canvas);
</screen>

<para>
This function returns the size of the rendering window:
</para>

<screen>
void evas_get_drawable_size(Evas canevas, int *width, int *height);
</screen>

<para>
And the canvas part that is currently displayed in the window is returned by:
</para>

<screen>
void evas_get_viewport(Evas canevas,
                       double *x, double *y,
                       double *width, double *height);
</screen>

<para>
This function is useful because a canvas isn't always displayed in whole in a
window: it can be zoomed on or scrolled, for example. The 'x' and 'y' 
coordinates, and the size of the window are returned in the canvas'
coordinate space.
</para>

<para>
All these properties can also be modified later in the program. This function:
</para>

<screen>
void evas_set_output(Evas canvas,
                     Display *display, Drawable drawable,
                     Visual *visual, Colormap color_map);
</screen>

<para>
can be used to change the window (drawable), the display as well as the visual
and colormap associated to a canvas. This makes it possible to display the
same canvas in two different windows.
</para>

<para>
The number of colors used by a canvas can also be changed:
</para>

<screen>
void evas_set_output_colors(Evas canvas, int colors);
</screen>

<para>
If the size of a canvas is modified during the execution of a program, Evas
must be informed:
</para>

<screen>
void evas_set_output_size(Evas canvas,
                          int width, int height);
</screen>

<para>
As mentioned above, it is possible to display only a part of a canvas in the
rendering window:
</para>

<screen>
void evas_set_output_viewport(Evas canvas,
                              double x, double y,
                              double width, double height);
</screen>

<para>
The 'x' and 'y' parameters are the upper left corner of the window in the
canvas, and 'width' and 'height' are the size of the window in the canvas.
To do this, Evas can stretch or shrink the pixels of the canvas in order
to make fit the requested area in the window.
</para>

<para>
By default, when Evas zooms (in or out), in order to reduce aliasing, it smoothes the object, the result being usually much nicer to the eye.
</para>

<screen>
This function (de)activates the smoothing effect on a canves:
void evas_set_scale_smoothness(Evas canevas, int smoothing);
If 'smoothing' is set to 0, Evas won't smoothe the objects. 
</screen>

<para>
Finally, the rendering method also can be changed:
</para>

<screen>
void evas_set_output_method(Evas canvas, Evas_Render_Method method);
</screen>

<para>
When a canvas isn't used anymore, the memory it allocated should be freed:
</para>

<screen>
void evas_free(Evas canvas);
</screen>

<para>
Let's now see an example program that uses some of the functions described 
above:
</para>

<screen>
/* mouse events processing */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;Evas.h&gt;

/* highlight : shades the button in blue when the mouse pointer is over it */
void highlight(void *rectangle, Evas canvas, Evas_Object object,
                  int button, int x, int y)
{
  evas_set_color(canvas, rectangle, 0,  0,  255, 180);
}

/* my_exit: this function is called when the rectangle is clicked */
void my_exit(void *data, Evas canvas, Evas_Object object,
            int button, int x, int y)
{
  printf("exit\n");
  exit(0);
}

int main(int argc, char *argv[])
{
  Display     *display;
  Window       window;
  Evas         canvas;
  Evas_Object  rectangle, text;

  /* Canvas creation */
  display = XOpenDisplay(NULL);
  canvas = evas_new_all(display,
                         RootWindow(display, DefaultScreen(display)),
                         100, 100, 300, 200,
                         RENDER_METHOD_ALPHA_SOFTWARE,
                         256, 0, 0, "./");
  window = evas_get_window(canvas);
  XSelectInput(display, window, ButtonPressMask | ButtonReleaseMask 
                  | PointerMotionMask);
  XMapWindow(display, window);
  XSync(display, False);
  /* setting the size of the canvas to that of the window */
  evas_set_output_size(canvas, 300, 200);
  
  /* some text */
  text = evas_add_text(canvas, "grunge", 20, "Vive Evas !");
  evas_show(canvas, text);
  evas_set_color(canvas, text, 255, 255, 255, 255);
  evas_move(canvas, text, 50, 70);

  /* this rectangle will be used as a button */
  rectangle = evas_add_rectangle(canvas);
  evas_show(canvas, rectangle);
  evas_set_color(canvas, rectangle, 0, 255, 0, 180);
  evas_move(canvas, rectangle, 50, 50);
  evas_resize(canvas, rectangle, 200, 100);

  /* connecting callback functions to our rectangle */
  evas_callback_add(canvas, rectangle, CALLBACK_MOUSE_DOWN, my_exit, NULL);
  evas_callback_add(canvas, rectangle, CALLBACK_MOUSE_MOVE, highlight, rectangle);

  /* updating */
  evas_update_rect(canvas, 0, 0, 300, 200);
  evas_render(canvas);

  /* event processing loop */
  for (;;)
  {
    XEvent ev;

    /* waiting for the next event */
    XNextEvent(display, &ev);
    switch (ev.type)
    {
      case MotionNotify: /* the mouse moved */
        evas_set_color(canvas, rectangle, 0,  255, 0, 180);
        evas_event_move(canvas, ev.xmotion.x, ev.xmotion.y);
        break;

      case ButtonPress: /* a mouse button has been pressed */
        evas_event_button_down(canvas, ev.xbutton.x, ev.xbutton.y, ev.xbutton.button);
        break;

      case ButtonRelease: /* a mouse button has been released */
        evas_event_button_up(canvas, ev.xbutton.x, ev.xbutton.y, ev.xbutton.button);
        break;
      default:
        break;
    }
    evas_update_rect(canvas, 0, 0, 300, 200);
    evas_render(canvas);
  }
  return 0;
}
</screen>

<para>
compile as usual with this command in your favorite shell:
</para>

<screen>
gcc mouse.c -o mouse -O2 -g -Wall `evas-config --cflags --libs`
</screen>

</section>

<section>
<title>Next time</title>

<para>
Next time, we'll finish this presentation of Evas with the last functions
we haven't seen yet.
</para>
</section>

</acticle>
