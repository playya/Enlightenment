<HTML
><HEAD
><TITLE
>Processing mouse events</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Evas Presentation, Part 4: mouse events processing and canvases"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Evas Presentation, Part 4: mouse events processing and canvases"
HREF="index.html"><LINK
REL="NEXT"
TITLE="Creating and tweaking canvases"
HREF="x60.html"></HEAD
><BODY
CLASS="SECTION"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Evas Presentation, Part 4: mouse events processing and canvases</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="index.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x60.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="AEN19">1. Processing mouse events</H1
><P
>Evas has support for simple mouse operations. For a start, it is possible to
know whether the mouse is currently over a given canvas:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>int evas_pointer_in(Evas canvas);</PRE
></FONT
></TD
></TR
></TABLE
><P
>This function returns 1 if the mouse is over the canvas, and 0 if not.</P
><P
>If the mouse pointer is over a canvas, the following function returns the 
object located under it:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Evas_Object evas_get_object_under_mouse(Evas canvas);</PRE
></FONT
></TD
></TR
></TABLE
><P
>The return value is NULL if the pointer isn't over an object, or else it is
a pointer to that object.</P
><P
>For more precision, the mouse pointer's coordinates over a canvas can be
found by calling this function:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_pointer_pos(Evas canvas, int *x, int *y);</PRE
></FONT
></TD
></TR
></TABLE
><P
>After the call, the integers x and y point to will be set to the mouse's
position in the canvas.</P
><P
>It is also possible to know whether a button is pressed:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>int evas_pointer_buttons(Evas canvas);</PRE
></FONT
></TD
></TR
></TABLE
><P
>The return value must be interpreted as a bitfield: bit 0 is the left button,
bit 1 the middle button and bit 2 the right button. The following bit of code
illustrates how this function could be used:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  
   int buttons;
   ...
   buttons = evas_pointer_buttons(canvas);

   if (buttons &#38; 1) /* Note: 1 ==  1 &#60;&#60; 0  , so we just write 1 */
   { /* the left mouse button is pressed */

   }

   if (buttons &#38; 1&#60;&#60;2)
   { /* the right mouse button is pressed */

   }
 /***************************************************/</PRE
></FONT
></TD
></TR
></TABLE
><P
>Actually, Evas doesn't directly know where the mouse pointer is, or whether
the buttons are pressed or not. And so there are functions that can give
Evas these informations. The first one is:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_event_button_down(Evas canvas, int x, int y, int button);</PRE
></FONT
></TD
></TR
></TABLE
><P
>This function informs Evas that a button of the mouse has been pressed while
the pointer was at (x,y) over the 'canvas' canvas. The 'button' parameter
indicates which button has been pressed. It must be between 1 and 32 (just
in case you have a 32-button mouse !). This function only supports 
single-button presses.</P
><P
>Evas considers the button to be pressed (and will tell us that it is with
evas_pointer_buttons()) until the following function is called with the same
button number as argument:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_event_button_up(Evas canvas, int x, int y, int button);</PRE
></FONT
></TD
></TR
></TABLE
><P
>The job of that function is to inform Evas that the 'button' button has been
released at (x,y) on the 'canvas' canvas.</P
><P
>In the same fashion, Evas can be informed of the mouse pointer's current position:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_event_move(Evas canvas, int x, int y);</PRE
></FONT
></TD
></TR
></TABLE
><P
>However, one must keep in mind that the coordinates of the screen (and thus
of the mouse) are not necessarily those of the canvas (which can have been
moved or resized). The following functions can be used to switch between to
coordinates systems.</P
><P
>These two convert the horizontal and vertical coordinates on the canvas to
screen coordinates:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>int evas_world_x_to_screen(Evas canvas, double x);
int evas_world_y_to_screen(Evas canvas, double y);</PRE
></FONT
></TD
></TR
></TABLE
><P
>Whereas these two have the opposite job:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>double evas_screen_x_to_world(Evas canvas, int x);
double evas_screen_y_to_world(Evas canvas, int y);</PRE
></FONT
></TD
></TR
></TABLE
><P
>The last information about the mouse Evas can be given are when the pointer
enters or leaves a canvas:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_event_enter(Evas canvas);
void evas_event_leave(Evas canvas);</PRE
></FONT
></TD
></TR
></TABLE
><P
>At first sight, it seems extremely stupid to have to tell Evas where the mouse
pointer is , to be able to ask it again. Actually, it hides a very powerful
feature. To understand it all, let's examine the following function:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_callback_add(Evas canvas,
                       Evas_Object object,
                       Evas_Callback_Type callback,
                       void (*function) (),
                       void *extra_data);</PRE
></FONT
></TD
></TR
></TABLE
><P
>This functions attaches function 'function' to object 'object' on the 
'canvas' canvas. This way, the function will be automatically called 
when evas_event_*() functions are called, if they correspond to the 
callback type specified. This parameter can take the following values:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>CALLBACK_MOUSE_IN, corresponding to the function evas_event_enter();
CALLBACK_MOUSE_OUT, corresponding to the function evas_event_leave(); 
CALLBACK_MOUSE_DOWN, corresponding to the function evas_event_button_down();
CALLBACK_MOUSE_UP, corresponding to the function evas_event_button_up();
CALLBACK_MOUSE_MOVE, corresponding to the function evas_event_move();
CALLBACK_FREE, when the object is destroyed.</PRE
></FONT
></TD
></TR
></TABLE
><P
>For example, if we call evas_callback_add() with these arguments:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>evas_callback_add(my_canvas, my_object,
                  CALLBACK_MOUSE_DOWN,
                  function, extra_data);</PRE
></FONT
></TD
></TR
></TABLE
><P
>Then the next time that evas_event_button_down() is called for a mouse click
on 'my_object' the function 'function' will be called. The prototype of
'function' must be:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void fonction(void *extra_data, Evas canvas, Evas_Object object,
              int button, int x, int y);</PRE
></FONT
></TD
></TR
></TABLE
><P
>This system can be compared to callback functions system in GTK+.</P
><P
>To remove the association between a function, a type of  event and an object,
use this function:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_callback_del(Evas canvas, Evas_Object object,
                       Evas_Callback_Type callback);</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x60.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Evas Presentation, Part 4: mouse events processing and canvases</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Creating and tweaking canvases</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>