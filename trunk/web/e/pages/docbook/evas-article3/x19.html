<HTML
><HEAD
><TITLE
>Linked lists "à la Evas"</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Evas Presentation, Part 3: Object Properties"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Evas Presentation, Part 3: Object Properties"
HREF="index.html"><LINK
REL="NEXT"
TITLE="Data attached to objects"
HREF="x43.html"></HEAD
><BODY
CLASS="SECTION"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Evas Presentation, Part 3: Object Properties</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="index.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x43.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="AEN19">1. Linked lists "à la Evas"</H1
><P
>For some of its operations, Evas uses linked lists. Since they are
used as return values for some functions, we must know how to manipulate them.
Evas lists are doubly linked, and each element is of _Evas_List type. The type
of a pointer to an element (or a pointer to a list) is Evas_List. The
accessible fields of an element are 'data', a generic pointer (void*) to the
data the element holds, and 'prev' and 'next' which are pointers to the
previous and following elements in the list.</P
><P
>An empty list is simply represented by the NULL pointer. There are four 
functions that can add an element to a list. The first add an element at the 
end of the list:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Evas_List evas_list_append(Evas_List list, void *data);</PRE
></FONT
></TD
></TR
></TABLE
><P
>The 'list' parameter must be a list or the NULL pointer. The new element is
created, and its 'data' pointer will have the value provided by the 'data'
parameter. The function evas_list_append() returns a pointer to the start of
the list.</P
><P
>The following function works exactly in the same way, but it adds the element
at the start of the chain:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Evas_List evas_list_prepend(Evas_List list, void *data);</PRE
></FONT
></TD
></TR
></TABLE
><P
>The returned value is again a pointer to the start of the list, which happens
to be the new element (since it was inserted at the beginning).</P
><P
>The last two functions that add an element to a list are:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Evas_List evas_list_append_relative(Evas_List list, void *data, void *search);
Evas_List evas_list_prepend_relative(Evas_List list, void *data, void *search);</PRE
></FONT
></TD
></TR
></TABLE
><P
>They look for the element whose data is 'search'. If this element exists, a
new element is created with the 'data' data, and added after (respectively
before) it. If the element looked for does not exist the element is created
and added at the end (resp. the beginning) of the list.</P
><P
>To remove an element from a list, use this function:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Evas_List evas_list_remove_list(Evas_List list, Evas_List element);</PRE
></FONT
></TD
></TR
></TABLE
><P
>This removes the element 'element' from the list 'list', and returns a
pointer to the beginning of the list. The memory used by the removed element
is freed, but not necessarily the one used by its data.</P
><P
>It is also possible to remove an element even when only its data is known:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Evas_List evas_list_remove(Evas_List list, void *data);</PRE
></FONT
></TD
></TR
></TABLE
><P
>If more than one element have the same 'data' pointer, only the first is
removed. The return value is a pointer to the beginning of the list (which
can have changed if the removed element was the first one). If no element
contains the requested 'data' , this function has no effect.</P
><P
>To remove all the elements of a list, use:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Evas_List evas_list_free(Evas_List list);</PRE
></FONT
></TD
></TR
></TABLE
><P
>This function returns always NULL. The  memory taken by the elements is freed.</P
><P
>Finally, it is possible to know if an element holding some specific  data 
exists in the list:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void *evas_list_find(Evas_List list, void *data);</PRE
></FONT
></TD
></TR
></TABLE
><P
>This function returns 'data' is a match was found, or else returns NULL.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x43.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Evas Presentation, Part 3: Object Properties</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Data attached to objects</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>