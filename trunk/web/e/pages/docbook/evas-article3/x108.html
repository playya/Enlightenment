<HTML
><HEAD
><TITLE
>Image object properties</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Evas Presentation, Part 3: Object Properties"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Properties of polygon objects"
HREF="x101.html"><LINK
REL="NEXT"
TITLE="Next time"
HREF="x127.html"></HEAD
><BODY
CLASS="SECTION"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Evas Presentation, Part 3: Object Properties</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x101.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x127.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="AEN108">6. Image object properties</H1
><P
>Images have several interesting properties: for example, the following function
returns whether an image is completely opaque or not:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>int evas_get_image_alpha(Evas canvas, Evas_Object object);</PRE
></FONT
></TD
></TR
></TABLE
><P
>This function returns 0 if the object is not an image, or if it is completely
opaque. It returns 1 if the object is an image with transparency.</P
><P
>The size of the image (in pixels) can be different from that of the object
that displays it, since the image can have been scaled to fit the object.
The following function returns the size of the image itself, as opposed to 
that of the parent Evas object which displays it:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_get_image_size(Evas canvas, Evas_Object object,
                         int *width, int *height);</PRE
></FONT
></TD
></TR
></TABLE
><P
>As we saw last month, it is possible to define a border around the image that
will not be stretched or shrunk when the image itself is scaled. The 
parameters of this border are returned by calling this function:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_get_image_border(Evas canvas, Evas_Object object, int *left, int *right, int *top, int *bottom);</PRE
></FONT
></TD
></TR
></TABLE
><P
>The last four parameters are pointers to integers that will be set to the
left, right, top and bottom borders width FIXME of the image.</P
><P
>Finally, when loading an image from  a file, all kinds of errors can occur.
The following function can help identify the type of error:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Imlib_Load_Error evas_get_image_load_error(Evas canvas, Evas_Object object);</PRE
></FONT
></TD
></TR
></TABLE
><P
>The return value is one of the following, and can be used for some 
more advanced error management:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>IMLIB_LOAD_ERROR_NONE : the loading has succeeded
IMLIB_LOAD_ERROR_FILE_DOES_NOT_EXIST,
IMLIB_LOAD_ERROR_FILE_IS_DIRECTORY,
IMLIB_LOAD_ERROR_PERMISSION_DENIED_TO_READ,
IMLIB_LOAD_ERROR_NO_LOADER_FOR_FILE_FORMAT,
IMLIB_LOAD_ERROR_PATH_TOO_LONG,
IMLIB_LOAD_ERROR_PATH_COMPONENT_NON_EXISTANT,
IMLIB_LOAD_ERROR_PATH_COMPONENT_NOT_DIRECTORY,
IMLIB_LOAD_ERROR_PATH_POINTS_OUTSIDE_ADDRESS_SPACE,
IMLIB_LOAD_ERROR_TOO_MANY_SYMBOLIC_LINKS,
IMLIB_LOAD_ERROR_OUT_OF_MEMORY,
IMLIB_LOAD_ERROR_OUT_OF_FILE_DESCRIPTORS,
IMLIB_LOAD_ERROR_PERMISSION_DENIED_TO_WRITE,
IMLIB_LOAD_ERROR_OUT_OF_DISK_SPACE,
IMLIB_LOAD_ERROR_UNKNOWN</PRE
></FONT
></TD
></TR
></TABLE
><P
>The names are by themselves quite explicit.</P
><P
>Let's now see most of these functions in some example code.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/* properties */
#include &#60;stdlib.h&#62;
#include &#60;stdio.h&#62;
#include &#60;Evas.h&#62;

void highlight(Evas canvas, int index)
{
  double      x, y, width, height;
  double      x_text, y_text;
  Evas_Object rectangle, text;

  text = evas_object_get_named(canvas, "Texte");
  evas_get_geometry(canvas, text,
                    _text, _text, NULL, NULL);
  evas_text_at(canvas, text, index, , ,
               , );
  rectangle = evas_add_rectangle(canvas);
  evas_show(canvas, rectangle);
  evas_set_color(canvas, rectangle, 255, 0, 0, 128);
  evas_move(canvas, rectangle, x_text+x, y_text+y);
  evas_resize(canvas, rectangle, width, height);  
}

int main(int argc, char *argv[])
{
  XSetWindowAttributes  att;
  Display              *display;
  Visual               *visual;
  Colormap              colormap;
  Window                window;
  Evas                  canvas;
  Evas_Object           rectangle, text;
  int                   i;
  Evas_List             list;

  /* Creating the canvas */
  canvas = evas_new();
  /* Choosing the rendering method */
  evas_set_output_method(canvas, RENDER_METHOD_ALPHA_SOFTWARE);
  /* Getting the X Window variables */
  display = XOpenDisplay(NULL);
  visual = evas_get_optimal_visual(canvas, display);
  colormap = evas_get_optimal_colormap(canvas, display);

  /* Opening a window */
  att.colormap = colormap;
  window = XCreateWindow(display,
                          RootWindow(display, DefaultScreen(display)),
                          0, 0, 300, 200, 0,
                          imlib_get_visual_depth(display, visual),
                          InputOutput, visual, CWColormap, );
  XMapWindow(display, window);
  XSync(display, False);

  /* attaching the canvas to the window */
  evas_set_output(canvas, display, window, visual, colormap);

  /* setting the canvas' size to that of the window */
  evas_set_output_size(canvas, 300, 200);
  evas_set_output_viewport(canvas, 0, 0, 300, 200);

  /* Drawing a bunch of rectangles */
  for (i=0 ; i&#60;100 ; i++)
  {
    int x1, y1, x2, y2;
    rectangle = evas_add_rectangle(canvas);
    evas_show(canvas, rectangle);
    evas_set_color(canvas, rectangle,
    rand()%256, rand()%256, rand()%256, rand()%256);
    x1 = rand()%300; y1 = rand()%100;
    x2 = rand()%300; y2 = rand()%100;
    evas_move(canvas, rectangle, x1, y1);
    evas_resize(canvas, rectangle, x2-x1, y2-y1);
    evas_put_data(canvas, rectangle, "x1", (void*)x1);
    evas_put_data(canvas, rectangle, "x2", (void*)x2);
    evas_put_data(canvas, rectangle, "y1", (void*)y1);
    evas_put_data(canvas, rectangle, "y2", (void*)y2);
  }

  /* some text */
  text = evas_add_text(canvas, "grunge", 20, "Vive Evas !");
  evas_object_set_name(canvas, text, "Texte");
  evas_show(canvas, text);
  evas_set_color(canvas, text, 255, 255, 255, 255);
  evas_move(canvas, text, 20, 100);

  /* highlighting the letters of 'Evas' */
  for (i=5 ; i&#60;9 ; i++)
    highlight(canvas, i);
 
  /* asking Evas to display it all */
  evas_update_rect(canvas, 0, 0, 300, 200);
  evas_render(canvas);

  /* display the properties of some rectangles */
  list = evas_objects_in_rect(canvas, 20, 20, 260, 160);
  while (list)
  {
    int x1, x2, y1, y2, rouge, vert, bleu, opacite;
    rectangle = (Evas_Object)(list-&#62;data);
    
    /* coordinates */
    x1 = (int)evas_get_data(canvas, rectangle, "x1");
    x2 = (int)evas_get_data(canvas, rectangle, "x2");
    y1 = (int)evas_get_data(canvas, rectangle, "y1");
    y2 = (int)evas_get_data(canvas, rectangle, "y2");
    /* color */
    evas_get_color(canvas, rectangle,
                   , , , );
    
    printf("(%d, %d) - (%d, %d) &#60;%d, %d, %d,  %d&#62;\n",
           x1, y1, x2, y2, rouge, vert, bleu, opacite);
    list = evas_list_remove_list(list, list);
  }
  
  /* infinite loop so that we have time to admire it all */
  for (;;);
  return 0;
}</PRE
></FONT
></TD
></TR
></TABLE
><P
>Compile the program like this:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>gcc evas.c -o evas -O2 -g -Wall `evas-config --cflags --libs`</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x101.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x127.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Properties of polygon objects</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Next time</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>