<HTML
><HEAD
><TITLE
>Images</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Evas presentation, Part2: Graphic Primitives"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Text"
HREF="x91.html"><LINK
REL="NEXT"
TITLE="Next time"
HREF="x126.html"></HEAD
><BODY
CLASS="SECTION"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Evas presentation, Part2: Graphic Primitives</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x91.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x126.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="AEN105">7. Images</H1
><P
>Finally, Evas is of course able to manage images.</P
><P
>To add an image object to a canvas, only the filename is needed:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Evas_Object evas_add_image_from_file(Evas canvas, char *filename);</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note that contrary to all Evas objects, image objects have by default
the size of their image. Even if the file can't be read, a completely
transparent object with a 0x0 size is created anyway.</P
><P
>The evas_set_color() function doesn't play the same role with image objects
as with the other types of objects. For an image, it sets color and opacity
values that will be used as a (multiplicative) filter for each pixel of the 
image. For example an evas_set_color(canvas, image, 0 ,0 ,255, 127); will
make this image completely blue (since the red and green values will be multiplied
by 0) and half transparent (127 begin about halfway between 0 and 255).</P
><P
>The file associated to an image object can be changed after its creation
by this function:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_set_image_file(Evas canvas, Evas_Object image, char * filename);</PRE
></FONT
></TD
></TR
></TABLE
><P
>This is very useful to create animations.</P
><P
>By default, the image is scaled to completely fill the image object, even if
the size of the object changes. To prevent this:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_set_image_fill(Evas canvas, Evas_Object object,
                         double x, double y,
                         double width, double height);</PRE
></FONT
></TD
></TR
></TABLE
><P
>After a call to this function, the image contained in the image object will
have the size defined by the 'width' and 'height' parameters, and will be
translated in the object so that its upper left corner is at coordinates (x,y)
in the image object. The image will be repeated as necessary in the four 
directions to completely fill the image object: "mosaic effect".</P
><P
>By default, when an image is scaled, all the image's pixels are stretched.
This is not always desirable. For example, in the case of a button with a
"3D" border: only the inside of the button should be stretched, but the 
borders should keep the same thickness, whatever the size of the button. This
can be realized by using the following function:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>void evas_set_image_border(Evas canvas, Evas_Object object,
                           int left, int right,
                           int top, int bottom);</PRE
></FONT
></TD
></TR
></TABLE
><P
>The parameters 'left', 'right', 'top' and 'bottom' indicate how many pixels
will not be stretched, starting from the edge of the image. This function is
directly taken from Imlib2.</P
><P
>Let's now see an example that uses all those primitives:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13;/* primitives */
#include &#60;stdlib.h&#62;
#include &#60;Evas.h&#62;

int main(int argc, char *argv[])
{
  XSetWindowAttributes  att;
  Display              *display;
  Visual               *visual;
  Colormap              colormap;
  Window                window;
  Evas                  canvas;
  Evas_Object           line, rectangle;
  Evas_Object           polygon, gradient;
  Evas_Object           text, image;
  Evas_Gradient         liste;
  int                   i, j;

  /* Creating the canvas */
  canvas = evas_new();
  /* choosing the rendering method */
  evas_set_output_method(canvas, RENDER_METHOD_ALPHA_SOFTWARE);
  /* the three usual X-Window variables */
  display = XOpenDisplay(NULL);
  visual = evas_get_optimal_visual(canvas, display);
  colormap = evas_get_optimal_colormap(canvas, display);

  /* Then we create the window with compatible parameters */
  att.colormap = colormap;
  window = XCreateWindow(display,
                          RootWindow(display, DefaultScreen(display)),
                          0, 0, 400, 600, 0,
                          imlib_get_visual_depth(display, visual),
                          InputOutput, visual, CWColormap, );
  XMapWindow(display, window);
  XSync(display, False);

  /* attaching the canvas to the window */
  evas_set_output(canvas, display, window, visual, colormap);

  /* setting the size of the canvas to that of the window */
  evas_set_output_size(canvas, 400, 600);
  evas_set_output_viewport(canvas, 0, 0, 400, 600);

  /* creating a few lines */
  for (i=0 ; i&#60;1000 ; i++)
  {
    line = evas_add_line(canvas);
    evas_show(canvas, line);
    evas_set_color(canvas, line,
                   rand()%256, rand()%256, rand()%256, rand()%256);
    evas_set_line_xy(canvas, line,
                     rand()%200, rand()%200,
                     rand()%200, rand()%200);
  
  } 
  /* a few rectangles */
  for (i=0 ; i&#60;100 ; i++)
  {
    int x1, y1, x2, y2;
    rectangle = evas_add_rectangle(canvas);
    evas_show(canvas, rectangle);
    evas_set_color(canvas, rectangle,
                   rand()%256, rand()%256, rand()%256, rand()%256);
    x1 = rand()%200; y1 = rand()%200;
    x2 = rand()%200; y2 = rand()%200;
    evas_move(canvas, rectangle, 200+x1, y1);
    evas_resize(canvas, rectangle, x2-x1, y2-y1);
  }

  /* polygons... */
  for (i=0 ; i&#60;20 ; i++)
  {
    polygon = evas_add_poly(canvas);
    evas_show(canvas, polygon);
    evas_set_color(canvas, polygon,
                   rand()%256, rand()%256, rand()%256, rand()%256);
    for (j=0 ; j&#60;5 ; j++)
      evas_add_point(canvas, polygon, rand()%200, 200+rand()%200);
  }

  /* two gradients */
  gradient = evas_add_gradient_box(canvas);
  evas_show(canvas, gradient);
  evas_resize(canvas, gradient, 200, 100);
  evas_move(canvas, gradient, 200, 200);
  liste = evas_gradient_new();
  evas_gradient_add_color(liste, 0, 0, 255, 255, 0);
  evas_gradient_add_color(liste, 255, 255, 255, 255, 100);
  evas_gradient_add_color(liste, 255, 0, 0, 255, 100);
  evas_set_gradient(canvas, gradient, liste);
  evas_set_angle(canvas, gradient, 270);
  
  gradient = evas_add_gradient_box(canvas);
  evas_show(canvas, gradient);
  evas_resize(canvas, gradient, 200, 100);
  evas_move(canvas, gradient, 200, 300);
  liste = evas_gradient_new();
  evas_gradient_add_color(liste, 0, 0, 255, 255, 0);
  evas_gradient_add_color(liste, 0, 0, 255, 255, 100);
  evas_gradient_add_color(liste, 255, 255, 255, 255, 0);
  evas_gradient_add_color(liste, 255, 255, 255, 255, 100);
  evas_gradient_add_color(liste, 255, 0, 0, 255, 0);
  evas_gradient_add_color(liste, 255, 0, 0, 255, 100);
  evas_set_gradient(canvas, gradient, liste);
  evas_set_angle(canvas, gradient, 270);
  
  /* some text */
  text = evas_add_text(canvas, "andover", 40, "Linux!");
  evas_show(canvas, text);
  evas_set_color(canvas, text, 255, 255, 255, 255);
  evas_move(canvas, text, 20, 450);

  /* and an image ! */
  image = evas_add_image_from_file(canvas, "sky001.png");
  evas_show(canvas, image);
  evas_set_color(canvas, image, 255, 255, 255, 255);
  evas_move(canvas, image, 200, 400);
 
  evas_update_rect(canvas, 0, 0, 400, 600);
  evas_render(canvas);
  /* infinite loop so that we have time to admire it all */
  for (;;);
  return 0;
}</PRE
></FONT
></TD
></TR
></TABLE
><P
>Compile this program from your favorite shell with this command:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>gcc primitives.c -o primitives -O2 -g -Wall `evas-config --cflags --libs`</PRE
></FONT
></TD
></TR
></TABLE
><P
>You should get something that looks like the screenshot included in these pages.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x91.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x126.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Text</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Next time</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>