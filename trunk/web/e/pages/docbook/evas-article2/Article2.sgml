<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN">

<article>

<articleinfo>
        <title>Evas presentation, Part2: Graphic Primitives</title>

        <author>
                <firstname>David</firstname>
                <surname>Odin</surname>
                <affiliation>
                        <address><email>David@dindinx.org</email></address>
                </affiliation>
        </author>

        <othercredit>
                <firstname>Romain</firstname>
                <surname>Lerallut</surname>
                <contrib>Translation to English</contrib>
                 <affiliation>
                        <address><email>rlerallut@free.fr</email></address>            
                </affiliation>
        </othercredit>                                                                

        <abstract>                                                        
        <para>
Last month, we took a brief look at Evas' drawing capabilities. Today, we'll
study in more details this library's graphic primitives and the six types of
objects Evas supports.
        </para>                                                         
        </abstract>
</articleinfo>                                                          



<section>
<title>The shapes Evas uses</title>
<para>
Evas' canvas can display a number of objects of different types. Evas supports
six types of objects:
<para>

<itemizedlist>
<listitem>
	<para>lines</para>
</listitem>
<listitem>
	<para>rectangles</para>
</listitem>
<listitem>
	<para>polygons</para>
</listitem>
<listitem>
	<para>color gradients</para>
</listitem>
<listitem>
	<para>text</para>
</listitem>
<listitem>
	<para>images</para>
</listitem>
</itemizedlist>

</section>

<section>
<title>Lines</title>

<para>
Lines are created with this function:
</para>
<screen>
Evas_Object evas_add_line(Evas canvas);
</screen>

<para>
The 'canvas' parameter indicates the canvas the line shall be drawn on. A line
can thus only belong to a single canvas at a time. The value returned is
an opaque structure that represents the line object.
</para>

<para>
Actually, an Evas_Object can point on any type of object that Evas can manipulate.
This makes it possible to have only one function to change to color of an
object, whatever its type is. That function is:
</para>

<screen>
void evas_set_color(Evas        canvas,
                    Evas_Object object,
                    int         red,
                    int         green,
                    int         blue,
                    int         alpha);
</screen>

<para>	
The 'object' parameter is the object which color will be changed. 'canvas' is
the canvas that displays the object. The parameters 'red', 'green' and 'blue'
define the objet's color components. Their values must be between 0 and 255. The
'alpha' parameter sets the opacity of the object, and its value is also between 0 
(completely transparent) and 255 (completely opaque).
</para>

<para>
After its creation, a line start on point (0,0) and ends on point (0,0),
which isn't very interesting. The following function is used to set the
coordinates of a line's extremities:
</para>

<screen>
void evas_set_line_xy(Evas        canvas,
                      Evas_Object line,
                      double x1, double y1,
                      double x2, double y2);
</screen>

<para>
After a call to this function, the 'line' object of the 'canvas' canvas will
be drawn from point (x1,y1) to point (x2,y2). 
</para>

<para>
However, objects created by Evas and placed on a canvas are by default
invisible. Use the following function to make them visible:
</para>

<screen>
void evas_show(Evas canvas, Evas_Object object);
</screen>

<para>
If afterwards an object must be temporarily hidden the corresponding function is:
</para>

<screen>
void evas_hide(Evas canvas, Evas_Object object);
</screen>

<para>
That function only makes the object invisible. It keeps its properties (colors,
size, etc) and uses up memory. To remove it completely from memory (it will
then not be usable anymore) use this function:
</para>

<screen>
void evas_del_object(Evas canvas, Evas_Object objet);
</screen>

</section>

<section>
<title>Rectangles</title>

<para>
The function to add a rectangle to a canvas is:
</para>

<screen>
Evas_Object evas_add_rectangle(Evas canvas);
</screen>

<para>
Just as for lines, a rectangle must be given a color, a size, a position, etc,
since by default the rectangle is black, transparent, at position (0,0) and
has a size of 1x1 pixel. For the color, just use evas_set_color(). However,
to set the position, use:
</para>

<screen>
void evas_move(Evas canvas, Evas_Object object,
               double x, double y);
</screen>

<para>
This function moves the upper left corner of the rectangle object to position
(x,y). This function can be used for all Evas objects with the exception of 
lines.
</para>

<para>
To define the size of a rectangle, use this function:
</para>

<screen>
void evas_resize(Evas canvas, Evas_Object object,
                 double width, double height);
</screen>

<para>
After this function call, the canvas' 'rectangle' object will have the
width 'width' and the height 'height'. This function can be used with rectangles,
gradients, and images.
</para>

<para>
Inversely, it is possible to know the current position and size of an object
with this function:
</para>

<screen>
void evas_get_geometry(Evas canvas, Evas_Object object,
                       double *x, double *y,
                       double *width, double *height);
</screen>
		       
<para>
The 'object' parameter is the object whose properties we want to know. It 
must belong to canvas 'canvas'. If parameters x and y are not NULL, they must
point to two double that will be set to the object's coordinates. In the same way,
if parameters width and height are not NULL, the doubles they point to will
 be respectively set to the object's width and height.
</para>

</section>
<section>
<title>Polygons</title>

<para>
Evas can also display polygons without restrictions on the number of sides. A
polygon is added to a canvas with the function:
</para>
<screen>
Evas_Object evas_add_poly(Evas canvas);
</screen>

<para>
The polygon created will not have any vertex and thus does not
really exist. The following function adds a point to a polygon:
</para>
<screen>
void evas_add_point(Evas canvas,
                    Evas_Object object,
                    double x, double y);
</screen>

<para>
The 'x' and 'y' parameters are the coordinates of the point we wish to
add to the object 'object' on the canvas 'canvas'.
</para>

<para>
To change the coordinates of the vertices of a polygon, the only solution
is to remove all the points and re-add the vertices with the new coordinates
with evas_add_point() function calls. The following function removes all the 
vertices of a polygon:
</para>

<screen>
void evas_clear_points(Evas canvas,
                       Evas_Object object);
</screen>

</section>

<section>
<title>Gradients</title>

<para>
The fourth type of objects Evas can use is the color gradient. A gradient is
really a rectangle filled with two-by-two color gradients in a given 
direction. Such a gradient is added to the canvas by the following function:
</para>

<screen>
Evas_Object evas_add_gradient_box(Evas canvas);
</screen>

<para>
The gradient's colors are specified by a list which type is 'Evas_Gradient'.
The list is created by this function:
</para>

<screen>
Evas_Gradient evas_gradient_new(void);
</screen>

<para>
By default, this list doesn't contain any color. Colors are added by this
function:
</para>

<screen>
void evas_gradient_add_color(Evas_Gradient list,
                             int red, int green, int blue,
                             int opacity, int distance);
</screen>

<para>
This adds the color defined by its red, green and blue values. The 
'opacity' parameter sets the opacity of the new color. The 'distance'
parameter sets the distance that separates the new color from the previous
one (it is ignored for the first color). This distance is relative to the
sum of all the distances in the list. For example if our list contains
only three colors: black, red and white, and the associated distances are
10 for red and 5 for white, we will get a gradient from black to red on
the two thirds of the rectangle and red to white on the remaining third.
To get a sharp cut between two colors (no smooth gradient), just use a
distance of 0.
</para>

<para>
Such a list must be freed from memory by the following function:
</para>

<screen>
void evas_gradient_free(Evas_Gradient grad);
</screen>

<para>
Once the list is created with the wanted colors (two at least!), it can
be attached to a gradient object by:
</para>

<screen>
void evas_set_gradient(Evas canvas,
                       Evas_Object gradient,
                       Evas_Gradient list);
</screen>

<para>
By default, the gradient is displayed in the rectangle from bottom to top.
However, it is possible to modify this direction:
</para>

<screen>
void evas_set_angle(Evas canvas,
                    Evas_Object gradient,
                    double angle);
</screen>

<para>
Le 'angle' parameter indicates the new direction, in degrees, counterclockwise
starting from the top.
</para>
</section>

<section>
<title>Text</title>

<para>
Evas can also display text, automatically using antialiasing if it's
needed. This function is used to displayed text on a canvas :
</para>

<screen>
Evas_Object evas_add_text(Evas canvas, char *font,
                          int size, char *text);
</screen>

<para>
The 'text' parameter is the text that the new object will display. 'size' is
the size in points of the font. The font is chosen by the 'font' parameter: it 
is the name of the font, without the suffix. For example, to display text
with "andover.ttf", the 'font' parameter to use is simply "andover".
</para>

<para>
Evas searches for the requested font in a list of directories. To add a 
directory to this list, use this:
</para>

<screen>
void evas_font_add_path(Evas canvas, char *directory);
</screen>

<para>
Note that each directory list is tied to a single canvas.
</para>

<para>
A directory can also be removed from the list with this function:
</para>

<screen>
void evas_font_del_path(Evas canvas, char *directory);
</screen>

<para>
It is possible to change the text of a text object after its creation with this
function:
</para>

<screen>
void evas_set_text(Evas canvas, Evas_Object object, char *text);
</screen>

<para>
It is possible as well to change the size and the font of a text object:
</para>
<screen>
void evas_set_font(Evas canvas, Evas_Object object,
                   char *font, int size);
</screen>

</section>

<section>
<title>Images</title>

<para>
Finally, Evas is of course able to manage images.
</para>

<para>
To add an image object to a canvas, only the filename is needed:
</para>
<screen>
Evas_Object evas_add_image_from_file(Evas canvas, char *filename);
</screen>

<para>
Note that contrary to all Evas objects, image objects have by default
the size of their image. Even if the file can't be read, a completely
transparent object with a 0x0 size is created anyway.
</para>

<para>
The evas_set_color() function doesn't play the same role with image objects
as with the other types of objects. For an image, it sets color and opacity
values that will be used as a (multiplicative) filter for each pixel of the 
image. For example an evas_set_color(canvas, image, 0 ,0 ,255, 127); will
make this image completely blue (since the red and green values will be multiplied
by 0) and half transparent (127 begin about halfway between 0 and 255).
</para>


<para>
The file associated to an image object can be changed after its creation
by this function:
</para>

<screen>
void evas_set_image_file(Evas canvas, Evas_Object image, char * filename);
</screen>

<para>
This is very useful to create animations.
</para>

<para>
By default, the image is scaled to completely fill the image object, even if
the size of the object changes. To prevent this:
</para>

<screen>
void evas_set_image_fill(Evas canvas, Evas_Object object,
                         double x, double y,
                         double width, double height);
</screen>

<para>
After a call to this function, the image contained in the image object will
have the size defined by the 'width' and 'height' parameters, and will be
translated in the object so that its upper left corner is at coordinates (x,y)
in the image object. The image will be repeated as necessary in the four 
directions to completely fill the image object: "mosaic effect".
</para>

<para>
By default, when an image is scaled, all the image's pixels are stretched.
This is not always desirable. For example, in the case of a button with a
"3D" border: only the inside of the button should be stretched, but the 
borders should keep the same thickness, whatever the size of the button. This
can be realized by using the following function:
</para>
<screen>
void evas_set_image_border(Evas canvas, Evas_Object object,
                           int left, int right,
                           int top, int bottom);
</screen>

<para>
The parameters 'left', 'right', 'top' and 'bottom' indicate how many pixels
will not be stretched, starting from the edge of the image. This function is
directly taken from Imlib2.
</para>

<para>
Let's now see an example that uses all those primitives:
</para>

<screen>

/* primitives */
#include &lt;stdlib.h&gt;
#include &lt;Evas.h&gt;

int main(int argc, char *argv[])
{
  XSetWindowAttributes  att;
  Display              *display;
  Visual               *visual;
  Colormap              colormap;
  Window                window;
  Evas                  canvas;
  Evas_Object           line, rectangle;
  Evas_Object           polygon, gradient;
  Evas_Object           text, image;
  Evas_Gradient         liste;
  int                   i, j;

  /* Creating the canvas */
  canvas = evas_new();
  /* choosing the rendering method */
  evas_set_output_method(canvas, RENDER_METHOD_ALPHA_SOFTWARE);
  /* the three usual X-Window variables */
  display = XOpenDisplay(NULL);
  visual = evas_get_optimal_visual(canvas, display);
  colormap = evas_get_optimal_colormap(canvas, display);

  /* Then we create the window with compatible parameters */
  att.colormap = colormap;
  window = XCreateWindow(display,
                          RootWindow(display, DefaultScreen(display)),
                          0, 0, 400, 600, 0,
                          imlib_get_visual_depth(display, visual),
                          InputOutput, visual, CWColormap, &att);
  XMapWindow(display, window);
  XSync(display, False);

  /* attaching the canvas to the window */
  evas_set_output(canvas, display, window, visual, colormap);

  /* setting the size of the canvas to that of the window */
  evas_set_output_size(canvas, 400, 600);
  evas_set_output_viewport(canvas, 0, 0, 400, 600);

  /* creating a few lines */
  for (i=0 ; i<1000 ; i++)
  {
    line = evas_add_line(canvas);
    evas_show(canvas, line);
    evas_set_color(canvas, line,
                   rand()%256, rand()%256, rand()%256, rand()%256);
    evas_set_line_xy(canvas, line,
                     rand()%200, rand()%200,
                     rand()%200, rand()%200);
  
  } 
  /* a few rectangles */
  for (i=0 ; i<100 ; i++)
  {
    int x1, y1, x2, y2;
    rectangle = evas_add_rectangle(canvas);
    evas_show(canvas, rectangle);
    evas_set_color(canvas, rectangle,
                   rand()%256, rand()%256, rand()%256, rand()%256);
    x1 = rand()%200; y1 = rand()%200;
    x2 = rand()%200; y2 = rand()%200;
    evas_move(canvas, rectangle, 200+x1, y1);
    evas_resize(canvas, rectangle, x2-x1, y2-y1);
  }

  /* polygons... */
  for (i=0 ; i<20 ; i++)
  {
    polygon = evas_add_poly(canvas);
    evas_show(canvas, polygon);
    evas_set_color(canvas, polygon,
                   rand()%256, rand()%256, rand()%256, rand()%256);
    for (j=0 ; j<5 ; j++)
      evas_add_point(canvas, polygon, rand()%200, 200+rand()%200);
  }

  /* two gradients */
  gradient = evas_add_gradient_box(canvas);
  evas_show(canvas, gradient);
  evas_resize(canvas, gradient, 200, 100);
  evas_move(canvas, gradient, 200, 200);
  liste = evas_gradient_new();
  evas_gradient_add_color(liste, 0, 0, 255, 255, 0);
  evas_gradient_add_color(liste, 255, 255, 255, 255, 100);
  evas_gradient_add_color(liste, 255, 0, 0, 255, 100);
  evas_set_gradient(canvas, gradient, liste);
  evas_set_angle(canvas, gradient, 270);
  
  gradient = evas_add_gradient_box(canvas);
  evas_show(canvas, gradient);
  evas_resize(canvas, gradient, 200, 100);
  evas_move(canvas, gradient, 200, 300);
  liste = evas_gradient_new();
  evas_gradient_add_color(liste, 0, 0, 255, 255, 0);
  evas_gradient_add_color(liste, 0, 0, 255, 255, 100);
  evas_gradient_add_color(liste, 255, 255, 255, 255, 0);
  evas_gradient_add_color(liste, 255, 255, 255, 255, 100);
  evas_gradient_add_color(liste, 255, 0, 0, 255, 0);
  evas_gradient_add_color(liste, 255, 0, 0, 255, 100);
  evas_set_gradient(canvas, gradient, liste);
  evas_set_angle(canvas, gradient, 270);
  
  /* some text */
  text = evas_add_text(canvas, "andover", 40, "Linux!");
  evas_show(canvas, text);
  evas_set_color(canvas, text, 255, 255, 255, 255);
  evas_move(canvas, text, 20, 450);

  /* and an image ! */
  image = evas_add_image_from_file(canvas, "sky001.png");
  evas_show(canvas, image);
  evas_set_color(canvas, image, 255, 255, 255, 255);
  evas_move(canvas, image, 200, 400);
 
  evas_update_rect(canvas, 0, 0, 400, 600);
  evas_render(canvas);
  /* infinite loop so that we have time to admire it all */
  for (;;);
  return 0;
}
</screen>

<para>
Compile this program from your favorite shell with this command:
</para>
<screen>
gcc primitives.c -o primitives -O2 -g -Wall `evas-config --cflags --libs`
</screen>

<para>
You should get something that looks like the screenshot included in these pages.
</para>

</section>

<section>
<title>Next time</title>
<para>
Next time, we will study in detail the properties of the objects Evas can
display, before we study the event processing system.
</para>

</section>
</article>
