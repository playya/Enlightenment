<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN">

<article>

<articleinfo>
        <title>Evas Presentation, Part 1: An Introduction to Evas</title>

        <author>
                <firstname>David</firstname>
                <surname>Odin</surname>
                <affiliation>
                        <address><email>David@dindinx.org</email></address>
                </affiliation>
        </author>

        <othercredit>
                <firstname>Romain</firstname>
                <surname>Lerallut</surname>
                <contrib>Translation to English</contrib>
                 <affiliation>
                        <address><email>rlerallut@free.fr</email></address>            
                </affiliation>
        </othercredit>                                                                

        <abstract>                                                        
        <para>
The new version of the Enlightenment window manager, aka E17, is still under development.
However, it is already in a completly usable state, and have many nifty graphic effects, being way beyond the other window
managers.  This technologic feat is mostly due to a very extensible and powerful library called Evas, which is a short for
"Enlightenment's Canvas".
        </para>                                                         
        </abstract>
</articleinfo>                                                          



<section>
<title>Installation</title>
<para>
Given that all this stuff is still at development stage, the prefered way to install it is often to use the CVS version.
This will allow you to get the latest innovations, and you may be able to help fixing the last bugs.
</para>

<para>In order to get the sources from CVS, you just have to issue these two lines:</para>

<programlisting>
cvs -d:pserver:anonymous@cvs.enlightenment.sourceforge.net:/cvsroot/enlightenment login
cvs -z3 -d:pserver:anonymous@cvs.enlightenment.sourceforge.net:/cvsroot/enlightenment co e17
</programlisting>

<para>These two lines will download everything from the Enlightenment's repository. In the toplevel directory, you'll find two
subdirectories: <emphasis>libs</emphasis>, which contains every e17-specific libraries, and <emphasis>apps</emphasis> which contains several programs
and enlightenment.</para>

<para>Every library in <emphasis>libs</emphasis> can be compiled and installed with the following sequence:</para>
<programlisting>
./autogen.sh
make
su -c "make install"
</programlisting>

<para>
However, you'll have to build everything in this order: edb, imlib2, imlib2_loaders, evas, ebits,
ecore, ewd,etox et ewl.
</para>

<para>
Obviously, for this little tutorial, you'll only need the first four.
</para>
</section>

<section>
<title>Somes basis</title>

<para>
Evas allow to draw lines, rectangles, texts, images or gradients, and all this with 256 levels of transparency. Also, every drawn
object can be resized or moved after its creation.</para>

<para>Each of these objects is put on a so-called <emphasis>canvas</emphasis> which must be created before any other operations. The type of an Evas canvas is simply <emphasis>Evas</emphasis>. The easiest way to create one is to use the following function:</para>

<programlisting>
Evas evas_new(void);
</programlisting>


<para>Then, we have to choose which rendering method Evas will use to draw the objects on the canvas. This can be achieved with the
following function:</para>

<programlisting>
void evas_set_output_method(Evas canvas, Evas_Render_Method method);
</programlisting>

<para>
The 'method' parameter should be one of these:
</para>

<itemizedlist>
<listitem>
<para><emphasis>RENDER_METHOD_ALPHA_SOFTWARE</emphasis>, Evas will use the Imlib2 library for all the drawing. This is a good compromise. This method will work well with every graphic card and the rendering will be very good.
</para>
</listitem>

<listitem>
<para><emphasis>RENDER_METHOD_BASIC_HARDWARE</emphasis>, Evas will only use the Xlib (the native X-Window library) to draw the objects.
There will be only 2 levels of transparency (any pixel will be either totally opaque or totally transparent) instead of 256. This
rendering method is very fast, but give poor results. This method should only be used on slow hardware.
</para>
</listitem>

<listitem>
<para><emphasis>RENDER_METHOD_3D_HARDWARE</emphasis>, Evas will use the accelerated facilities of your 3D graphic card. This is certainly the
fastest method if the graphic card does present an OpenGL acceleration, otherwise, it could be the slowest one! So use this method
only is you do own such a card.
</para>
</listitem>

<listitem>
<para><emphasis>RENDER_METHOD_IMAGE</emphasis>, with this method, Evas will only be able to draw into an Imlib2 picture, without actually displaying the result on the screen. This assumption will let Evas to do some optimisations. Nevertheless, this methood isn't very used in a regular application.
</para>
</listitem>
</itemizedlist>

<para>
After that, in order to show the whole thing, we must link the canvas to a Drawable (i.e. a Window or a Pixmap). This is done with
the following function:
</para>

<programlisting>
void evas_set_output(Evas canvas,
                     Display *display,
		     Drawable window,
		     Visual *visual,
		     Colormap colormap);
</programlisting>

<para>
The <emphasis>canvas</emphasis> parameter is obviously the canvas we want to link. <emphasis>display</emphasis> is an X-Window display, like the one
returned by <emphasis>XOpenDisplay()</emphasis>. <emphasis>visual</emphasis> and <emphasis>colormap</emphasis> should be a X-Window visual and a X-Window colormap
suitable for our canvas. The easiest way to get these two informations is to ask the following functions:
</para>
<programlisting>
Visual   *evas_get_optimal_visual(Evas canvas, Display *display);
Colormap  evas_get_optimal_colormap(Evas canvas, Display *display);
</programlisting>

<para>
And the <emphasis>window</emphasis> parameter of the <emphasis>evas_set_output()</emphasis> function should be a window or a pixmap (an off-screen window) to link the canvas to. This couuld be a window created with the <emphasis>XCreateWindow()</emphasis> function.
</para>

<para>
But relax, the sample code for this article will show how to do this without much problems. I've heard that someone is
developping a new library which let one use Evas within GTK windows, which should be very handy. I'll present this soon.
</para>

<para>
Before we could put objets on the canvas, we have to give it a size. It is often best to choose the same size as its linked
window, but it isn't the only option. This is done with the following function:
</para>

<programlisting>
void evas_set_output_size(Evas canvas, int width, int height);
</programlisting>

<para>
By default, the whole canvas is mapped to the whoole window. That is, a pixel from the canvas match exactly one pixel on the screen. There isn't such a limitation within Evas. So, the following function allow to choose which part of the canvas will be shown
in the window:
</para>

<programlisting>
void evas_set_output_viewport(Evas canevas, double x, double y, double width, double height);
</programlisting>

<para>The last four parameters define the rectangular part of the canvas which will be mapped to the window.
So, it is rather easy to make a zoom in/out effect by changing the <emphasis>width</emphasis> or <emphasis>height</emphasis> parameters or a scrolling
effect by changing the <emphasis>x</emphasis> or <emphasis>y</emphasis> parameters.
</para>
</section>

<section>
<title>The objects</title>

<para>
Once every parameter of a canvas is set, we can start putting object on it. The objects Evas can handle are images, texts,
rectangles, lines, color gradients or polygons. All these oobjects share the same type: <emphasis>Evas_Object</emphasis>. For instance, a
rectangle or a line can be created with these functions:
</para>

<programlisting>
Evas_Object evas_add_rectangle(Evas canvas);
Evas_Object evas_add_line(Evas canvas);
</programlisting>

<para>
Though, all created objects do not have a properly defined position, size nor color. These attributes are to be affected after the
creation. One can set the size of an object by using the following function:
</para>

<programlisting>
void evas_resize(Evas canvas, Evas_Object object,
                 double width, double height);
</programlisting>

<para>
And the size of an object can be set with this function:
</para>

<programlisting>
void evas_move(Evas canvas, Evas_Object object,
               double x, double y);
</programlisting>

<para>
Line objects are a little bit special, and instead of setting their size and position, we set directly the position of its ends
with this function:
</para>

<programlisting>
void evas_set_line_xy(Evas canvas, Evas_Object object,
                      double x1, double y1, double x2, double y2);
</programlisting>

<para>
To set the color of an object (line, texte or rectangle), we use the following function:
</para>

<programlisting>
void evas_set_color(Evas canvas, Evas_Object object,
                    int red, int green, int blue, int alpha);
</programlisting>

<para>
The <emphasis>red</emphasis>, <emphasis>green</emphasis> and <emphasis>blue</emphasis> parameters should be between 0 and 255 and set the color of the object. The
alpha parameter set the level of transluscency of the object; it also should be between 0 (totally transparent) and 255 (totally
opaque).
</para>

<para>
Just after creation, objects are hidden, even if placed on the canvas. To show them, we must use the following function:
</para>

<programlisting>
void evas_show(Evas canvas, Evas_Object object);
</programlisting>

<para>
This object could then be hidden afterward, by using this function:
</para>

<programlisting>
void evas_hide(Evas canvas, Evas_Object object);
</programlisting>

<para>
Once the objects are on the canvas, we can ask Evas to render the whole thing with this function:
</para>

<programlisting>
void evas_render(Evas canvas);
</programlisting>

<para>
Let's see all these functions in a sample program:
</para>

<programlisting>

#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;math.h&gt;
#include "Evas.h"

int main(int argc, char *argv[])
{
  XSetWindowAttributes  att;
  Display              *display;
  Visual               *visual;
  Colormap              colormap;
  Window                window;
  Evas                  canvas;
  Evas_Object           object, line;
  int                   i;

  /* Canvas creation */
  canvas = evas_new();
  /* rendering method */
  evas_set_output_method(canvas, RENDER_METHOD_ALPHA_SOFTWARE);
  /* let's get three X-Window important variables */
  display = XOpenDisplay(NULL);
  visual = evas_get_optimal_visual(canvas, display);
  colormap = evas_get_optimal_colormap(canvas, display);

  /* Then, we create a suitable window */
  att.colormap = colormap;
  window = XCreateWindow(display,
                         RootWindow(display, DefaultScreen(display)),
                         0, 0, 500, 500, 0,
                         imlib_get_visual_depth(display, visual),
                         InputOutput, visual, CWColormap, &amp;att);
  XMapWindow(display, window);
  XSync(display, False);

  /* link the canvas to the window */
  evas_set_output(canvas, display, window, visual, colormap);

  /* The size of the canvas should be equals to the window's size */
  evas_set_output_size(canvas, 500, 500);

  /* Let's create some transluscent rectangles */
  for (i=25 ; i&lt;250 ; i+=50)
  {
    object = evas_add_rectangle(canvas);
    evas_show(canvas, object);
    evas_move(canvas, object, 250-i, i);
    evas_resize(canvas, object, i*2, (250-i)*2);
    evas_set_color(canvas, object, i, i, 255-i, 150);
  }
  
  /* a little animation, changing the canvas scale factor */
  for (i=500 ; i&lt;1000 ; i+=50)
  {
    evas_set_output_viewport(canvas, 0, 0, i, i);
    
    evas_render(canvas);
  }
  evas_set_output_viewport(canvas, 0, 0, 500, 500);
  evas_render(canvas);

  /* At last, we move a line around: */
  line = evas_add_line(canvas);
  evas_show(canvas, line);
  evas_set_color(canvas, line, 255,255,255,255);
  for (i=0 ; i&lt;360 ; i+=5)
  {
    evas_set_line_xy(canvas, line,
                     50+50*sin(i*2*M_PI/180.0),
                     50+50*cos(i*3*M_PI/180.0),
                     450+50*sin(i*4*M_PI/180.0),
                     450+50*cos(i*5*M_PI/180.0));
    evas_update_rect(canvas, 0, 0, 500, 500);
    evas_render(canvas);
  }
  return 0;
}
</programlisting>

<para>
To compile this sample program, you can use the following command-line:
</para>

<programlisting>
gcc evas_test.c -o evas_test -O2 -g -Wall `evas-config --cflags --libs`
</programlisting>

<para>
Try to adjust some parameters to make sure you have understood each of them.
</para>
</section>
 
<section>
<title>Next time</title>
<para>
Next time, we'll study closely the Evas' drawing functions.
</para>
</section>

</article>

