<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>El libro de EWL</title><meta name="generator" content="DocBook XSL Stylesheets V1.64.1"><meta name="description" content=" 
  Este libro es un tutorial sobre el uso de EWL ( Enlightened Widget Library ).
  "></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="id2440402"></a>El libro de EWL</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div><div class="legalnotice"><p>
  	   Este trabajo está licenciado bajo la licencia Creative Commons NonCommercial-ShareAlike.
  	   Para ver una copia de esta licencia, visita
  	   <a href="http://creativecommons.org/licenses/nc-sa/1.0/" target="_top">
  	   http://creativecommons.org/licenses/nc-sa/1.0/</a> o envía una carta a
  	   Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.
  	   </p></div></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.1</td><td align="left">July 07, 2004</td><td align="left">dj2</td></tr><tr><td align="left" colspan="3">Documento inicial</td></tr><tr><td align="left">Revision 0.2</td><td align="left">July 10, 2004</td><td align="left">dj2</td></tr><tr><td align="left" colspan="3">Hacer salir algo de la información sobre widgets</td></tr><tr><td align="left">Revision 0.3</td><td align="left">July 15, 2004</td><td align="left">dj2</td></tr><tr><td align="left" colspan="3">Añade más widgets, añade cosas sobre la jerarquía</td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p> 
  Este libro es un tutorial sobre el uso de EWL ( Enlightened Widget Library ).
  </p></div></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#ch-Intro">1. Introducción</a></span></dt><dt><span class="chapter"><a href="#ch-GettingStarted">2. Empezando</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec-Installation">Instalando EWL</a></span></dt><dt><span class="sect1"><a href="#sec-CreateWindow">Creando una ventana simple</a></span></dt><dt><span class="sect1"><a href="#sec-HelloWorld">Hola mundo</a></span></dt><dt><span class="sect1"><a href="#sec-Callbacks">Callbacks</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch-OjbectHierarchy">3. Jerarquía de objectos</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec-ObjHierIntro">Introducción</a></span></dt><dt><span class="sect1"><a href="#sec-ObjHierCasting">Casteado de objectos</a></span></dt><dt><span class="sect1"><a href="#sec-ObjHierNewWidget">Añadiendo nuevos widgets</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch-WidgetPacking">4. Empaquetado de widgets</a></span></dt><dt><span class="chapter"><a href="#ch-Config">5. Configuración</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2511088">Configuración EWL</a></span></dt><dt><span class="sect1"><a href="#id2511954">Configuración de la aplicación</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch-Themes">6. Temas EWL</a></span></dt><dt><span class="chapter"><a href="#ch-Widgets">7. Widgets</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec-EwlBox">ewl_hbox and ewl_vbox</a></span></dt><dt><span class="sect1"><a href="#sec-EwlButton">ewl_button</a></span></dt><dt><span class="sect1"><a href="#sec-EwlCheckButton">ewl_checkbutton</a></span></dt><dt><span class="sect1"><a href="#sec-EwlCombo">ewl_combo</a></span></dt><dt><span class="sect1"><a href="#sec-EwlDialog">ewl_dialog</a></span></dt><dt><span class="sect1"><a href="#sec-EwlEntry">ewl_entry</a></span></dt><dt><span class="sect1"><a href="#sec-EwlFileDialog">ewl_filedialog</a></span></dt><dt><span class="sect1"><a href="#sec-EwlImage">ewl_image</a></span></dt><dt><span class="sect1"><a href="#sec-EwlMenu">ewl_menu</a></span></dt><dt><span class="sect1"><a href="#sec-EwlNotebook">ewl_notebook</a></span></dt><dt><span class="sect1"><a href="#sec-EwlPassword">ewl_password</a></span></dt><dt><span class="sect1"><a href="#sec-EwlProgressBar">ewl_progressbar</a></span></dt><dt><span class="sect1"><a href="#sec-Ewl-RadioButton">ewl_radiobutton</a></span></dt><dt><span class="sect1"><a href="#sec-EwlScrollpane">ewl_scrollpane</a></span></dt><dt><span class="sect1"><a href="#sec-EwlSeeker">ewl_seeker</a></span></dt><dt><span class="sect1"><a href="#sec-EwlSpinner">ewl_spinner</a></span></dt><dt><span class="sect1"><a href="#sec-EwlTable">ewl_table</a></span></dt><dt><span class="sect1"><a href="#sec-EwlText">ewl_text</a></span></dt><dt><span class="sect1"><a href="#sec-EwlTooltip">ewl_tooltip</a></span></dt><dt><span class="sect1"><a href="#sec-EwlTree">ewl_tree</a></span></dt><dt><span class="sect1"><a href="#sec-EwlMedia">ewl_media</a></span></dt><dt><span class="sect1"><a href="#sec-EwlWindow">ewl_window</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch-Contributing">8. Contribuyendo</a></span></dt><dt><span class="appendix"><a href="#apx-ewl_media_player_example">A. Ejemplo de reproductor de media EWL</a></span></dt></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>3.1. <a href="#fig-obj_hierarchy">La jerarquía de objetos EWL</a></dt><dt>4.1. <a href="#fig-padding_inset_diagram">El relleno y los Insets</a></dt><dt>7.1. <a href="#id2512594">Un botón EWL</a></dt><dt>7.2. <a href="#id2512732">Un botón de opción EWL</a></dt><dt>7.3. <a href="#id2512834">Una combobox EWL</a></dt><dt>7.4. <a href="#id2512949">Un diálogo EWL</a></dt><dt>7.5. <a href="#id2513325">Una caja de entrada EWL</a></dt><dt>7.6. <a href="#id2513502">Un diálogo de archivo EWL</a></dt><dt>7.7. <a href="#id2513752">Un libro de notas EWL</a></dt><dt>7.8. <a href="#id2513824">Un diálogo de contraseña EWL</a></dt><dt>7.9. <a href="#id2513967">Una barra de progreso EWL</a></dt><dt>7.10. <a href="#id2514020">Un radiobutton EWL</a></dt><dt>7.11. <a href="#id2514091">Un buscador EWL</a></dt><dt>7.12. <a href="#id2514183">Un spinner EWL</a></dt><dt>7.13. <a href="#id2514571">Un tooltip EWL</a></dt><dt>7.14. <a href="#id2514655">Un objeto media EWL</a></dt><dt>7.15. <a href="#id2514926">Una ventana EWL</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>3.1. <a href="#id2511312">Creando widgets EWL</a></dt><dt>7.1. <a href="#id2512447">Creando cajas EWL</a></dt><dt>7.2. <a href="#sec-EwlButtonCode">Creating a button</a></dt><dt>7.3. <a href="#sec-EwlButtonCB">Callback de botón</a></dt><dt>7.4. <a href="#sec-EwlCheckButtonCode">Creando un checkbutton</a></dt><dt>7.5. <a href="#sec-EwlCheckButtonCB">Callback del botón</a></dt><dt>7.6. <a href="#sec-EwlComboCode">Creating a combo box</a></dt><dt>7.7. <a href="#sec-EwlComboCodeCB">callback de cambio de valor combobox</a></dt><dt>7.8. <a href="#sec-EwlDialogCode">código de diálogo EWL</a></dt><dt>7.9. <a href="#sec-EwlDialogCB">Callback de diálogo EWL</a></dt><dt>7.10. <a href="#id2513357">Creando una caja de entrada EWL</a></dt><dt>7.11. <a href="#id2513412">callback de cambio de valor para Ewl_Entry</a></dt><dt>7.12. <a href="#id2513540">Creando un diálogo de archivo EWL</a></dt><dt>7.13. <a href="#id2513628">callback para Ewl_Filedialog open</a></dt><dt>7.14. <a href="#id2513690">Ewl_Image</a></dt><dt>7.15. <a href="#id2513858">Creando un diálogo de contraseña EWL</a></dt><dt>7.16. <a href="#id2513930">callback de cambio de valor de Ewl_Password</a></dt><dt>7.17. <a href="#id2514123">Creando un buscador EWL</a></dt><dt>7.18. <a href="#id2514146">Ewl_Seeker callback</a></dt><dt>7.19. <a href="#sec-EwlTextCode">Código Ewl_Text</a></dt><dt>7.20. <a href="#sec-EwlMediaCode">Ewl_Media code</a></dt><dt>7.21. <a href="#id2514743">Ewl_Media callbacks</a></dt><dt>7.22. <a href="#sec-EwlWindowCode">Creando una ventana EWL</a></dt><dt>7.23. <a href="#sec-EwlWindowDestroyCb">Ewl Window destroy callback</a></dt><dt>A.1. <a href="#id2518113">Reproductor de media EWL</a></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-Intro"></a>Chapter 1. Introducción</h2></div></div><div></div></div><p>
La EWL (Enlightened Widget Library) es una librería de creación de interfaces de 
usuario basada en las EFL (Enlightenment Foundation Libraries).
</p><p>
El autor principal de EWL es:
</p><div class="itemizedlist"><ul type="disc" compact><li>Nathan 'RbdPngn' Ingersoll</li></ul></div><p>
EWL funciona de manera similar a otras librerías de widgets, dado que está basada en un 
sistema de callback. Conforme los elementos son creados y añadidos al interfaz, los 
callbacks deseados son registrados, estas funciones serán activadas cuando el evento 
especificado ocurra.
</p><p>
Este tutorial es un intento de familiarizar al usuario con los diferentes aspectos del sistema EWL.
El tutorial probablemente nunca documentará todos los aspectos de EWL conforme el sistema continue 
creciendo. Una buena comprensión de la programación en C es asumida durante el tutorial.
</p><p>
Si tienes cualquier problema con este tutorial, o el uso de EWL en general, cualquier feedback es 
grandemente appreciado puesto que ayudará a mejorar el tutorial o la propia EWL. Por favor mira 
la sección <a href="#ch-Contributing" title="Chapter 8. Contribuyendo">Contribuyendo</a> para más información.
</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-GettingStarted"></a>Chapter 2. Empezando</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec-Installation">Instalando EWL</a></span></dt><dt><span class="sect1"><a href="#sec-CreateWindow">Creando una ventana simple</a></span></dt><dt><span class="sect1"><a href="#sec-HelloWorld">Hola mundo</a></span></dt><dt><span class="sect1"><a href="#sec-Callbacks">Callbacks</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-Installation"></a>Instalando EWL</h2></div></div><div></div></div><p>
Antes de usar EWL necesitas tener las librerías instaladas en tu equipo. EWL puede ser obtenido 
del CVS en Enlightenment y instrucciones de como esto se hace se pueden encontrar en: 
<tt class="literal"><a href="http://www.enlightenment.org/pages/source.html" target="_top"> 
http://www.enlightenment.org/pages/source.html </a></tt> junto con detalladas instrucciones 
de instalación.
</p><p>
Necesitarás instalar un montón de dependencias antes de ser capaz de instalar EWL, esto es porque 
depende de que tantas de las EFL librerías EFL estén presentes en el sistema.
</p><p>
Una vez que tengas las otras librer&#65533;as EFL instaladas, instalar EWL es tan simple como:
</p><pre class="screen">
    ./configure;
    make;
    sudo make install;
</pre><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-CreateWindow"></a>Creando una ventana simple</h2></div></div><div></div></div><p>
El primer paso en crear una aplicación EWL es obtener la ventana principal para mostrarla 
en la pantalla.
</p><pre class="programlisting">
#include &lt;Ewl.h&gt;

void destroy_cb(Ewl_Widget *w, void *event, void *data) {
    ewl_widget_destroy(w);
    ewl_main_quit();
}

int main(int argc, char ** argv) {
    Ewl_Widget *win = NULL;

    if (!ewl_init(&amp;argc, argv)) {
        printf("Unable to init ewl\n");
        return 1;
    }

    win = ewl_window_new();
    ewl_windowt_title_set(EWL_WINDOW(win), "EWL Window");
    ewl_window_name_set(EWL_WINDOW(win), "EWL_WINDOW");
    ewl_window_class_set(EWL_WINDOW(win), "EWLWindow");
    ewl_object_size_request(EWL_OBJECT(win), 200, 100);
    ewl_callback_append(win, EWL_CALLBACK_DELETE_WINDOW, destroy_cb, NULL);
    ewl_widget_show(win);

    ewl_main();
    return 0;
}
</pre><p>Este programa puede ser compilado con un simple:
</p><pre class="screen">
zero@oberon [create_window] -&gt; gcc -o create_window main.c \
 `ewl-config --cflags --libs`
</pre><p>

Y cuando ise ejecuta debería producir algo similar a:
</p><p>
 <span class="inlinemediaobject"><img src="img/create_window.png" alt="Ejemplo de ventana EWL vacía"></span>
</p><p>
Ahora que sabemos lo que estamos haciendo, veamos el código con un poco mas de detalle.
</p><pre class="programlisting">
#include &lt;Ewl.h&gt;
</pre><p>
Todas las aplicaciones EWL empezarán con el include &lt;Ewl.h&gt;. Esto introducirá todos los otros 
archivos de cabecera que EWL requiera para funcionar.
</p><pre class="programlisting">
void destroy_cb(Ewl_Widget *w, void *event, void *data) {
    ewl_widget_destroy(w);
    ewl_main_quit();
}
</pre><p>
<tt class="function">destroy_cb</tt> ser&#65533; usada por EWL cuando el gestor de ventanas requiera que la 
aplicaci&#65533;n termine. Los callbacks serán descritos mas tarde en la sección 
<a href="#sec-Callbacks" title="Callbacks">Callbacks</a> section.
</p><p>
<tt class="function">ewl_widget_destroy()</tt> es usado para señalar a EWL que ya no necesitamos el 
objeto dado, en este caso la ventana, y para que EWL limpie los recurson usados por ese widget.
</p><p>
Finalmente, llamamos a <tt class="function">ewl_main_quit()</tt> que causa que EWL salga de su ciclo 
principal de proceso y vuelva de la función <tt class="function">ewl_main()</tt>. 
</p><pre class="programlisting">
int main(int argc, char ** argv) {
    Ewl_Widget *win = NULL;

    if (!ewl_init(&amp;argc, argv)) {
        printf("Unable to init ewl\n");
        return 1;
    }
</pre><p>
Antes de que podamos usar EWL debemos iniciar la librería.Esto se hace mediante la llamada a 
<tt class="function">ewl_init()</tt>. Pasamos los parámetros argc y argv desde main a EWL dado que 
hay unas cuantas opciones específicas para EWL entre los argumentos.
</p><p>Estos argumentos incluyen:</p><div class="itemizedlist"><p class="title"><b>Opciones de linea de comandos EWL</b></p><ul type="bullet" compact><li style="list-style-type: disc"><p>--ewl-theme &lt;name&gt;</p></li><li style="list-style-type: disc"><p>--ewl-segv</p></li><li style="list-style-type: disc"><p>--ewl-software-x11</p></li><li style="list-style-type: disc"><p>--ewl-gl-x11</p></li><li style="list-style-type: disc"><p>--ewl-fb</p></li></ul></div><p>
El parámetro &lt;name&gt; para la opción --ewl-theme es el nombre del tema que deseas usar. Este puede 
estar localizado en uno de los directorios del sistema, o en el directorio local.
</p><p>
Si EWL fué capaz de inicializarse con éxito la llamada a <tt class="function">ewl_init()</tt>
devolverá un valor &gt; 0. Si no hubo éxito no tiene realmente sentido continuar dado que 
EWL no funcionará correctamente.
</p><pre class="programlisting">
    win = ewl_window_new();
    ewl_window_title_set(EWL_WINDOW(win), "EWL Window");
    ewl_window_name_set(EWL_WINDOW(win), "EWL_WINDOW");
    ewl_window_class_set(EWL_WINDOW(win), "EWLWindow");
    ewl_object_size_request(EWL_OBJECT(win), 200, 100);
    ewl_callback_append(win, EWL_CALLBACK_DELETE_WINDOW, destroy_cb, NULL);
    ewl_widget_show(win);
</pre><p>
Aquí es donde la ventana es creada. Una llamada a <tt class="function">ewl_window_new()</tt>
crea la nueva ventana vacia. Entonces tomamos esa ventana y empezamos a añadir datos. 
Empezamos por colocar el título con <tt class="function">ewl_window_title_set()</tt>, que colocará 
la cadena que el gestor de ventanas mostrará en la parte superior de la ventana. Las siguientes 
dos llamadas, <tt class="function">ewl_window_name_set()</tt> y <tt class="function">ewl_window_class_set()</tt>, 
inician datos que serán usados por el gestor de ventanas para gestionar mejor tu aplicación.
</p><p>
Procedemos entonces a iniciar el tamaño base de la ventana con una llamada a 
<tt class="function">ewl_object_size_request()</tt>. Los parámetros segundo y tercero ( 200 , 100 )
especifican la anchura y altura con las que queremos crear la ventana. Notarás que esta 
llamada es casteada a <tt class="literal">EWL_OBJECT()</tt>. Esto es a causa de la jerarquía de 
widgets que EWL provee ( descrita más a fondo en el capítulo <a href="#ch-OjbectHierarchy" title="Chapter 3. Jerarquía de objectos">
Object Hierarchy</a> ). Un ewl_window es un ewl_object así que podemos usar las operaciones 
de ewl_object en una ewl_window.
</p><p>
Entonces procedemos a añadir el callback delete a la ventana mediante una llamada a 
<tt class="function">ewl_callback_append</tt>. El segundo parámetro de la cual es el tipo de 
señal que queremos recibir, el tercero es la función a la que llamar y finalmente el cuarto 
son cualesquiera datos de usuario que hayan de ser enviados al callback.
</p><p>
Una vez la ventana está iniciada y lista para empezar, una simple llamada a 
<tt class="function">ewl_widget_show()</tt> hará que EWL muestre la ventana.
</p><pre class="programlisting">
    ewl_main();
    return 0;
}
</pre><p>
La llamada a <tt class="function">ewl_main()</tt> le dir&#65533; a EWL que empiece su ciclo de proceso principal 
esperando por señales. <tt class="function">ewl_main()</tt> se encargará del apagado de EWL cuando se salga 
del ciclo de proceso principal.
</p><p>
Eso es todo. Aunque es probablemente una de las aplicaciones EWL más simples que pueden producirse, 
será usada como la base para muchos de los otros ejemplos presentados en este tutorial, y muchas 
aplicaciones EWL que son producidas.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-HelloWorld"></a>Hola mundo</h2></div></div><div></div></div><p>
Cuando tienes una ventana en la pantalla es hora de hacer algo más divertido con ella. Siguiendo la 
gran tradición , algo con Hola.
</p><p>
Solo voy a explicar porciones del programa que no hayan sido vistas ya. Si hay algo que no entiendes 
por favor busca en la sección anterior y debería estar explicado allí
I am only going to explain the portions of the program which have not already been 
seen. If there is something you do not understand please reference the previous section
and it should be explained there.</p><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;Ewl.h&gt;

void destroy_cb(Ewl_Widget *w, void *event, void *data) {
    ewl_widget_destroy(w);
    ewl_main_quit();
}

void text_update_cb(Ewl_Widget *w, void *event, void *data) {
    char *s = NULL;
    Ewl_Widget *label = NULL;
    char buf[BUFSIZ];

    s = ewl_entry_get_text(EWL_ENTRY(w));
    label = (Ewl_Widget *)data;

    snprintf(buf, BUFSIZ, "Hello %s", s);
    ewl_text_text_set(EWL_TEXT(label), buf);

    free(s);
    return;
}

int main(int argc, char ** argv) {
    Ewl_Widget *win = NULL;
    Ewl_Widget *box = NULL;
    Ewl_Widget *label = NULL;
    Ewl_Widget *o = NULL;

    /* init the library */
    if (!ewl_init(&amp;argc, argv)) {
        printf("Unable to initialize EWL\n");
        return 1;
    }

    /* create the window */
    win = ewl_window_new();
    ewl_window_title_set(EWL_WINDOW(win), "Hello world");
    ewl_window_class_set(EWL_WINDOW(win), "hello");
    ewl_window_name_set(EWL_WINDOW(win), "hello");
    ewl_object_size_request(EWL_OBJECT(win), 200, 50);
    ewl_callback_append(win, EWL_CALLBACK_DELETE_WINDOW, destroy_cb, NULL);
    ewl_widget_show(win);

    /* create the container */
    box = ewl_vbox_new();
    ewl_container_child_append(EWL_CONTAINER(win), box);
    ewl_object_fill_policy_set(EWL_OBJECT(box), EWL_FLAG_FILL_ALL);
    ewl_widget_show(box);

    /* create text label */
    label = ewl_text_new(NULL);
    ewl_container_child_append(EWL_CONTAINER(box), label);
    ewl_object_alignment_set(EWL_OBJECT(label), EWL_FLAG_ALIGN_CENTER);
    ewl_text_style_set(EWL_TEXT(label), "soft_shadow");
    ewl_text_color_set(EWL_TEXT(label), 255, 0, 0, 255);
    ewl_text_text_set(EWL_TEXT(label), "hello");
    ewl_widget_show(label);

    /* create the entry */
    o = ewl_entry_new("");
    ewl_container_child_append(EWL_CONTAINER(box), o);
    ewl_object_alignment_set(EWL_OBJECT(o), EWL_FLAG_ALIGN_CENTER);
    ewl_object_padding_set(EWL_OBJECT(o), 5, 5, 5, 0);
    ewl_text_color_set(EWL_TEXT(EWL_ENTRY(o)-&gt;text), 0, 0, 0, 255);
    ewl_callback_append(o, EWL_CALLBACK_VALUE_CHANGED, text_update_cb, label);
    ewl_widget_show(o);

    ewl_main();
    return 0;
}
</pre><p>
Si compilas y corres esta aplicación de la misma manera que el primer ejemplo deberías ver algo 
similar a la siguiente ventana.
</p><p>
 <span class="inlinemediaobject"><img src="img/hello_world.png" alt="Aplicación simple Hola Mundo"></span>
</p><p>
Esto es un poco mas largo que la simple creación de una ventana, pero tambien incluye mas 
funcionalidad. Si corres este programa deberías ver una ventana simple con un poco de texto 
diciendo "Hello" en la parte superior y un área de texto. Teclear en el área de texto y pulsar 
"Enter" mostrará "Hello" más lo que hayas tecleado.
</p><p>
A la cadena "Hola" se le ha aplicado un poco de estilización. Ouedes ver que al texto se le ha 
aplicado un simple cambio de color y es mostrado con una sombra.
</p><p>
Ahora que sabes lo que hace, vamos a hechar un vistazo a los nuevos pedazos de código que introduce 
este ejemplo.
</p><pre class="programlisting">
void text_update_cb(Ewl_Widget *w, void *event, void *data) {
    char *s = NULL;
    Ewl_Widget *label = NULL;
    char buf[BUFSIZ];

    s = ewl_entry_get_text(EWL_ENTRY(w));
    label = (Ewl_Widget *)data;

    snprintf(buf, BUFSIZ, "Hello %s", s);
    ewl_text_text_set(EWL_TEXT(label), buf);

    free(s);
    return;
}
</pre><p>
<tt class="function">text_update_cb()</tt> es el callback que vamos a registrar para cuando el usuario 
ha presionado "Enter" en el campo de texto. Tiene la misma firma que el callback de destroy, y 
todos los otros callbacks de EWL que estaremos registrando.
</p><p>
El texto que ha sido introducido es recuperado con una llamada a<tt class="function">ewl_entry_get_text()</tt> 
pasando el widget de entrada desde el cual queremos recuperar el texto. Esto retornarña un puntero a 
la cadena de texto, es responsabilidad de la aplicación liberar este puntero.
</p><p>
Entonces casteamos el parámetro <tt class="literal">data</tt> a <tt class="literal">Ewl_Widget</tt>. Esto es porque, 
como verás en el callback register, estamos añadiendo un widget a este callback como parámetro de datos.
</p><p>
Entonces podemos tomar este nuevo texto y reemplazar los contenidos de la etiqueta de texto actual 
llamando a <tt class="function">ewl_text_text_set()</tt> pasándole el objeto de texto y el texto a ser mostrado.
</p><pre class="programlisting">
    box = ewl_vbox_new();
    ewl_container_append_child(EWL_CONTAINER(win), box);
    ewl_object_fill_policy_set(EWL_OBJECT(box), EWL_FLAG_FILL_ALL);
    ewl_widget_show(box);
</pre><p>
Aunque podríamos añadir cualquier widget a la ventana principal de la aplicación, es un poco mas 
limpio añadirlos a una caja que se añade a la ventana principal. La caja es creada con una llamada 
a <tt class="function">ewl_vbox_new()</tt> creando una disposición de caja vertical. Podríamos haber usado 
<tt class="function">ewl_hbox_new()</tt> si quisieramos una caja horizontal en vez de una vertical. En 
cuanto la caja es creada la añadimos a la ventana llamando a <tt class="function">ewl_container_child_append()</tt>. 
Esto coloca el widget dado como siguiente elemento en el contenedor. Los contenedores son empaquetados desde 
arriba hacia abajo, o de izquierda a derecha, así que el orden en que los elementos son insertados 
en el contenedor afecta su apariencia en la pantalla. Finalmente, antes de enseñar el widget, 
seleccionamos una política de relleno con <tt class="function">ewl_object_fill_policy_set()</tt>. La 
política de relleno cambia la manera en que el objeto rellena su espacio disponible.
</p><p>
Las políticas de relleno posibles son:
</p><div class="itemizedlist"><p class="title"><b>EWL Fill Flags</b></p><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_FLAG_FILL_NONE</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_HSHRINK</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_VSHRINK</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_SHRINK</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_HFILL</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_VFILL</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_FILL</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_ALL</p></li></ul></div><p>
Todas las cuales deberían tener un significado obvio, con las excepciones de 
<tt class="literal">EWL_FLAG_FILL_SHRINK</tt>, <tt class="literal">EWL_FLAG_FILL_FILL</tt>
y <tt class="literal">EWL_FLAG_FILL_ALL</tt>. La opción SHRINK es el or lógico de 
las dos opciones HSHRINK y VSHRINK . La opción FILL es el or lógico de las dos 
opciones HFILL y VFILL. Finalmente la opción ALL es el or lógico de las dos opciones 
SHRINK y FILL.
</p><pre class="programlisting">
    label = ewl_text_new(NULL);
    ewl_container_child_append(EWL_CONTAINER(box), label);
    ewl_object_alignment_set(EWL_OBJECT(label), EWL_FLAG_ALIGN_CENTER);
    ewl_text_style_set(EWL_TEXT(label), "soft_shadow");
    ewl_text_color_set(EWL_TEXT(label), 255, 0, 0, 255);
    ewl_text_text_set(EWL_TEXT(label), "Hello");
    ewl_widget_show(label);
</pre><p>
Ahora que tenemos nusetra caja contenedor iniciada, creamosel elemento de texto que va a 
funcionar como nuestra etiqueta. La etiqueta es creada con una llamada a
<tt class="function">ewl_text_new()</tt>. En este caso, pasamos NULL como valor porque especificaremos 
nuestro texto después de añadir algún estilizado al objeto. También puedes pasar una cadena 
de texto a <tt class="function">ewl_text_new()</tt> si es necesario. Recuerda que el estilizado de texto 
ocurre para el texto que es añadido <span class="emphasis"><em>después</em></span> de que se añada el estilizado.
</p><p>
Cuando el widget es creado lo añadimos a la caja con <tt class="function">ewl_container_child_append()</tt>. 
Después seleccionamos la alineación del objeto de texto por medio de <tt class="function">ewl_object_alignment_set()</tt>. 
Esto especifica como se alinearán los contenidos dentro del propio widget.
</p><p>
La función de alineación aceptará uno de:
</p><div class="itemizedlist"><p class="title"><b>Opciones de alineación EWL</b></p><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_FLAG_FILL_CENTER</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_LEFT</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_RIGHT</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_TOP</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_BOTTOM</p></li></ul></div><p>
Una vez todas las opciones de widget han sido especificadas, añadimos algunas propiedades de formato de 
texto al widget. La primera,  <tt class="function">ewl_text_style_set()</tt>, coloca el estilo del objeto 
de texto. Los estilos cambian la apariencia del texto aplicando algún tipo de filtro, en este caso, 
creando una apariencia de "sombra suave" para el widget. Seleccionamos entonces el color del texto rojo 
llamando a <tt class="function">ewl_text_color_set()</tt>. Hay cuatro parámetros para la función de color, 
siendo estos rojo, verde, azul, y alpha.
</p><pre class="programlisting">
    o = ewl_entry_new("");
    ewl_container_append_child(EWL_CONTAINER(box), o);
    ewl_object_alignment_set(EWL_OBJECT(o), EWL_FLAG_ALIGN_CENTER);
    ewl_object_padding_set(EWL_OBJECT(o), 5, 5, 5, 0);
    ewl_text_color_set(EWL_TEXT(EWL_ENTRY(o)-&gt;text), 0, 0, 0, 255);
    ewl_callback_append(o, EWL_CALLBACK_VALUE_CHANGED, text_update_cb, label);
    ewl_widget_show(o);
</pre><p>
El widget final que crearemos es una caja de entrada de texto. Esto es hecho con una llamada a 
<tt class="function">ewl_entry_new()</tt>. En este caso estamos dando "" como valor, pero 
podíamos dar una cadena inicial para mostrar en la entrada de texto. Hacemos un conjunto semejante de 
inicializaciones a la caja de entrada, seleccionando la alineación y seleccionando el color del texto 
negro. La llamada a <tt class="function">ewl_object_padding_set()</tt> selecciona la cantidad de padding 
alrededor del widget. Los cuatro parámetros son izquierda, derecha, arriba y abajo.
</p><p>
Con eso deberías tener una comprensión básica de las funciones EWL y como varios widgets son creados y 
configurados.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-Callbacks"></a>Callbacks</h2></div></div><div></div></div><p>
La EWL funciona mediante el uso de callbacks. Una gran cantidad del trabajo interno de la propia 
librería también trabaja con callbacks.
</p><p>
Un callback es una función que será llamada cuando ocurra un evento específico. Estos eventos pueden 
ser cualquier cosa desde el usuario pulsando un botón hasta la ventana siendo destruída por el gestor 
de ventanas.
</p><p>
Para los eventos de los cuales la aplicación requiere una notificación se registra un callback a 
través de la EWL. Esto es hecho con <tt class="function">ewl_callback_append()</tt>. Esta función toma 
cuatro parámetros: el objeto al que añadir el callback, el callback deseado, la función de callback, 
y los datos de usuario.
</p><p>
Algunos de los callbacks posibles incluyen:
</p><div class="variablelist"><p class="title"><b>Callbacks EWL posibles</b></p><dl><dt><span class="term">EWL_CALLBACK_DESTROY</span></dt><dd><p>El widget es liberado</p></dd><dt><span class="term">EWL_CALLBACK_DELETE_WINDOW</span></dt><dd><p>La ventana está siendo cerrada.</p></dd><dt><span class="term">EWL_CALLBACK_KEY_DOWN</span></dt><dd><p>Una tecla fué presionada.</p></dd><dt><span class="term">EWL_CALLBACK_KEY_UP</span></dt><dd><p>Una tecla fué soltada.</p></dd><dt><span class="term">EWL_CALLBACK_MOUSE_DOWN</span></dt><dd><p>El botón del ratón fué presionado.</p></dd><dt><span class="term">EWL_CALLBACK_MOUSE_UP</span></dt><dd><p>El botón del ratón fue soltado.</p></dd><dt><span class="term">EWL_CALLBACK_MOUSE_MOVE</span></dt><dd><p>El ratón fué movido.</p></dd><dt><span class="term">EWL_CALLBACK_MOUSE_WHEEL</span></dt><dd><p>La rueda del ratón se desplazó</p></dd><dt><span class="term">EWL_CALLBACK_FOCUS_IN</span></dt><dd><p>El ratón fué posicionado sobre el widget.</p></dd><dt><span class="term">EWL_CALLBACK_FOCUS_OUT</span></dt><dd><p>El ratón se movió fuera del widget.</p></dd><dt><span class="term">EWL_CALLBACK_SELECT</span></dt><dd><p>El widget fué seleccionado mediante el ratón o el teclado.</p></dd><dt><span class="term">EWL_CALLBACK_DESELECT</span></dt><dd><p>El widget fué deselecionado por el ratón o el teclado.</p></dd><dt><span class="term">EWL_CALLBACK_CLICKED</span></dt><dd><p>El ratón fué presionado y soltado en un widget.</p></dd><dt><span class="term">EWL_CALLBACK_DOUBLE_CLICKED</span></dt><dd><p>El ratón fué clickado dos veces rápidamente.</p></dd><dt><span class="term">EWL_CALLBACK_HILITED</span></dt><dd><p>El ratón está sobre el widget.</p></dd><dt><span class="term">EWL_CALLBACK_VALUE_CHANGED</span></dt><dd><p>El valor en el widget cambió.</p></dd></dl></div><p>
La función callback tiene una firma como <tt class="literal">void fcn(Ewl_Widget *, void *, void *)</tt>. 
El primer parámetro es el widget que activó este callback. El segundo parámetro son los datos del evento 
y el tercer parámetro son los datos de usuario añadidos. 
</p><p>
Los datos de evento son un tipo que se refiere al propio callback. Así, por ejemplo, cuando 
el callback para <tt class="literal">EWL_CALLBACK_MOUSE_WHEEL</tt> es llamado los datos de evento tendrán 
una estructura de tipo <tt class="literal">Ewl_Event_Mouse_Wheel</tt> y esta estructura contiene información 
adicional sobre el evento. En el caso de la rueda, los modificadores de teclado, la posición del ratón 
y la dirección del desplazamiento.
</p><p>
El último parámetro para la función son los datos de usuario. Esto te permite añadir cualesquiera 
dsatos que quieras pasar al callback cuando sea ejecutado. Estos datos serán provistos al callback 
como su tercer parámetro.
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-OjbectHierarchy"></a>Chapter 3. Jerarquía de objectos</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec-ObjHierIntro">Introducción</a></span></dt><dt><span class="sect1"><a href="#sec-ObjHierCasting">Casteado de objectos</a></span></dt><dt><span class="sect1"><a href="#sec-ObjHierNewWidget">Añadiendo nuevos widgets</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-ObjHierIntro"></a>Introducción</h2></div></div><div></div></div><p>
Los widgets EWL forman una jerarquía. El widget base del que todo deriva es el <tt class="literal">Ewl_Object</tt>. 
<tt class="literal">Ewl_Object</tt> provee toda la funcionalidad base para cada widget incluyendo el dimensionado, 
alineación, políticas de relleno, relleno y otras. Este es el principal bloque constructivo de la EWL. Una 
aplicación que use EWL nunca necesitará obtener un <tt class="literal">Ewl_Object</tt>.
</p><p>
Justo sobre el <tt class="literal">Ewl_Object</tt> está el <tt class="literal">Ewl_Widget</tt>. De nuevo, todos los 
widgets heredan de <tt class="literal">Ewl_Object</tt>. Este objecto provee la funcionalidad base para que un 
widget ineractúe con el usuario. Como con <tt class="literal">Ewl_Object</tt> una aplicación nunca necesitará 
obtener un <tt class="literal">Ewl_Widget</tt>.
</p><p>
Con el <tt class="literal">Ewl_Widget</tt> en su lugar podemos empezar a construir la jerarquía de objetos que 
forman la EWL. La jerarquía es similar a la mostrada en la figura <a href="#fig-obj_hierarchy" title="Figure 3.1. La jerarquía de objetos EWL">EWL Object Hierarcy</a> 
más abajo.
</p><p>
 </p><div class="figure"><a name="fig-obj_hierarchy"></a><p class="title"><b>Figure 3.1. La jerarquía de objetos EWL</b></p><span class="inlinemediaobject"><img src="img/obj_hierarchy.png" alt="La jerarquía de objetos EWL"></span></div><p>
</p><p>
El objeto <tt class="literal">Ewl_Container</tt> es construido sobre el objeto <tt class="literal">Ewl_Widget</tt> 
y provee la funcionalidad para widgets que tienen que contener otros widgets. Esto incluye cualquier cosa 
desde la ventana principal, a cajas, a paneles de desplazamiento.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-ObjHierCasting"></a>Casteado de objectos</h2></div></div><div></div></div><p>
Conforme progreses en la EWL notarás que hay un montón de casting entre los diferentes tipos. Para hacer 
esto más fácil, cada cast a un tipo particular tiene una macro EWL_TYPE() definida. Así por ejemplo hay 
definidas EWL_OBJECT(o) y EWL_WIDGET(o) para hacer la vida más fácil.
</p><p>
Estas macros siempre deberían ser usadas cuando se convierta entre widgets EWL para saber que se está 
haciendo lo correcto.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-ObjHierNewWidget"></a>Añadiendo nuevos widgets</h2></div></div><div></div></div><p>
Para añadir widgets nuevos en EWL necesitas crear una nueva struct que tenga el tipo apropiado de subclase 
como primer elemento. Este objeto de subclase no debe ser un puntero.
</p><div class="example"><a name="id2511312"></a><p class="title"><b>Example 3.1. Creando widgets EWL</b></p><pre class="programlisting">
struct Ewl_Foo {
    Ewl_Container container;
    int bar;
}
 </pre></div><p>
Esto creará un nuevo widget Ewl_Foo que hereda de <tt class="literal">Ewl_Container</tt> así que deberías ser capaz 
de empaquetar otros widgets en este nuevo tipo de widget.
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-WidgetPacking"></a>Chapter 4. Empaquetado de widgets</h2></div></div><div></div></div><p>
Conforme escribas una aplicación EWL necesitarás empezar colocando los widgets en las distintas cajas. Para 
hacerlo, necesitarás algo de información sobre como EWL empaqueta los widgets.
</p><p>
Hay dos orientaciones principales para contenedores en EWL, vertical u horizontal.
Las diferentes orientaciones pueden ser vistas fácilmente en <a href="#sec-EwlBox" title="ewl_hbox and ewl_vbox">the section called &#8220;ewl_hbox and ewl_vbox&#8221;</a>.
</p><p>
En EWL, cada widget tiene una cantidad de relleno alrededor del widget y un inset vinculado al widget. Esto se ve abajo en 
<a href="#fig-padding_inset_diagram" title="Figure 4.1. El relleno y los Insets">Figure 4.1, &#8220;El relleno y los Insets&#8221;</a>.
  </p><div class="figure"><a name="fig-padding_inset_diagram"></a><p class="title"><b>Figure 4.1. El relleno y los Insets</b></p><span class="inlinemediaobject"><img src="img/padding_insets.png" alt="Diagrama del relleno e insets en EWL"></span></div><p>
</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-Config"></a>Chapter 5. Configuración</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2511088">Configuración EWL</a></span></dt><dt><span class="sect1"><a href="#id2511954">Configuración de la aplicación</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2511088"></a>Configuración EWL</h2></div></div><div></div></div><p>
EWL usa el sistema Ecore_Config para manejar todos sus datos de configuración. Esto hace fácil el cambio de 
valores mediante las herramientas existentes para trabajar con Ecore_Config.
</p><p>
Las siguientes son las claves usadas por EWL con una descripción breve.
</p><div class="variablelist"><dl><dt><span class="term">/ewl/debug/enable</span></dt><dd><p>Habilita el modo de depuración</p></dd><dt><span class="term">/ewl/debug/level</span></dt><dd><p>Selecciona el nivel de depuración [0 - 10]</p></dd><dt><span class="term">/ewl/evas/render_method</span></dt><dd><p>
    Selecciona el método que Evas usará para renderizar. Este puede ser uno de:		
 	 </p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>software_x11</p></li><li style="list-style-type: disc"><p>gl_x11</p></li><li style="list-style-type: disc"><p>fb</p></li></ul></div><p>
	 para X11 software, X11 OpenGL y Framebuffer respectivamente.
   </p></dd><dt><span class="term">/ewl/evas/font_cache</span></dt><dd><p>El tamaño de la caché de fuentes de Evas</p></dd><dt><span class="term">/ewl/evas/image_cache</span></dt><dd><p>El tamaño de la caché de imagenes de Evas</p></dd><dt><span class="term">/ewl/theme/name</span></dt><dd><p>El nombre del tema EWL a usar ( menos la porción .eet )</p></dd><dt><span class="term">/ewl/theme/cache</span></dt><dd><p>Un booleano para indicar si los valores del tema deberían ser cacheados por EWL</p></dd><dt><span class="term">/ewl/theme/color_classes/override</span></dt><dd><p>Sustituye las clases de color por defecto</p></dd><dt><span class="term">/ewl/theme/color_classes/count</span></dt><dd><p>El número de clases de color que son sustituídas</p></dd><dt><span class="term">/ewl/theme/color_class/[n]/name</span></dt><dd><p>El nombre de la clase de color número [n]</p></dd><dt><span class="term">/ewl/theme/color_class/[n][rgba]</span></dt><dd><p>Una clave para cada uno de los valores de color r, g, b, a </p></dd></dl></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2511954"></a>Configuración de la aplicación</h2></div></div><div></div></div><p>
La mejor manera para una aplicación de manejar su configuración específica es usar también Ecore_Config.
Hacerlo es simple y ya maneja cosas como valores por defecto y callbacks para cambios de datos.
</p><p>
Como medida de precaución probablemente deberías hacer una llamada a <tt class="function">ecore_init()</tt> en 
tu código antes de usar las funciones Ecore_Config. Esto garantizará que Ecore no será apagado antes de 
que hayas terminado de usarlo ( Necesitarás hacer una llamada a <tt class="function">ecore_shutdown()</tt> 
cuando hayas terminado ).
</p><p>
Antes de empezar a usar Ecore_Config debes hacer una llamada a <tt class="function">int ecore_config_init(char *)</tt> 
donde el parámetro es el nombre bajo el cual quieras que tu configuración aparezca en Ecore_Config. Este 
es también el nombre que sería usado con <span><b class="command">examine</b></span> para cambiar tus datos de configuración.
Cuando hayas terminado de usar Ecore_Config deberías llamar a <tt class="function">int ecore_config_shutdown(void)</tt> 
para cerrar el sistema Ecore_Config.
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-Themes"></a>Chapter 6. Temas EWL</h2></div></div><div></div></div><p>
EWL usa la librería Edje para manejar todos sus requerimientos de theming. Los temas pueden estar definidos
el el archivo de configuración o en la línea de comandos usando la opción <tt class="literal">--ewl-theme</tt>.
</p><p>
El uso de Edje para theming proporciona a EWL una gran flexibilidad y provee al diseñador 
de temas con un gran poder para personalizar el aspecto de EWL.
</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-Widgets"></a>Chapter 7. Widgets</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec-EwlBox">ewl_hbox and ewl_vbox</a></span></dt><dt><span class="sect1"><a href="#sec-EwlButton">ewl_button</a></span></dt><dt><span class="sect1"><a href="#sec-EwlCheckButton">ewl_checkbutton</a></span></dt><dt><span class="sect1"><a href="#sec-EwlCombo">ewl_combo</a></span></dt><dt><span class="sect1"><a href="#sec-EwlDialog">ewl_dialog</a></span></dt><dt><span class="sect1"><a href="#sec-EwlEntry">ewl_entry</a></span></dt><dt><span class="sect1"><a href="#sec-EwlFileDialog">ewl_filedialog</a></span></dt><dt><span class="sect1"><a href="#sec-EwlImage">ewl_image</a></span></dt><dt><span class="sect1"><a href="#sec-EwlMenu">ewl_menu</a></span></dt><dt><span class="sect1"><a href="#sec-EwlNotebook">ewl_notebook</a></span></dt><dt><span class="sect1"><a href="#sec-EwlPassword">ewl_password</a></span></dt><dt><span class="sect1"><a href="#sec-EwlProgressBar">ewl_progressbar</a></span></dt><dt><span class="sect1"><a href="#sec-Ewl-RadioButton">ewl_radiobutton</a></span></dt><dt><span class="sect1"><a href="#sec-EwlScrollpane">ewl_scrollpane</a></span></dt><dt><span class="sect1"><a href="#sec-EwlSeeker">ewl_seeker</a></span></dt><dt><span class="sect1"><a href="#sec-EwlSpinner">ewl_spinner</a></span></dt><dt><span class="sect1"><a href="#sec-EwlTable">ewl_table</a></span></dt><dt><span class="sect1"><a href="#sec-EwlText">ewl_text</a></span></dt><dt><span class="sect1"><a href="#sec-EwlTooltip">ewl_tooltip</a></span></dt><dt><span class="sect1"><a href="#sec-EwlTree">ewl_tree</a></span></dt><dt><span class="sect1"><a href="#sec-EwlMedia">ewl_media</a></span></dt><dt><span class="sect1"><a href="#sec-EwlWindow">ewl_window</a></span></dt></dl></div><p>
Miraremos ahora a cada widget individualmente. Mira el código que crea el widget y una captura de pantalla 
del widget en acción ( si es aplicable ).
</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlBox"></a>ewl_hbox and ewl_vbox</h2></div></div><div></div></div><p>
Los widgets caja te permiten especificar distintas maneras en que la aplicación será colocada. Puedes crear 
una caja horizontal ( hbox ) o vertical ( vbox ). Una caja horizontal tendrá a sus widgets hijos empaquetados 
desde la izquierda hacia la derecha mientras que una caja vertical tendrá sus widgets empaquetados de arriba abajo. 
</p><p>
Un widget caja no se mostrará en la propia aplicación, es usado solo como un contenedor para otros widgets. 
</p><p>
 </p><div class="example"><a name="id2512447"></a><p class="title"><b>Example 7.1. Creando cajas EWL</b></p><pre class="programlisting">
   Ewl_Widget *hbox = ewl_hbox_new();
   ewl_widget_show(hbox);

   Ewl_Widget *vbox = ewl_vbox_new();
   ewl_widget_show(vbox);
  </pre></div><p>
Los widgets de caja son relativamente simples de crear y usar, sólamente requiriendo una llamada a la función new.
</p><p>
Las funciones para manipular cajas incluyen:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p><tt class="function">void ewl_box_set_orientation(Ewl_Box *, Ewl_Orientation)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">Ewl_Orientation ewl_box_orientation_get(Ewl_Box *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">void ewl_box_spacing_set(Ewl_Box *, int)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">void ewl_box_homogeneous_set(Ewl_Box *, int)</tt></p></li></ul></div><p>

La opción <tt class="literal">Ewl_Orientation</tt> puede ser uno de:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_ORIENTATION_HORIZONTAL</p></li><li style="list-style-type: disc"><p>EWL_ORIENTATION_VERTICAL</p></li></ul></div><p>
</p><p>
<tt class="function">ewl_box_set_spacing()</tt> seleccionará la cantidad de espacio entre los elementos en la caja con 
el valor dado. <tt class="function">ewl_box_set_homogeneous()</tt> configurará la caja para dar a todos los elementos 
en ella un tamaño igual si recibe true, sino tendrán su tamaño requerido.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlButton"></a>ewl_button</h2></div></div><div></div></div><p>
El widget botón es simplemente un widget con una etiqueta incluída. Cuando el usuario pulsa en el botón 
el callback vinculado a <tt class="literal">EWL_CALLBACK_CLICKED</tt> será ejecutado.
</p><p>
 </p><div class="figure"><a name="id2512594"></a><p class="title"><b>Figure 7.1. Un botón EWL</b></p><span class="inlinemediaobject"><img src="img/entry.png" alt="Ejemplo de un botón EWL"></span></div><p>
</p><p>
</p><div class="example"><a name="sec-EwlButtonCode"></a><p class="title"><b>Example 7.2. Creating a button</b></p><pre class="programlisting">
    Ewl_Widget *button = ewl_button_new("A button");
    ewl_object_alignment_set(EWL_OBJECT(button), EWL_FLAG_ALIGN_CENTER);
    ewl_callback_append(button, EWL_CALLBACK_CLICKED, button_cb, NULL);
    ewl_widget_show(button);
 </pre></div><p>
La porción de etiqueta del botón puede ser alineada a cualquiera de los valores <tt class="literal">EWL_FLAG_ALIGN_*</tt>. 
</p><p>
</p><div class="example"><a name="sec-EwlButtonCB"></a><p class="title"><b>Example 7.3. Callback de botón</b></p><pre class="programlisting">
void button_cb(Ewl_Widget *w, void *event, void *data) {
    printf("button pressed\n");
}
 </pre></div><p>
</p><p>
La etiqueta de un botón puede ser manipulada después de que el botón ha sido creado mediante las dos llamadas:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p><tt class="function">char *ewl_button_label_get(EwlButton *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">void ewl_button_label_set(EwlButton *, char *)</tt></p></li></ul></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlCheckButton"></a>ewl_checkbutton</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2512732"></a><p class="title"><b>Figure 7.2. Un botón de opción EWL</b></p><span class="inlinemediaobject"><img src="img/checkbutton.png" alt="Ejemplo de un botón de opción EWL"></span></div><p>
</p><p>
</p><div class="example"><a name="sec-EwlCheckButtonCode"></a><p class="title"><b>Example 7.4. Creando un checkbutton</b></p><pre class="programlisting">
    Ewl_Widget *cb = ewl_checkbutton_new("Label");
    ewl_checkbutton_label_position_set(EWL_CHECKBUTTON(cb), EWL_FLAG_ALIGN_LEFT);
    ewl_callback_append(cb, EWL_CALLBACK_VALUE_CHANGED, checkbutton_cb, NULL);
    ewl_widget_show(cb);
 </pre></div><p>
</p><p>
 </p><div class="example"><a name="sec-EwlCheckButtonCB"></a><p class="title"><b>Example 7.5. Callback del botón</b></p><pre class="programlisting">
void checkbutton_cb(Ewl_Widget *w, void *event, void *data) {
    if (ewl_checkbutton_is_checked(EWL_CHECKBUTTON(w)))
        printf("checked\n");
    else
        printf("Not checked\n");
}
 </pre></div><p>
 </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlCombo"></a>ewl_combo</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2512834"></a><p class="title"><b>Figure 7.3. Una combobox EWL</b></p><span class="inlinemediaobject"><img src="img/combo.png" alt="Ejemplo de una combobox EWL"></span></div><p>
</p><p>
</p><div class="example"><a name="sec-EwlComboCode"></a><p class="title"><b>Example 7.6. Creating a combo box</b></p><pre class="programlisting">
    Ewl_Widget *combo = ewl_combo_new("combo box");
    ewl_callback_append(combo, EWL_CALLBACK_VALUE_CHANGED, 
                                     combo_change_cb, NULL);
    ewl_widget_show(combo);

    Ewl_widget *item1 = ewl_menu_item_new(NULL, "foo");
    ewl_container_child_append(EWL_CONTAINER(combo));
    ewl_widget_show(item1);
 </pre></div><p>
</p><p>
</p><div class="example"><a name="sec-EwlComboCodeCB"></a><p class="title"><b>Example 7.7. callback de cambio de valor combobox</b></p><pre class="programlisting">
void combo_change_cb(Ewl_Widget *w, void *event, void *data) {
    char *text = (char *)event;
    printf("Value changed to %s\n", text);
}
 </pre></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlDialog"></a>ewl_dialog</h2></div></div><div></div></div><p>
El widget <tt class="literal">Ewl_Dialog</tt> provee una manera de mostrar al usuario una simple caja de diálogo 
que puede esperar una respuesta, dar avisos, o simplemente mostrar mensajes.
</p><p>
 </p><div class="figure"><a name="id2512949"></a><p class="title"><b>Figure 7.4. Un diálogo EWL</b></p><span class="inlinemediaobject"><img src="img/dialog_box.png" alt="Ejemplo de una caja de diálogo EWL"></span></div><p>
</p><p>
</p><div class="example"><a name="sec-EwlDialogCode"></a><p class="title"><b>Example 7.8. código de diálogo EWL</b></p><pre class="programlisting">
    Ewl_Widget *dialog = NULL;
    Ewl_Widget *o = NULL;

    o = ewl_text_new("a dialog eh");
    ewl_object_alignment_set(EWL_OBJECT(o),
    EWL_FLAG_ALIGN_CENTER);
    ewl_widget_show(o);

    dialog = ewl_dialog_new(EWL_POSITION_BOTTOM);
    ewl_dialog_set_has_separator(EWL_DIALOG(dialog), 0);
    ewl_dialog_add_widget(EWL_DIALOG(dialog), o);
    ewl_object_alignment_set(EWL_OBJECT(dialog), EWL_FLAG_ALIGN_CENTER);
    ewl_widget_show(dialog);

    o = ewl_dialog_set_button(EWL_STOCK_OK, EWL_RESPONSE_OK);
    ewl_container_child_append(EWL_CONTAINER(dialog), o);
    ewl_callback_append(o, EWL_CALLBACK_CLICKED, dialog_clicked_cb, dialog);
    ewl_widget_show(o);

    o = ewl_dialog_set_button(EWL_STOCK_CANCEL, EWL_RESPONSE_CANCEL);
    ewl_container_child_append(EWL_CONTAINER(dialog), o);
    ewl_callback_append(o, EWL_CALLBACK_CLICKED, dialog_clicked_cb, dialog);
    ewl_widget_show(o);
</pre></div><p>
Este ejemplo creará un <tt class="literal">Ewl_Dialog</tt> con dos botones:
un botón de OK y un botón de Cancel. El própio diálogo es creado con la llamada a 
<tt class="function">ewl_dialog_new()</tt> pasándole la posición de los botones relativa a la 
propia ventana. Los valores posibles son:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_POSITION_TOP</p></li><li style="list-style-type: disc"><p>EWL_POSITION_BOTTOM</p></li><li style="list-style-type: disc"><p>EWL_POSITION_LEFT</p></li><li style="list-style-type: disc"><p>EWL_POSITION_RIGHT</p></li></ul></div><p> 
</p><p>
Un <tt class="literal">Ewl_Dialog</tt> puede opcionalmente tener dibujada una linea horizontal para separar 
las dos secciones del diálogo. La linea se controla con <tt class="function">ewl_dialog_set_has_separator()</tt> 
donde 0 significa no dibujar el separador y 1 significa dibujarlo. Hay una correspondiente
<tt class="function">ewl_dialog_get_has_separator()</tt> que devuelve 1 si hay separador y 0 de si no lo hay.
</p><p>
El contenido del área principal de display de la caja es controlado por medio de la función 
<tt class="function">ewl_dialog_add_widget()</tt>. En este caso añadimos un objeto <tt class="literal">Ewl_Text</tt>
al dialogo.
</p><p>
Una vez el diálogo ha sido inicializado necesitamos crear los botones deseados. Los botones son creados 
llamando a <tt class="function">ewl_dialog_set_button()</tt>, que creará un botón. Los parámetros son la etiqueta 
del botón y el código de respuesta que devolver desde el botón. Hay varias etiquetas predefinidas, incluyendo:

</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_STOCK_OK</p></li><li style="list-style-type: disc"><p>EWL_STOCK_APPLY</p></li><li style="list-style-type: disc"><p>EWL_STOCK_CANCEL</p></li><li style="list-style-type: disc"><p>EWL_STOCK_OPEN</p></li><li style="list-style-type: disc"><p>EWL_STOCK_SAVE</p></li><li style="list-style-type: disc"><p>EWL_STOCK_PAUSE</p></li><li style="list-style-type: disc"><p>EWL_STOCK_PLAY</p></li><li style="list-style-type: disc"><p>EWL_STOCK_STOP</p></li></ul></div><p>
Los códigos de respuesta predefinidos son:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_RESPONSE_OPEN</p></li><li style="list-style-type: disc"><p>EWL_RESPONSE_SAVE</p></li><li style="list-style-type: disc"><p>EWL_RESPONSE_OK</p></li><li style="list-style-type: disc"><p>EWL_RESPONSE_CANCEL</p></li><li style="list-style-type: disc"><p>EWL_RESPONSE_APPLY</p></li><li style="list-style-type: disc"><p>EWL_RESPONSE_PLAY</p></li><li style="list-style-type: disc"><p>EWL_RESPONSE_PAUSE</p></li><li style="list-style-type: disc"><p>EWL_RESPONSE_STOP</p></li></ul></div><p>
Una vez que los botones son creados necesitan ser añadidos al diálogo y tener un callback añadido 
para su estado <tt class="literal">EWL_CALLBACK_CLICKED</tt>.
</p><p>
</p><div class="example"><a name="sec-EwlDialogCB"></a><p class="title"><b>Example 7.9. Callback de diálogo EWL</b></p><pre class="programlisting">
void dialog_clicked_cb(Ewl_Widget *w, void *event, void *data) {
    int d = EWL_BUTTON_STOCK(w)-&gt;response_id;

    if (d == EWL_RESPONSE_OK)
        printf("OK\n");
    else if (d == EWL_RESPONSE_CANCEL)
        printf("CANCEL\n");

    ewl_widget_destroy(EWL_WIDGET(data));
}
</pre></div><p>
El código de respuesta del botón que fué pulsado está disponible en el propio widget 
<tt class="literal">Ewl_Button_Stock</tt> a través de su parámetro response_id. Usando este valor 
podemos determinar que botón fué pulsado. También pasamos el propio <tt class="literal">Ewl_Dialog</tt> 
mediante el parámetro de datos de manera que podemos destruir el diálogo cuando hemos terminado.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlEntry"></a>ewl_entry</h2></div></div><div></div></div><p>
La caja de entrada EWL está disponible cuando necesites recibir entrada de texto del usuario. La caja 
funciona en simples líneas, y el callback es accionado cuando el usuario presiona la tecla "Enter".
</p><p>
 </p><div class="figure"><a name="id2513325"></a><p class="title"><b>Figure 7.5. Una caja de entrada EWL</b></p><span class="inlinemediaobject"><img src="img/entry.png" alt="Ejeplo de una caja de entrada EWL"></span></div><p>
</p><p>
 </p><div class="example"><a name="id2513357"></a><p class="title"><b>Example 7.10. Creando una caja de entrada EWL</b></p><pre class="programlisting">
   Ewl_Widget *entry = ewl_entry_new();
   ewl_object_size_request(EWL_OBJECT(entry), 100, 15);
   ewl_object_padding_set(EWL_OBJECT(entry), 1, 1, 1, 1);
   ewl_callback_append(entry, EWL_CALLBACK_VALUE_CHANGED, entry_cb, NULL);
   ewl_widget_show(entry);
  </pre></div><p> 
<tt class="literal">Ewl_Entry</tt> es un objeto bastante simple con el que trabajar, la 
única inicialización requerida es crear el nuevo objeto y vincular un callback para eventos 
<tt class="literal">EWL_CALLBACK_VALUE_CHANGED</tt>. Este ejemplo toma los pasos extra 
de seleccionar el tamaño con <tt class="function">ewl_object_size_request()</tt> y añadir 
un poco de relleno al widget con <tt class="function">ewl_object_padding_set()</tt>.
</p><p>
 </p><div class="example"><a name="id2513412"></a><p class="title"><b>Example 7.11. callback de cambio de valor para Ewl_Entry</b></p><pre class="programlisting">
void entry_cb(Ewl_Widget *w, void *event, void *data) {
    char *s = ewl_entry_get_text(EWL_ENTRY(w));
    printf("%s\n", s);

    ewl_entry_set_text(EWL_ENTRY(w), "New Text");
}
  </pre></div><p>
Este callback captura el valor actual del widget entrada con la llamada a 
<tt class="function">ewl_entry_get_text()</tt> y entonces resetea el texto al valor "New Text" 
llamando a <tt class="function">ewl_entry_set_text()</tt>.
</p><p>
El objeto <tt class="literal">Ewl_Entry</tt> te permite configurarsi el texto es o no editable con una llamada a 
<tt class="function">void ewl_entry_set_editable(Ewl_Entry *, unsigned int edit)</tt>
donde <tt class="literal">edit</tt> es 0 para ineditable y 1 para editable.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlFileDialog"></a>ewl_filedialog</h2></div></div><div></div></div><p>
A menudo se desea permitir al usuario abrir y grabar archivos. Esto puede ser fácilmente hecho con el 
uso de <tt class="literal">Ewl_Filedialog</tt>.
</p><p>
 </p><div class="figure"><a name="id2513502"></a><p class="title"><b>Figure 7.6. Un diálogo de archivo EWL</b></p><span class="inlinemediaobject"><img src="img/file_dialog.png" alt="Ejemplo de un diálogo de archivo EWL"></span></div><p>
Este diálogo de archivo ha sido empotrado en su propia ventana, pero podría haber sido puesto en 
otra ventana de la misma manera.
</p><p>
 </p><div class="example"><a name="id2513540"></a><p class="title"><b>Example 7.12. Creando un diálogo de archivo EWL</b></p><pre class="programlisting">
   Ewl_Widget *filedialog = ewl_filedialog_new(EWL_FILEDIALOG_TYPE_OPEN);
   ewl_callback_append(filedialog, EWL_CALLBACK_VALUE_CHANGED, 
                            open_file_cb, NULL);
   ewl_widget_show(filedialog);
  </pre></div><p>
Cuando el diálogo de archivo es creado especificas un tipo, bien <tt class="literal">EWL_FILDIALOG_TYPE_OPEN</tt> 
o bien <tt class="literal">EWL_FILEDIALOG_TYPE_SAVE</tt>, dependiendo del tipo de diálogo de archivo deseado. El 
callback <tt class="literal">EWL_CALLBACK_VALUE_CHANGED</tt> será ejecutado cuando el usuario pulse el botón 'Open' 
en el diálogo.
</p><p>
También es posible empaquetar otros widgets en el propio diálogo de archivo. Esto es hecho por medio de 
la habitual <tt class="function">ewl_container_child_append()</tt>. Así, si necesitaras, por ejemplo, añadir 
un botón "Home", crearías el botón y lo empaquetarías en el diálogo de archivo donde aparecerá abajo en la parte 
izquierda. 
</p><p>
Puedes cambiar el directorio que se ve actualmente en el diálogo de archivo ejecutando 
<tt class="function">void ewl_filedialog_set_directory(Ewl_Filedialog *, char *path)</tt>
donde <tt class="literal">path</tt> es la ruta completa al directorio deseado.
</p><p>
 </p><div class="example"><a name="id2513628"></a><p class="title"><b>Example 7.13. callback para Ewl_Filedialog open</b></p><pre class="programlisting">
void open_file_cb(Ewl_Widget *w, void *event, void *data) {
    char *filename = (char *)event;
    printf("selected file %s\n", filename);
}
  </pre></div><p>
El archivo que ha sido seleccionado es pasado al callback como parámetro <tt class="literal">event</tt>.
Si quieres quitar el diálogo de archivo puedes hacer algo similar a <tt class="literal">ewl_widget_hide(fd_win)</tt> 
donde <tt class="literal">fd_win</tt> es el objeto ventana que contiene el diálogo de archivo.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlImage"></a>ewl_image</h2></div></div><div></div></div><p>
</p><div class="example"><a name="id2513690"></a><p class="title"><b>Example 7.14. Ewl_Image</b></p><pre class="programlisting">
    Ewl_Widget *i = ewl_image_new("/usr/foo/img.png", NULL);
    ewl_widget_show(i);
 </pre></div><p>
La función<tt class="function">ewl_image_new()</tt> toma dos parametros, la ruta a la imagen a cargar 
y la clave para los datos de imagen. La clave es usada principalmente para cargar grupos edje o datos 
con clave como imagen.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlMenu"></a>ewl_menu</h2></div></div><div></div></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlNotebook"></a>ewl_notebook</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2513752"></a><p class="title"><b>Figure 7.7. Un libro de notas EWL</b></p><span class="inlinemediaobject"><img src="img/notebook.png" alt="Example of an EWL Notebook"></span></div><p>
</p><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlPassword"></a>ewl_password</h2></div></div><div></div></div><p>
El widget <tt class="literal">ewl_password</tt> provee funcionalidad similar similar al widget <tt class="literal">ewl_text</tt> 
, excepto que cualquier texto tecleado no será mostrado, en su lugar un carácter oscurecedor configurable 
será mostrado.
</p><p>
 </p><div class="figure"><a name="id2513824"></a><p class="title"><b>Figure 7.8. Un diálogo de contraseña EWL</b></p><span class="inlinemediaobject"><img src="img/passwd.png" alt="Ejemplo de un diálogo de contradeña EWL"></span></div><p>
</p><p>
</p><div class="example"><a name="id2513858"></a><p class="title"><b>Example 7.15. Creando un diálogo de contraseña EWL</b></p><pre class="programlisting">
    Ewl_Widget *p = ewl_password_new("default");
    ewl_password_set_obscure(EWL_PASSWORD(p), "-");
    ewl_callback_append(p, EWL_CALLBACK_VALUE_CHANGED, passwd_cb, NULL);
    ewl_widget_show(p);
</pre></div><p>
El carácter oscurecedor por defecto es un carácter "*". Esto se puede cambiar fácilmente llamando a 
<tt class="function">ewl_password_set_obscure(Ewl_Password *, char)</tt>.
Hay también una correspondiente función 
<tt class="function">char ewl_password_get_obscure(Ewl_Password *)</tt> para 
obtener el carácter obscurecedor actual. Como con el widget 
<tt class="literal">ewl_text</tt> hay dos funciones para obtener y colocar el texto del widget:
<tt class="function">ewl_password_set_text(Ewl_Password *, char *)</tt> y
<tt class="function">char *ewl_password_get_text(Ewl_Password *)</tt>.
</p><p>
Cuando el usuario presiona la tecla enter en la caja de contraseña se activará un 
<tt class="literal">EWL_CALLBACK_VALUE_CHANGED</tt> will be triggered.
</p><div class="example"><a name="id2513930"></a><p class="title"><b>Example 7.16. callback de cambio de valor de Ewl_Password</b></p><pre class="programlisting">
void passwd_cb(Ewl_Widget *, void *event, void *data) {
    char *text = ewl_password_get_text(EWL_PASSWORD(w));
    printf("text: %s\n", text);
}
</pre></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlProgressBar"></a>ewl_progressbar</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2513967"></a><p class="title"><b>Figure 7.9. Una barra de progreso EWL</b></p><span class="inlinemediaobject"><img src="img/progressbar.png" alt="Ejemplo de una barra de progreso EWL"></span></div><p>
</p><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-Ewl-RadioButton"></a>ewl_radiobutton</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2514020"></a><p class="title"><b>Figure 7.10. Un radiobutton EWL</b></p><span class="inlinemediaobject"><img src="img/radiobutton.png" alt="Ejemplo de un radiobutton EWL"></span></div><p>
</p><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlScrollpane"></a>ewl_scrollpane</h2></div></div><div></div></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlSeeker"></a>ewl_seeker</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2514091"></a><p class="title"><b>Figure 7.11. Un buscador EWL</b></p><span class="inlinemediaobject"><img src="img/seeker.png" alt="Ejemplo de un buscador EWL"></span></div><p>
</p><p>
</p><div class="example"><a name="id2514123"></a><p class="title"><b>Example 7.17. Creando un buscador EWL</b></p><pre class="programlisting">
    Ewl_Widget *s = ewl_seeker_new(EWL_ORIENTATION_HORIZONTAL);
    ewl_seeker_value_set(EWL_SEEKER(s), 5.0);
    ewl_seeker_range_set(EWL_SEEKER(s), 10.0);
    ewl_seeker_step_set(EWL_SEEKER(s), 1);
    ewl_callback_append(s, EWL_CALLBACK_VALUE_CHANGED, seeker_cb, NULL);
    ewl_widget_show(s);
</pre></div><p>
</p><p>
</p><div class="example"><a name="id2514146"></a><p class="title"><b>Example 7.18. Ewl_Seeker callback</b></p><pre class="programlisting">
void seeker_cb(Ewl_Widget *w, void *event, void *data) {
    double val = ewl_seeker_value_get(EWL_SEEKER(w));
    printf("%f\n", val);
}
</pre></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlSpinner"></a>ewl_spinner</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2514183"></a><p class="title"><b>Figure 7.12. Un spinner EWL</b></p><span class="inlinemediaobject"><img src="img/spinner.png" alt="Ejemplo de un spinner EWL"></span></div><p>
</p><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlTable"></a>ewl_table</h2></div></div><div></div></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlText"></a>ewl_text</h2></div></div><div></div></div><p>
El widget <tt class="literal">Ewl_Text</tt> provee un widget de texto multilínea. Puede ser usado cuando se 
requiere mostrar texto en una aplicación. Funciona bien con el <tt class="literal">Ewl_Scrollpane</tt> para
proveer un área de texto desplazable.
</p><p>
</p><div class="example"><a name="sec-EwlTextCode"></a><p class="title"><b>Example 7.19. Código Ewl_Text</b></p><pre class="programlisting">
    Ewl_Widget *text = ewl_text_new("text");
    ewl_widget_show(text);
</pre></div><p>
Crear el objeto <tt class="literal">Ewl_Text</tt> es bastante simple, el objeto será iniciado para mostrar 
el parámetro a <tt class="function">ewl_text_new()</tt>.
</p><p>
Una vez el objeto de texto es creado puedes cambiar el texto, recuperar el contenido del texto actual 
u obtener la longitud del texto con:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p><tt class="function">ewl_text_text_set(Ewl_Text *, char *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">ewl_text_text_prepend(Ewl_Text *, char *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">ewl_text_text_append(Ewl_Text *, char *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">ewl_text_text_insert(Ewl_Text *, char *, int index)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">char *ewl_text_text_get(Ewl_Text *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">int ewl_text_length_get(Ewl_Text *)</tt></p></li></ul></div><p>
</p><p>
El widget <tt class="literal">Ewl_Text</tt> te permite hacer cambios de estilización al texto en el widget. 
Diferentes porciones del texto pueden ser de diferentes colores, fuentes, o estilos. El estilo aplicaco a un 
widget se basa en que está configurado cuando el texto es añadido al widget. Así, si quieres que tu texto 
sea rojo, necesitas seleccionar el color del objeto <tt class="literal">Ewl_Text</tt> <span class="emphasis"><em>antes</em></span>, 
añadiendo el texto después.
</p><p>
El color del texto puede ser manipulado con la llamada 
<tt class="function">ewl_text_color_set(Ewl_Text *, int r, int g, int b, int a)</tt>
, mientras que la información de color actual puede ser obtenida con 
<tt class="function">ewl_text_color_get(Ewl_Text *, int *r, int *g, int *b, int *a)</tt>.
</p><p>
La configuración de fuentes del texto puede ser manipulada con 
<tt class="function">ewl_text_font_set(Ewl_Text *, char *font, int size)</tt>
. Con las llamadas para obtener el nombre de fuente actual y el tamaño definidas como:
<tt class="function">char *ewl_text_font_get(Ewl_Text *)</tt> and
<tt class="function">int ewl_text_font_size_get(Ewl_Text *)</tt>.
</p><p>
Para obtener o colocar la alineación del widget de texto hay dos funciones:
<tt class="function">ewl_text_align_set(Ewl_Text *, unsigned int align)</tt>
y <tt class="function">unsigned int ewl_text_align_get(Ewl_Text *)</tt>. Donde el parámetro 
de alineación es una de las opciones de alineación EWL:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_CENTER</p></li><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_LEFT</p></li><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_RIGHT</p></li><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_TOP</p></li><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_BOTTOM</p></li></ul></div><p>
</p><p>
También es posible colocar el estilo del texto. Esto puede incluir cosas como hacer el texto 
en negrita o colocar sombras suaves. Los estilos que están disponibles son obtenidos por medio 
de la librería Etox e incluyen actualmente:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>bold</p></li><li style="list-style-type: disc"><p>outline</p></li><li style="list-style-type: disc"><p>plain</p></li><li style="list-style-type: disc"><p>raised</p></li><li style="list-style-type: disc"><p>shadow</p></li><li style="list-style-type: disc"><p>soft_shadow</p></li></ul></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlTooltip"></a>ewl_tooltip</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2514571"></a><p class="title"><b>Figure 7.13. Un tooltip EWL</b></p><span class="inlinemediaobject"><img src="img/tooltip.png" alt="Ejemplo de un tooltip EWL"></span></div><p>
</p><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlTree"></a>ewl_tree</h2></div></div><div></div></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlMedia"></a>ewl_media</h2></div></div><div></div></div><p>
El widget <tt class="literal">Ewl_Media</tt> permite empotrar objetos de vídeo en tu aplicación. Esto es hecho 
mediante un envoltorio de la librería Emotion.
</p><p>
 </p><div class="figure"><a name="id2514655"></a><p class="title"><b>Figure 7.14. Un objeto media EWL</b></p><span class="inlinemediaobject"><img src="img/ewl_media.png" alt="Ejemplo de un objeto Media EWL"></span></div><p>
</p><p>
</p><div class="example"><a name="sec-EwlMediaCode"></a><p class="title"><b>Example 7.20. Ewl_Media code</b></p><pre class="programlisting">
    Ewl_Media *m = ewl_media_new(file);
    ewl_callback_append(m, EWL_CALLBACK_REALIZE, video_realize_cb, NULL);
    ewl_callback_append(m, EWL_CALLBACK_VALUE_CHANGED, video_change_cb, NULL);
    ewl_widget_show(m);
</pre></div><p>
Crear el objeto de vídeo básico es tan simple como crear el objeto y mostrarlo ( suponiendo que lo hayas 
añadido a cualquier contenedor en el que esté colocado ). Vinculamos los dos callbacks
<tt class="literal">EWL_CALLBACK_REALIZE</tt> y
<tt class="literal">EWL_CALLBACK_VALUE_CHANGED</tt>. Vinculamos el callback realize para poder determinar la 
longitud del vídeo a ser mostrado si lo deseamos. Esto solo está disponible después de que el vídeo 
haya sido realizado, y devolverá 0 hasta que haya sido realizado. El callback de cambio de valor 
será llamado cuando emotion avance el vídeo. Esto puede ser usado para un temporizador o una seekbar y 
hacer que autoavance con el vídeo.
</p><p>
</p><div class="example"><a name="id2514743"></a><p class="title"><b>Example 7.21. Ewl_Media callbacks</b></p><pre class="programlisting">
void video_realize_cb(Ewl_Widget *w, void *event, void *data) {
    double len = ewl_media_length_get(EWL_MEDIA(video));
}   

void video_change_cb(Ewl_Widget *w, void *event, void *data) {
    char buf[512];
    int h, m;
    double s;
                
    ewl_media_position_time_get(EWL_MEDIA(video), &amp;h, &amp;m, &amp;s);
    snprintf(buf, sizeof(buf), "%02i:%02i:%02.0f", h, m, s);
}
 </pre></div><p>
</p><p>
El vídeo que está siendo mostrado puede ser cambiado llamando a 
<tt class="function">ewl_media_media_set(Ewl_Media *, char *)</tt> o si solo quieres saber lo que se 
está reproduciendo actualmente puedes llamar a <tt class="function">char *ewl_media_media_get(Ewl_Media *)</tt>. 
La longitud del vídeo actual puede ser obtenida llamando a <tt class="function">int
ewl_media_length_get(Ewl_Media *)</tt>. La longitud puede también ser obtenida como valor 
de tiempo llamando a <tt class="function">ewl_media_length_time_get(Ewl_Media *, int h, int m, double s)</tt>.
</p><p>
Puedes empezar la reproducción de vídeo pasando 1 a <tt class="function">ewl_media_play_set(Ewl_Media *, int)</tt> 
o parar el video pasando 0 a la misma función.
</p><p>
Para determinar si el codec de video permite búsqueda en el video puedes llamar a 
<tt class="function">int ewl_media_seekable_get(Ewl_Media *)</tt> que devolverá 1 si el video permite búsqueda, 
y 0 si no.
<tt class="function">double ewl_media_position_get(Ewl_Media *)</tt> es usada para determinar la posición actual 
en el video, mientras que<tt class="function">ewl_media_position_set(Ewl_Media *, double position)</tt>
puede ser usada para seleccionar la posición en el video. Este valor puede también ser obtenido como 
horas, minutos, y segundos llamando a <tt class="function">ewl_media_position_time_get(Ewl_Media *, int h, int m, double s)</tt>.
</p><p>
Si quieres cambiar la configuración de audio del video hay varias funciones disponibles. Estas 
incluyen la habilidad de obtener/colocar la configuración de mute:
<tt class="function">int ewl_media_audio_mute_get(Ewl_Media *)</tt> y
<tt class="function">ewl_media_audio_mute_set(Ewl_Media *, int)</tt>. También puedes obtener/colocar el 
volumen del video por medio de: <tt class="function">int ewl_media_audio_volume_get(Ewl_Media *)</tt> y
<tt class="function">ewl_media_audio_volume_set(Ewl_Media *, int)</tt>.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlWindow"></a>ewl_window</h2></div></div><div></div></div><p>
Una ewl_window será usada por toda aplicación EWL. Esta es la ventana que mostrará todos los otros 
widgets que se deseen.
</p><p>
 </p><div class="figure"><a name="id2514926"></a><p class="title"><b>Figure 7.15. Una ventana EWL</b></p><span class="inlinemediaobject"><img src="img/create_window.png" alt="Ejemplo de una ventana EWL"></span></div><p>
</p><p>
 </p><div class="example"><a name="sec-EwlWindowCode"></a><p class="title"><b>Example 7.22. Creando una ventana EWL</b></p><pre class="programlisting">
    Ewl_Widget *window = ewl_window_new();
    ewl_window_title_set(EWL_WINDOW(window), "foo window");
    ewl_window_class_set(EWL_WINDOW(window), "foo_class");
    ewl_window_name_set(EWL_WINDOW(window), "foo_name");
    ewl_object_size_request(EWL_OBJECT(window), 300, 400);
    ewl_callback_append(window, EWL_CALLBACK_DELETE_WINDOW, win_del_cb, NULL);
    ewl_widget_show(window);
  </pre></div><p>
Iniciar la ventana básica es bastante simple. Tomamos los pasos extra de llamar:
<tt class="function">ewl_window_title_set()</tt>, 
<tt class="function">ewl_window_name_set()</tt> y <tt class="function">ewl_window_class_set()</tt>
para rellenar la información que usa el gestor de ventanas.
</p><p>
Dado que la ventana es un <tt class="literal">Ewl_Object</tt> como cualquier otro usamos <tt class="function">ewl_object_size_request()</tt> 
para requerir el tamaño inicial de nuestra ventana. Podríamos haber llamado también a <tt class="function">ewl_object_minimum_size_set()</tt> 
y <tt class="function">ewl_object_maximum_size_set()</tt> para restringir los tamaños mínimo y máximo de 
nuestra ventana.
</p><p>
El callback principal usado por una Ewl_Window es <tt class="literal">EWL_CALLBACK_DELETE_WINDOW</tt>.
Este será llamado cuando la ventana sea destruida por el gestor de ventanas. Debería ser usado para limpiar 
los recursos que la aplicación ha usado antes de salir de la aplicación.
</p><p>
 </p><div class="example"><a name="sec-EwlWindowDestroyCb"></a><p class="title"><b>Example 7.23. Ewl Window destroy callback</b></p><pre class="programlisting">
void win_del_cb(Ewl_Widget *w, void *event, void *data) {
    ewl_widget_destroy(w);
    ewl_main_quit();
}
 </pre></div><p>
</p><p>
Algunas de las otras operaciones relacionadas con el objeto Ewl_Window son:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p><tt class="function">char *ewl_window_title_get(Ewl_Window *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">char *ewl_window_name_get(Ewl_Window *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">char *ewl_window_class_get(Ewl_Window *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">void ewl_window_borderless_set(Ewl_Window *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">void ewl_window_move(Ewl_Window *, int x, int y)</tt></p></li><li style="list-style-type: disc"><p>
  <tt class="function">void ewl_window_position_get(Ewl_Window *, int *x, int *y)</tt>
 </p></li></ul></div><p>
Las primeras tres llamadas son bastante autoexplicatorias. <tt class="function">ewl_window_borderless_set()</tt> 
puede ser usada para decir al gestor de ventanas que no muestre ninguna decoración alrededor de la ventana, 
esto incluye el borde y la barra de título. La función <tt class="function">ewl_window_move()</tt> es usada para
posicionar la ventana en un lugar específico del escritorio, indexado desde la esquina superior izquierda.
También hay una función <tt class="function">ewl_window_position_get()</tt> que devolverá la posición 
de la ventana en el escritorio.
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-Contributing"></a>Chapter 8. Contribuyendo</h2></div></div><div></div></div><p>
Si encontraste este documento útil, pero carente en algún respecto, considera el contribuir 
al propio documento. Este documento está disponible bajo una licencia abierta y cualquier contribución 
es muy apreciada. Contribuciones ( en Inglés ) pueden ser enviadas a : 
<tt class="literal"><a href="mailto:zero@perplexity.org" target="_top">zero@perplexity.org</a></tt>.
Para cuestiones específicas de la traducción al castellano intenta : 
<tt class="literal"><a href="mailto:rtx@papelmail.com" target="_top">rtx</a></tt>
</p><p>
Observa que cualquier contribución a este documento necesita estar licenciada bajo la licencia que 
este documento usa, la Creative Commons NonCommercial-ShareAlike 1.0 License.
</p><p>
Si deseas contribuir a la EWL o a otra parte de las EFL, hecha un vistazo al website de
<tt class="literal"><a href="http://www.enlightenment.org" target="_top">www.enlightenment.org</a></tt>.
Toda la información sobre acceder CVS y las listas de email puede ser encontrada allí.
</p><p>Gracias.</p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="apx-ewl_media_player_example"></a>Appendix A. Ejemplo de reproductor de media EWL</h2></div></div><div></div></div><p>
</p><div class="example"><a name="id2518113"></a><p class="title"><b>Example A.1. Reproductor de media EWL</b></p><pre class="programlisting">
#include &lt;Ewl.h&gt;

static Ewl_Widget *video;
static Ewl_Widget *fd_win;
static Ewl_Widget *seeker;

typedef struct {
    char *name;
    Ewl_Callback_Function func;
} Control;

void del_cb(Ewl_Widget *w, void *event, void *data) {
    ewl_widget_hide(w);
    ewl_widget_destroy(w);
    ewl_main_quit();
}

void play_cb(Ewl_Widget *w, void *event, void *data ) {
    ewl_media_play_set(EWL_MEDIA(video), 1);
}

void stop_cb(Ewl_Widget *w, void *event, void *data ) {
    ewl_media_play_set(EWL_MEDIA(video), 0);
}

void ff_cb(Ewl_Widget *w, void *event, void *data ) {
    double p = ewl_media_position_get(EWL_MEDIA(video));
    ewl_media_position_set(EWL_MEDIA(video), p + 10.0);
}

void rew_cb(Ewl_Widget *w, void *event, void *data ) {
    double p = ewl_media_position_get(EWL_MEDIA(video));
    ewl_media_position_set(EWL_MEDIA(video), p - 10.0);
}

void video_realize_cb(Ewl_Widget *w, void *event, void *data) {
    double len = ewl_media_length_get(EWL_MEDIA(video));
    ewl_seeker_range_set(EWL_SEEKER(seeker), len);
}

void video_change_cb(Ewl_Widget *w, void *event, void *data) {
    char buf[512];
    int h, m;
    double s;
    Ewl_Text *t = (Ewl_Text *)data;
    double pos = ewl_media_position_get(EWL_MEDIA(video));

    ewl_seeker_value_set(EWL_SEEKER(seeker), pos);
    ewl_media_position_time_get(EWL_MEDIA(video), &amp;h, &amp;m, &amp;s);
    snprintf(buf, sizeof(buf), "%02i:%02i:%02.0f", h, m, s);
    ewl_text_text_set(t, buf);
}

void seeker_move_cb(Ewl_Widget *w, void *event, void *data) {
    double val = ewl_seeker_value_get(EWL_SEEKER(seeker));
    ewl_media_position_set(EWL_MEDIA(video), val);
}

void fd_win_del_cb(Ewl_Widget *w, void *event, void *data) {
    ewl_widget_hide(w);
    ewl_widget_destroy(w);
}

void open_file_cb(Ewl_Widget *w, void *event, void *data) {
    char *file = NULL;

    ewl_widget_hide(fd_win);
    file = (char *)event;
    if (file) 
        ewl_media_media_set(EWL_MEDIA(video), file);
}

void open_cb(Ewl_Widget *w, void *event, void *data ) {
    Ewl_Widget *fd = NULL;

    if (fd_win) {
        ewl_widget_show(fd_win);
        return;
    }

    fd_win = ewl_window_new();
    ewl_window_title_set(EWL_WINDOW(fd_win), "EWL Media Open");
    ewl_window_class_set(EWL_WINDOW(fd_win), "EWL_Media_Open");
    ewl_window_name_set(EWL_WINDOW(fd_win), "EWL_Media_Open");
    ewl_callback_append(fd_win, EWL_CALLBACK_DELETE_WINDOW, 
                    fd_win_del_cb, NULL);
    ewl_widget_show(fd_win);

    fd = ewl_filedialog_new(EWL_FILEDIALOG_TYPE_OPEN);
    ewl_container_child_append(EWL_CONTAINER(fd_win), fd);
    ewl_callback_append(fd, EWL_CALLBACK_VALUE_CHANGED, open_file_cb, NULL);
    ewl_widget_show(fd);
}

void key_up_cb(Ewl_Widget *w, void *event, void *data) {
    Ewl_Event_Key_Up *e = (Ewl_Event_Key_Up *)event;

    if (!strcmp(e-&gt;keyname, "p"))
        ewl_media_play_set(EWL_MEDIA(video), 1);

    else if (!strcmp(e-&gt;keyname, "s"))
        ewl_media_play_set(EWL_MEDIA(video), 0);

    else if (!strcmp(e-&gt;keyname, "q"))
        del_cb(w, event, data);
}

int main(int argc, char ** argv) {
    Ewl_Widget *win = NULL, *o = NULL, *b = NULL;
    Ewl_Widget *controls = NULL, *time = NULL;
    char * file = NULL;

    if (!ewl_init(&amp;argc, argv)) {
        printf("Can't init ewl");
        return 1;
    }

    if (argc &gt; 1)
        file = argv[1];

    win = ewl_window_new();
    ewl_window_title_set(EWL_WINDOW(win), "EWL Media test");
    ewl_window_name_set(EWL_WINDOW(win), "EWL_Media_test");
    ewl_window_class_set(EWL_WINDOW(win), "EWL_Media_test");
    ewl_callback_append(win, EWL_CALLBACK_DELETE_WINDOW, del_cb, NULL);
    ewl_callback_append(win, EWL_CALLBACK_KEY_UP, key_up_cb, NULL);
    ewl_object_size_request(EWL_OBJECT(win), 320, 280);
    ewl_object_fill_policy_set(EWL_OBJECT(win), EWL_FLAG_FILL_ALL);
    ewl_widget_show(win);

    /* box to contain everything */
    b = ewl_vbox_new();
    ewl_container_append_child(EWL_CONTAINER(win), b);
    ewl_object_fill_policy_set(EWL_OBJECT(b), EWL_FLAG_FILL_ALL);
    ewl_widget_show(b);

    /* create the time widget now so we can pass it to the video as data */
    time = ewl_text_new("00:00:00");

    /* the video */
    video = ewl_media_new(file);
    ewl_container_child_append(EWL_CONTAINER(b), video);
    ewl_object_fill_policy_set(EWL_OBJECT(video), EWL_FLAG_FILL_ALL);
    ewl_callback_append(video, EWL_CALLBACK_REALIZE, video_realize_cb, NULL);
    ewl_callback_append(video, EWL_CALLBACK_VALUE_CHANGED, video_change_cb, time);
    ewl_widget_show(video);

    /* box to contain contols and scrollers */
    controls = ewl_vbox_new();
    ewl_object_fill_policy_set(EWL_OBJECT(controls), 
                 EWL_FLAG_FILL_VSHRINK | EWL_FLAG_FILL_HFILL);
    ewl_container_child_append(EWL_CONTAINER(b), controls);
    ewl_widget_show(controls);

    /* hold he controls */
    b = ewl_hbox_new();
    ewl_container_child_append(EWL_CONTAINER(controls), b);
    ewl_widget_show(b);

    {
        Control controls [] = {
            { "play", play_cb },
            { "stop", stop_cb },
            { "rewind", rew_cb },
            { "fast forward", ff_cb },
            { "open", open_cb },
            { NULL, NULL }
        };
        int i;

        for(i = 0; controls[i].name != NULL; i++) {
            o = ewl_button_with_stock_new(controls[i].name);
            ewl_container_child_append(EWL_CONTAINER(b), o);
            ewl_callback_append(o, EWL_CALLBACK_CLICKED, 
                                    controls[i].func, NULL);
            ewl_widget_show(o);
        }
    }

    b = ewl_hbox_new();
    ewl_container_child_append(EWL_CONTAINER(controls), b);
    ewl_widget_show(b);

    /* the video seeker */
    seeker = ewl_seeker_new(EWL_ORIENTATION_HORIZONTAL);
    ewl_container_child_append(EWL_CONTAINER(b), seeker);
    ewl_object_fill_policy_set(EWL_OBJECT(seeker), 
            EWL_FLAG_FILL_VSHRINK | EWL_FLAG_FILL_HFILL);
    ewl_seeker_value_set(EWL_SEEKER(seeker), 0.0);
    ewl_seeker_range_set(EWL_SEEKER(seeker), 0.0);
    ewl_seeker_step_set(EWL_SEEKER(seeker), 1.0);
    ewl_callback_append(seeker, EWL_CALLBACK_VALUE_CHANGED, seeker_move_cb, NULL);
    ewl_widget_show(seeker);

    /* the time text spot */
    ewl_container_child_append(EWL_CONTAINER(b), time);
    ewl_object_insets_set(EWL_OBJECT(time), 0, 3, 0, 0);
    ewl_object_fill_policy_set(EWL_OBJECT(time), EWL_FLAG_FILL_SHRINK);
    ewl_widget_show(time);

    ewl_main();
    return 0;
}
</pre></div><p>
</p></div></div></body></html>
