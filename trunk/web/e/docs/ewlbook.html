<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>The EWL book</title><meta name="generator" content="DocBook XSL Stylesheets V1.64.1"><meta name="description" content="
  This book is a tutorial on the use of the EWL (Enlightened Widget Library).
  "></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="id2439822"></a>The EWL book</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">dan</span> <span class="othername">'dj2'</span> <span class="surname">sinclair</span></h3></div></div></div><div><div class="legalnotice"><p>
  This work is licensed under the Creative Commons NonCommercial-ShareAlike
  License. To view a copy of this license, visit
  <a href="http://creativecommons.org/licenses/nc-sa/1.0/" target="_top">
  http://creativecommons.org/licenses/nc-sa/1.0/</a> or send a letter to
  Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.
  </p></div></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.1</td><td align="left">July 07, 2004</td><td align="left">dj2</td></tr><tr><td align="left" colspan="3">Initial document</td></tr><tr><td align="left">Revision 0.2</td><td align="left">July 10, 2004</td><td align="left">dj2</td></tr><tr><td align="left" colspan="3">Flush out some of the widget information</td></tr><tr><td align="left">Revision 0.3</td><td align="left">July 15, 2004</td><td align="left">dj2</td></tr><tr><td align="left" colspan="3">Add more widgets, add some hierarchy stuff</td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>
  This book is a tutorial on the use of the EWL (Enlightened Widget Library).
  </p></div></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#ch-Intro">1. Introduction</a></span></dt><dt><span class="chapter"><a href="#ch-GettingStarted">2. Getting Started</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec-Installation">Getting EWL installed</a></span></dt><dt><span class="sect1"><a href="#sec-CreateWindow">Creating a simple Window</a></span></dt><dt><span class="sect1"><a href="#sec-HelloWorld">Hello World</a></span></dt><dt><span class="sect1"><a href="#sec-Callbacks">Callbacks</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch-OjbectHierarchy">3. Object Hierarchy</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec-ObjHierIntro">Introduction</a></span></dt><dt><span class="sect1"><a href="#sec-ObjHierCasting">Object Casting</a></span></dt><dt><span class="sect1"><a href="#sec-ObjHierNewWidget">Adding new widgets</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch-WidgetPacking">4. Widget Packing</a></span></dt><dt><span class="chapter"><a href="#ch-Config">5. Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2510713">EWL configuration</a></span></dt><dt><span class="sect1"><a href="#id2511659">Application configuration</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch-Themes">6. EWL Themes</a></span></dt><dt><span class="chapter"><a href="#ch-Widgets">7. Widgets</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec-EwlBox">ewl_hbox and ewl_vbox</a></span></dt><dt><span class="sect1"><a href="#sec-EwlButton">ewl_button</a></span></dt><dt><span class="sect1"><a href="#sec-EwlCheckButton">ewl_checkbutton</a></span></dt><dt><span class="sect1"><a href="#sec-EwlCombo">ewl_combo</a></span></dt><dt><span class="sect1"><a href="#sec-EwlDialog">ewl_dialog</a></span></dt><dt><span class="sect1"><a href="#sec-EwlEntry">ewl_entry</a></span></dt><dt><span class="sect1"><a href="#sec-EwlFileDialog">ewl_filedialog</a></span></dt><dt><span class="sect1"><a href="#sec-EwlImage">ewl_image</a></span></dt><dt><span class="sect1"><a href="#sec-EwlMenu">ewl_menu</a></span></dt><dt><span class="sect1"><a href="#sec-EwlNotebook">ewl_notebook</a></span></dt><dt><span class="sect1"><a href="#sec-EwlPassword">ewl_password</a></span></dt><dt><span class="sect1"><a href="#sec-EwlProgressBar">ewl_progressbar</a></span></dt><dt><span class="sect1"><a href="#sec-Ewl-RadioButton">ewl_radiobutton</a></span></dt><dt><span class="sect1"><a href="#sec-EwlScrollpane">ewl_scrollpane</a></span></dt><dt><span class="sect1"><a href="#sec-EwlSeeker">ewl_seeker</a></span></dt><dt><span class="sect1"><a href="#sec-EwlSpinner">ewl_spinner</a></span></dt><dt><span class="sect1"><a href="#sec-EwlTable">ewl_table</a></span></dt><dt><span class="sect1"><a href="#sec-EwlText">ewl_text</a></span></dt><dt><span class="sect1"><a href="#sec-EwlTooltip">ewl_tooltip</a></span></dt><dt><span class="sect1"><a href="#sec-EwlTree">ewl_tree</a></span></dt><dt><span class="sect1"><a href="#sec-EwlMedia">ewl_media</a></span></dt><dt><span class="sect1"><a href="#sec-EwlWindow">ewl_window</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch-Contributing">8. Contributing</a></span></dt><dt><span class="appendix"><a href="#apx-ewl_media_player_example">A. EWL Media Player Example</a></span></dt></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>3.1. <a href="#fig-obj_hierarchy">The EWL Object Hierarchy</a></dt><dt>4.1. <a href="#fig-padding_inset_diagram">Padding and Insets</a></dt><dt>7.1. <a href="#id2512255">An Ewl Button</a></dt><dt>7.2. <a href="#id2512389">An Ewl Checkbutton</a></dt><dt>7.3. <a href="#id2512489">An Ewl Combo box</a></dt><dt>7.4. <a href="#id2512601">An Ewl Dialog</a></dt><dt>7.5. <a href="#id2513072">An EWL entry box</a></dt><dt>7.6. <a href="#id2513242">An EWL file dialog</a></dt><dt>7.7. <a href="#id2513473">An EWL Notebook</a></dt><dt>7.8. <a href="#id2513543">An EWL password dialog</a></dt><dt>7.9. <a href="#id2513678">An EWL progress bar</a></dt><dt>7.10. <a href="#id2513730">An EWL radiobutton</a></dt><dt>7.11. <a href="#id2513801">An EWL seeker</a></dt><dt>7.12. <a href="#id2513893">An EWL spinner</a></dt><dt>7.13. <a href="#id2514258">An EWL tooltip</a></dt><dt>7.14. <a href="#id2514341">An EWL media object</a></dt><dt>7.15. <a href="#id2514583">An EWL Window</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>3.1. <a href="#id2511040">Creating EWL Widgets</a></dt><dt>7.1. <a href="#id2511295">Creating EWL boxes</a></dt><dt>7.2. <a href="#sec-EwlButtonCode">Creating a button</a></dt><dt>7.3. <a href="#sec-EwlButtonCB">Button Callback</a></dt><dt>7.4. <a href="#sec-EwlCheckButtonCode">Creating a checkbutton</a></dt><dt>7.5. <a href="#sec-EwlCheckButtonCB">Button Callback</a></dt><dt>7.6. <a href="#sec-EwlComboCode">Creating a combo box</a></dt><dt>7.7. <a href="#sec-EwlComboCodeCB">combo box value changed callback</a></dt><dt>7.8. <a href="#sec-EwlDialogCode">EWL Dialog code</a></dt><dt>7.9. <a href="#sec-EwlDialogCB">EWL Dialog callback</a></dt><dt>7.10. <a href="#id2513104">Creating an EWL entry box</a></dt><dt>7.11. <a href="#id2513154">Ewl_Entry value changed callback</a></dt><dt>7.12. <a href="#id2513277">Creating an EWL filedialog</a></dt><dt>7.13. <a href="#id2513353">Ewl_Filedialog open callback</a></dt><dt>7.14. <a href="#id2513411">Ewl_Image</a></dt><dt>7.15. <a href="#id2513575">Creating an EWL password</a></dt><dt>7.16. <a href="#id2513640">Ewl_Password value changed callback</a></dt><dt>7.17. <a href="#id2513833">Creating an EWL seeker</a></dt><dt>7.18. <a href="#id2513856">Ewl_Seeker callback</a></dt><dt>7.19. <a href="#sec-EwlTextCode">Ewl_Text code</a></dt><dt>7.20. <a href="#sec-EwlMediaCode">Ewl_Media code</a></dt><dt>7.21. <a href="#id2514420">Ewl_Media callbacks</a></dt><dt>7.22. <a href="#sec-EwlWindowCode">Creating a Window</a></dt><dt>7.23. <a href="#sec-EwlWindowDestroyCb">Ewl Window destroy callback</a></dt><dt>A.1. <a href="#id2517181">Ewl Media Player</a></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-Intro"></a>Chapter 1. Introduction</h2></div></div><div></div></div><p>
The EWL (Enlightened Widget Library) is a library for creating
graphical user interfaces based upon the EFL (Enlightenment Foundation Libraries).
</p><p>
 The primary author of EWL is:
</p><div class="itemizedlist"><ul type="disc" compact><li>Nathan 'RbdPngn' Ingersoll</li></ul></div><p>
EWL works in a similar fashion to other widget libraries, as it is 
based on a callback system. As elements are created and added to the 
interface, any desired event callbacks are registered, these functions
will be triggered when the specified event happens.
</p><p>
This tutorial is an attempt to familiarize the user with the different
aspects of the EWL system. The tutorial will probably never completely
document all aspects of EWL as the system continues to grow. A good
understanding of C programming is assumed throughout the tutorial.
</p><p>
If you have any troubles with either this tutoral, or using EWL
in general, any feedback is greatly appreciated as it would help improve either
the tutorial or EWL itself. Please see <a href="#ch-Contributing" title="Chapter 8. Contributing">Contributing</a>
section for more information.
</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-GettingStarted"></a>Chapter 2. Getting Started</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec-Installation">Getting EWL installed</a></span></dt><dt><span class="sect1"><a href="#sec-CreateWindow">Creating a simple Window</a></span></dt><dt><span class="sect1"><a href="#sec-HelloWorld">Hello World</a></span></dt><dt><span class="sect1"><a href="#sec-Callbacks">Callbacks</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-Installation"></a>Getting EWL installed</h2></div></div><div></div></div><p>
Before using EWL you need to have the libraries installed on your computer.
EWL can be retrieved from the Enlightenment CVS and directions on how this is done
can be found at: <tt class="literal"><a href="http://www.enlightenment.org/pages/source.html" target="_top"> 
http://www.enlightenment.org/pages/source.html </a></tt> along with detailed
installation directions.
</p><p>
You will need to install a lot of dependencies before being able to install
EWL, this is because it depends on many of the EFL libraries being present on the
system.
</p><p>
Once you have the other EFL libraries installed, installing EWL is as simple as:
</p><pre class="screen">
    ./configure;
    make;
    sudo make install;
</pre><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-CreateWindow"></a>Creating a simple Window</h2></div></div><div></div></div><p>
The first step in creating an EWL application is to get the main window
to be displayed on the screen.
</p><pre class="programlisting">
#include &lt;Ewl.h&gt;

void destroy_cb(Ewl_Widget *w, void *event, void *data) {
    ewl_widget_destroy(w);
    ewl_main_quit();
}

int main(int argc, char ** argv) {
    Ewl_Widget *win = NULL;

    if (!ewl_init(&amp;argc, argv)) {
        printf("Unable to init ewl\n");
        return 1;
    }

    win = ewl_window_new();
    ewl_window_title_set(EWL_WINDOW(win), "EWL Window");
    ewl_window_name_set(EWL_WINDOW(win), "EWL_WINDOW");
    ewl_window_class_set(EWL_WINDOW(win), "EWLWindow");
    ewl_object_size_request(EWL_OBJECT(win), 200, 100);
    ewl_callback_append(win, EWL_CALLBACK_DELETE_WINDOW, destroy_cb, NULL);
    ewl_widget_show(win);

    ewl_main();
    return 0;
}
</pre><p>This program can be compiled with a simple:
</p><pre class="screen">
zero@oberon [create_window] -&gt; gcc -o create_window main.c \
 `ewl-config --cflags --libs`
</pre><p>

And if executed should produce something similar to:
</p><p>
 <span class="inlinemediaobject"><img src="img/create_window.png" alt="Example of empty EWL window"></span>
</p><p>
Now that we know what we're making, lets go over the code in more detail.
</p><pre class="programlisting">
#include &lt;Ewl.h&gt;
</pre><p>
All EWL applications will start with the &lt;Ewl.h&gt; include. This will pull in all
of the other header files that EWL requires to function.
</p><pre class="programlisting">
void destroy_cb(Ewl_Widget *w, void *event, void *data) {
    ewl_widget_destroy(w);
    ewl_main_quit();
}
</pre><p>
The <tt class="function">destroy_cb</tt> will be used by EWL when the window 
manager requests the application terminate. Callbacks will be described
further in the <a href="#sec-Callbacks" title="Callbacks">Callbacks</a> section.
</p><p>
The <tt class="function">ewl_widget_destroy()</tt> is used to signal to EWL that we
no longer need the given widget, in this case the window, and for EWL to clean up the
resources used by that widget.
</p><p>
Finally, we call <tt class="function">ewl_main_quit()</tt> which causes EWL to exit
its main processing loop and return from the <tt class="function">ewl_main()</tt> function.
</p><pre class="programlisting">
int main(int argc, char ** argv) {
    Ewl_Widget *win = NULL;

    if (!ewl_init(&amp;argc, argv)) {
        printf("Unable to init ewl\n");
        return 1;
    }
</pre><p>
Before we can actually use EWL we must initialize the library. This is done through
the call to <tt class="function">ewl_init()</tt>. We pass the argc and argv parameters from main
to EWL as there are a few specific switches EWL parses from the arguments.
</p><p>These switches currently include:</p><div class="itemizedlist"><p class="title"><b>EWL command line switches</b></p><ul type="bullet" compact><li style="list-style-type: disc"><p>--ewl-theme &lt;name&gt;</p></li><li style="list-style-type: disc"><p>--ewl-segv</p></li><li style="list-style-type: disc"><p>--ewl-software-x11</p></li><li style="list-style-type: disc"><p>--ewl-gl-x11</p></li><li style="list-style-type: disc"><p>--ewl-fb</p></li></ul></div><p>
The &lt;name&gt; parameter to the --ewl-theme switch is the name of the theme you wish
to be used. This can be either located in one of the system directories, or in the
local directory.
</p><p>
If EWL was able to successfully initialize itself the call to <tt class="function">ewl_init()</tt>
will return a value &gt; 0. If it was unsuccessful there is no real point in continuing as
EWL will not function correctly.
</p><pre class="programlisting">
    win = ewl_window_new();
    ewl_window_title_set(EWL_WINDOW(win), "EWL Window");
    ewl_window_name_set(EWL_WINDOW(win), "EWL_WINDOW");
    ewl_window_class_set(EWL_WINDOW(win), "EWLWindow");
    ewl_object_size_request(EWL_OBJECT(win), 200, 100);
    ewl_callback_append(win, EWL_CALLBACK_DELETE_WINDOW, destroy_cb, NULL);
    ewl_widget_show(win);
</pre><p>
This is where the actual window is created. A call to <tt class="function">ewl_window_new()</tt>
creates the new, empty window. We then take that window and start attaching data. We begin
by setting the title with <tt class="function">ewl_window_title_set()</tt>, which will set
the string to be displayed by the window manager on the top of the window. The next two
function calls, <tt class="function">ewl_window_name_set()</tt> and 
<tt class="function">ewl_window_class_set()</tt> set data that will be used by the window manager
to better manage your application.
</p><p>
We then proceed to set the base size for the window with a call to 
<tt class="function">ewl_object_size_request()</tt>. The second and third parameters (200, 100)
specify the width and height we wish the window to have on creation. You'll notice that
this call casts to <tt class="literal">EWL_OBJECT()</tt>. This is because of the hierarchy of 
widgets that EWL provides, (further described in the <a href="#ch-OjbectHierarchy" title="Chapter 3. Object Hierarchy">
Object Hierarchy</a> chapter) an ewl_window is a ewl_object so we can use the
ewl_object operations on an ewl_window.
</p><p>
We then proceed to add the delete callback to the window with a call to
<tt class="function">ewl_callback_append</tt>. The second parameter of which is the
type of signal we wish to listen too, the third is the function to call and finally
the fourth is any user data to be sent to the callback.
</p><p>
Once the window is all set up and ready to go, a simple call to 
<tt class="function">ewl_widget_show()</tt> will have EWL display the window.
</p><pre class="programlisting">
    ewl_main();
    return 0;
}
</pre><p>
The call to <tt class="function">ewl_main()</tt> will tell EWL to start its main processing
loop waiting on any signals. <tt class="function">ewl_main()</tt> will handle the shutdown
of EWL when the main processing loop is exited.
</p><p>
That's it. Although it's probably one of the simplest EWL applications that can be produced,
it will be used as a basis for many of the other examples presented in this tutorial, and
many EWL applications that are produced.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-HelloWorld"></a>Hello World</h2></div></div><div></div></div><p>
Once you have a window on the screen its time to do something more fun with it. So, following
in the grand tradition, something with Hello in it.
</p><p>I am only going to explain the portions of the program which have not already been 
seen. If there is something you do not understand please reference the previous section
and it should be explained there.</p><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;Ewl.h&gt;

void destroy_cb(Ewl_Widget *w, void *event, void *data) {
    ewl_widget_destroy(w);
    ewl_main_quit();
}

void text_update_cb(Ewl_Widget *w, void *event, void *data) {
    char *s = NULL;
    Ewl_Widget *label = NULL;
    char buf[BUFSIZ];

    s = ewl_entry_get_text(EWL_ENTRY(w));
    label = (Ewl_Widget *)data;

    snprintf(buf, BUFSIZ, "Hello %s", s);
    ewl_text_text_set(EWL_TEXT(label), buf);

    free(s);
    return;
}

int main(int argc, char ** argv) {
    Ewl_Widget *win = NULL;
    Ewl_Widget *box = NULL;
    Ewl_Widget *label = NULL;
    Ewl_Widget *o = NULL;

    /* init the library */
    if (!ewl_init(&amp;argc, argv)) {
        printf("Unable to initialize EWL\n");
        return 1;
    }

    /* create the window */
    win = ewl_window_new();
    ewl_window_title_set(EWL_WINDOW(win), "Hello world");
    ewl_window_class_set(EWL_WINDOW(win), "hello");
    ewl_window_name_set(EWL_WINDOW(win), "hello");
    ewl_object_size_request(EWL_OBJECT(win), 200, 50);
    ewl_callback_append(win, EWL_CALLBACK_DELETE_WINDOW, destroy_cb, NULL);
    ewl_widget_show(win);

    /* create the container */
    box = ewl_vbox_new();
    ewl_container_child_append(EWL_CONTAINER(win), box);
    ewl_object_fill_policy_set(EWL_OBJECT(box), EWL_FLAG_FILL_ALL);
    ewl_widget_show(box);

    /* create text label */
    label = ewl_text_new(NULL);
    ewl_container_child_append(EWL_CONTAINER(box), label);
    ewl_object_alignment_set(EWL_OBJECT(label), EWL_FLAG_ALIGN_CENTER);
    ewl_text_style_set(EWL_TEXT(label), "soft_shadow");
    ewl_text_color_set(EWL_TEXT(label), 255, 0, 0, 255);
    ewl_text_text_set(EWL_TEXT(label), "hello");
    ewl_widget_show(label);

    /* create the entry */
    o = ewl_entry_new("");
    ewl_container_child_append(EWL_CONTAINER(box), o);
    ewl_object_alignment_set(EWL_OBJECT(o), EWL_FLAG_ALIGN_CENTER);
    ewl_object_padding_set(EWL_OBJECT(o), 5, 5, 5, 0);
    ewl_text_color_set(EWL_TEXT(EWL_ENTRY(o)-&gt;text), 0, 0, 0, 255);
    ewl_callback_append(o, EWL_CALLBACK_VALUE_CHANGED, text_update_cb, label);
    ewl_widget_show(o);

    ewl_main();
    return 0;
}
</pre><p>
If you compile and run this application, in the same fashion as the first example,
you should see something similar to the following window.
</p><p>
 <span class="inlinemediaobject"><img src="img/hello_world.png" alt="Simple Hello World application"></span>
</p><p>
This one's a bit longer than the simple creating of a window, but then it also includes
more functionality. If you run this program you should see a simple window with a bit
of text saying 'Hello' at the top and a text area. Typing in the text area and hitting
'Enter' will display 'Hello' plus whatever you've typed.
</p><p>
The 'Hello' string has had a bit of text styling applied. You can see that the text
has had a simple colour change applied and is displayed with a drop shadow.
</p><p>
Now that you know what it does, lets take a look at the new bits of code this
example introduce.
</p><pre class="programlisting">
void text_update_cb(Ewl_Widget *w, void *event, void *data) {
    char *s = NULL;
    Ewl_Widget *label = NULL;
    char buf[BUFSIZ];

    s = ewl_entry_get_text(EWL_ENTRY(w));
    label = (Ewl_Widget *)data;

    snprintf(buf, BUFSIZ, "Hello %s", s);
    ewl_text_text_set(EWL_TEXT(label), buf);

    free(s);
    return;
}
</pre><p>
The <tt class="function">text_update_cb()</tt> is the callback we are going to register
for when the user has pressed 'Enter' in the text field. It has the same signature
as the destroy callback, and all other EWL callbacks that we will be registering.
</p><p>
The text that has been entered is retrieved with a call to 
<tt class="function">ewl_entry_get_text()</tt> passing the entry widget from which
we want to retrieve the text. This will return a pointer to the text string, 
it is the applications responsibility to free this pointer.
</p><p>
We then cast the <tt class="literal">data</tt> parameter into a <tt class="literal">Ewl_Widget</tt>.
This is because, as you will see in the register callback, we are attaching a widget to
this callback as a data parameter.
</p><p>
We can then take this new text and replace the contents of the current text label
by calling <tt class="function">ewl_text_text_set()</tt> passing the text object and
the text to be displayed.
</p><pre class="programlisting">
    box = ewl_vbox_new();
    ewl_container_child_append(EWL_CONTAINER(win), box);
    ewl_object_fill_policy_set(EWL_OBJECT(box), EWL_FLAG_FILL_ALL);
    ewl_widget_show(box);
</pre><p>
While we could just attach any widgets onto the main application window, it is a bit
cleaner to attach the widgets into a box that is attached to the main window. The
box is created with a call to <tt class="function">ewl_vbox_new()</tt> creating a 
vertical box layout. We could have used <tt class="function">ewl_hbox_new()</tt>
if we desired a horizontal box instead of a vertical one. Once the box is created
we attach it to the window by calling <tt class="function">ewl_container_child_append()</tt>.
This places the given widget into the container as the next element. Containers are packed
from top to bottom, or left to right, so the order elements are inserted into the 
container effect there appearance on screen. Lastly, before showing the widget,
we attach a fill policy with <tt class="function">ewl_object_fill_policy_set()</tt>. The fill
policy changes the way the object fills in its available space.
</p><p>
The possible fill policies are:
</p><div class="itemizedlist"><p class="title"><b>EWL Fill Flags</b></p><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_FLAG_FILL_NONE</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_HSHRINK</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_VSHRINK</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_SHRINK</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_HFILL</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_VFILL</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_FILL</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_ALL</p></li></ul></div><p>
All of which should be pretty self explanatory, with the exceptions of, 
<tt class="literal">EWL_FLAG_FILL_SHRINK</tt>, <tt class="literal">EWL_FLAG_FILL_FILL</tt>
and <tt class="literal">EWL_FLAG_FILL_ALL</tt>. The SHRINK flag is the or of
the two HSHRINK and VSHRINK flags. The FILL flag is the or of the 
two HFILL and VFILL flags. Finally the ALL flag is the or of the
two SHRINK and FILL flags.
</p><pre class="programlisting">
    label = ewl_text_new(NULL);
    ewl_container_child_append(EWL_CONTAINER(box), label);
    ewl_object_alignment_set(EWL_OBJECT(label), EWL_FLAG_ALIGN_CENTER);
    ewl_text_style_set(EWL_TEXT(label), "soft_shadow");
    ewl_text_color_set(EWL_TEXT(label), 255, 0, 0, 255);
    ewl_text_text_set(EWL_TEXT(label), "Hello");
    ewl_widget_show(label);
</pre><p>
Now that we have our containing box set up, we create the actual text element
that is going to function as our label. The label is created with a
call to <tt class="function">ewl_text_new()</tt> in this case, we pass NULL as the value
because we will be specifying our text after we attach some styling to the object. 
You can also pass a text string into <tt class="function">ewl_text_new()</tt> if desired.
Just keep in mind that text styling happens for text that is added <span class="emphasis"><em>after</em></span>
the styling is attached.
</p><p>
Once the widget is created we attach it to the box
with <tt class="function">ewl_container_child_append()</tt>. Next we set
the alignment on the text object though <tt class="function">ewl_object_alignment_set()</tt>.
This specifies how the contents will be aligned within the widget itself.
</p><p>
The alignment function will accept one of:
</p><div class="itemizedlist"><p class="title"><b>EWL Alignment Flags</b></p><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_FLAG_FILL_CENTER</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_LEFT</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_RIGHT</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_TOP</p></li><li style="list-style-type: disc"><p>EWL_FLAG_FILL_BOTTOM</p></li></ul></div><p>
Once all the widget properties are specified, we attach some text formatting
properties to the widget. The first, <tt class="function">ewl_text_style_set()</tt>,
sets the style of the text object. The styles change the appearance of the text
by applying some kind of filter, in this case, creating a 'soft shadow' appearance
to the widget. We then set the colour of the text to red by calling 
<tt class="function">ewl_text_color_set()</tt>. There are four parameters to the colour
function, those being, red, green, blue and alpha.
</p><pre class="programlisting">
    o = ewl_entry_new("");
    ewl_container_child_append(EWL_CONTAINER(box), o);
    ewl_object_alignment_set(EWL_OBJECT(o), EWL_FLAG_ALIGN_CENTER);
    ewl_object_padding_set(EWL_OBJECT(o), 5, 5, 5, 0);
    ewl_text_color_set(EWL_TEXT(EWL_ENTRY(o)-&gt;text), 0, 0, 0, 255);
    ewl_callback_append(o, EWL_CALLBACK_VALUE_CHANGED, text_update_cb, label);
    ewl_widget_show(o);
</pre><p>
The final widget we create is a text entry box. This is done with a call to 
<tt class="function">ewl_entry_new()</tt>. In this case we are giving ""
as the value, but an initial string could be given to be displayed in the entry box.
We do a similar set of initializations to the entry box, setting the alignment and
setting the text colour to black. The call to <tt class="function">ewl_object_padding_set()</tt>
sets the amount of padding around the widget. The four parameters are, left, right,
top and bottom.
</p><p>
With that you should have a basic understanding of how EWL functions and how different
widgets are created and setup.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-Callbacks"></a>Callbacks</h2></div></div><div></div></div><p>
The EWL is powered through the use of callbacks. A large amount of the internal work
of the library itself also works on callbacks.
</p><p>
A callback is a function that will be called when a specific event happens. These events
can be anything from the user clicking a button to the window being destroyed by the
window manager.
</p><p>
For the events that an application needs notification a callback is registered
through EWL. This is done with the <tt class="function">ewl_callback_append()</tt>. This
function takes four parameters: the object to attach the callback too, the callback
desired, the callback function and any user data.
</p><p>
Some of the possible callbacks include:
</p><div class="variablelist"><p class="title"><b>Possible EWL Callbacks</b></p><dl><dt><span class="term">EWL_CALLBACK_DESTROY</span></dt><dd><p>The widget is freed</p></dd><dt><span class="term">EWL_CALLBACK_DELETE_WINDOW</span></dt><dd><p>The window is being closed</p></dd><dt><span class="term">EWL_CALLBACK_KEY_DOWN</span></dt><dd><p>A key was pressed down</p></dd><dt><span class="term">EWL_CALLBACK_KEY_UP</span></dt><dd><p>A key was released</p></dd><dt><span class="term">EWL_CALLBACK_MOUSE_DOWN</span></dt><dd><p>Mouse button was pressed down</p></dd><dt><span class="term">EWL_CALLBACK_MOUSE_UP</span></dt><dd><p>Mouse button was released</p></dd><dt><span class="term">EWL_CALLBACK_MOUSE_MOVE</span></dt><dd><p>Mouse was moved</p></dd><dt><span class="term">EWL_CALLBACK_MOUSE_WHEEL</span></dt><dd><p>Mouse wheel scrolled</p></dd><dt><span class="term">EWL_CALLBACK_FOCUS_IN</span></dt><dd><p>Mouse was placed over the widget</p></dd><dt><span class="term">EWL_CALLBACK_FOCUS_OUT</span></dt><dd><p>Mouse was moved away from the widget</p></dd><dt><span class="term">EWL_CALLBACK_SELECT</span></dt><dd><p>Widget was selected by mouse or key</p></dd><dt><span class="term">EWL_CALLBACK_DESELECT</span></dt><dd><p>Widget was deselected by mouse or key</p></dd><dt><span class="term">EWL_CALLBACK_CLICKED</span></dt><dd><p>Mouse was pressed and released on a widget</p></dd><dt><span class="term">EWL_CALLBACK_DOUBLE_CLICKED</span></dt><dd><p>Mouse was clicked twice quickly</p></dd><dt><span class="term">EWL_CALLBACK_HILITED</span></dt><dd><p>Mouse is over the widget</p></dd><dt><span class="term">EWL_CALLBACK_VALUE_CHANGED</span></dt><dd><p>Value in widget changed</p></dd></dl></div><p>
The callback function has a signature like 
<tt class="literal">void fcn(Ewl_Widget *, void *, void *)</tt>. The first parameter is the
widget that activated this callback. The second parameter is the event data and the
third parameter is the user attached data.
</p><p>
The event data is a type that relates to the callback itself. So, for example, when
the callback for <tt class="literal">EWL_CALLBACK_MOUSE_WHEEL</tt> is called the event
data will have a struct of type <tt class="literal">Ewl_Event_Mouse_Wheel</tt> and this
struct contains additional information about the event. In the wheel case, the
key modifiers, the mouse position and the direction of scroll.
</p><p>
The last parameter to the callback attach function is the user data. This allows you
to attach any data desired to be passed to the callback when it is executed. This
data will be provided to the callback in the form of its third parameter.
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-OjbectHierarchy"></a>Chapter 3. Object Hierarchy</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec-ObjHierIntro">Introduction</a></span></dt><dt><span class="sect1"><a href="#sec-ObjHierCasting">Object Casting</a></span></dt><dt><span class="sect1"><a href="#sec-ObjHierNewWidget">Adding new widgets</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-ObjHierIntro"></a>Introduction</h2></div></div><div></div></div><p>
The EWL widgets are setup in a hierarcy. The base widget that everything
extends from is the <tt class="literal">Ewl_Object</tt>. The
<tt class="literal">Ewl_Object</tt> provides all of the base functionality for
each widget including the sizing, alignment, fill policies, padding and
others. This is the main building block of the EWL. An application using EWL
will never need to allocate an <tt class="literal">Ewl_Object</tt>
</p><p>
Sitting just above the <tt class="literal">Ewl_Object</tt> is the
<tt class="literal">Ewl_Widget</tt>. Again, all widgets inheret from this object,
which in turn inherits from the <tt class="literal">Ewl_Object</tt>. This object
provides the base functinality for a widget to interact with users. Like
the <tt class="literal">Ewl_Object</tt> an application will never need to allocate
an <tt class="literal">Ewl_Widget</tt> itself.
</p><p>
With the <tt class="literal">Ewl_Widget</tt> in place we can start to build up the
hierarchy of widgets that form the EWL. The hierarchy looks something similar to
that in the <a href="#fig-obj_hierarchy" title="Figure 3.1. The EWL Object Hierarchy">EWL Object Hierarcy</a> figure below.
</p><p>
 </p><div class="figure"><a name="fig-obj_hierarchy"></a><p class="title"><b>Figure 3.1. The EWL Object Hierarchy</b></p><span class="inlinemediaobject"><img src="img/obj_hierarchy.png" alt="The EWL Object Hierarchy"></span></div><p>
</p><p>
The <tt class="literal">Ewl_Container</tt> object is built off of the
<tt class="literal">Ewl_Widget</tt> object and provides the functionality for
widgets that are to hold other widgets. This includes anything from the main
window, to boxes, to scrollpanes.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-ObjHierCasting"></a>Object Casting</h2></div></div><div></div></div><p>
As you progress into EWL you will notice that there is a lot of casting
between different types. To make this easier, each cast to a particular type
has a EWL_TYPE() macro defined. So for example there is are EWL_OBJECT(o) and
EWL_WIDGET(o) defined to make life easier.
</p><p>
These macros should always be used when converting between EWL widgets so
that you know that the right thing is being done.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-ObjHierNewWidget"></a>Adding new widgets</h2></div></div><div></div></div><p>
To add new widgets into EWL you just need to create a new struct that has
the appropriate type of subclass as the first element. This subclass object
must not be a pointer.
</p><div class="example"><a name="id2511040"></a><p class="title"><b>Example 3.1. Creating EWL Widgets</b></p><pre class="programlisting">
struct Ewl_Foo {
    Ewl_Container container;
    int bar;
}
 </pre></div><p>
This would create a new Ewl_Foo widget that inherits from the
<tt class="literal">Ewl_Container</tt> so you would be able to pack other widgets
into this new widget type.
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-WidgetPacking"></a>Chapter 4. Widget Packing</h2></div></div><div></div></div><p>
As you're writing an EWL application you will need to start laying out the
widgets into the different boxes. To do so, you'll need a bit of information
on how EWL packs widgets together.
</p><p>
There are two main orientations for containers in EWL, vertical or
horizontal. The different orientations can be most easily seen in 
<a href="#sec-EwlBox" title="ewl_hbox and ewl_vbox">the section called &#8220;ewl_hbox and ewl_vbox&#8221;</a>.
</p><p>
In EWL, each widget has an amount of padding around the widget and an inset
set into the widget. This is seen in the below in
<a href="#fig-padding_inset_diagram" title="Figure 4.1. Padding and Insets">Figure 4.1, &#8220;Padding and Insets&#8221;</a>.

 </p><div class="figure"><a name="fig-padding_inset_diagram"></a><p class="title"><b>Figure 4.1. Padding and Insets</b></p><span class="inlinemediaobject"><img src="img/padding_insets.png" alt="Diagram of padding and insets in EWL"></span></div><p>
</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-Config"></a>Chapter 5. Configuration</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2510713">EWL configuration</a></span></dt><dt><span class="sect1"><a href="#id2511659">Application configuration</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2510713"></a>EWL configuration</h2></div></div><div></div></div><p>
EWL uses the Ecore_Config system to handle all of its configuration data.
This makes the changing of values easy though the existing tools to work
with Ecore_Config.
</p><p>
The following are the current keys used by EWL with a brief description.
</p><div class="variablelist"><dl><dt><span class="term">/ewl/debug/enable</span></dt><dd><p>Enable debug mode</p></dd><dt><span class="term">/ewl/debug/level</span></dt><dd><p>Set the debug level [0 - 10]</p></dd><dt><span class="term">/ewl/evas/render_method</span></dt><dd><p>
    Set the method Evas will use to render the display. This can 
	be one of:
	 </p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>software_x11</p></li><li style="list-style-type: disc"><p>gl_x11</p></li><li style="list-style-type: disc"><p>fb</p></li></ul></div><p>
	 For X11 software, X11 OpenGL and Framebuffer display respectively.
   </p></dd><dt><span class="term">/ewl/evas/font_cache</span></dt><dd><p>The size of the Evas font cache</p></dd><dt><span class="term">/ewl/evas/image_cache</span></dt><dd><p>The size of the Evas image cache</p></dd><dt><span class="term">/ewl/theme/name</span></dt><dd><p>The name of the EWL theme to use (minus the .eet portion)</p></dd><dt><span class="term">/ewl/theme/cache</span></dt><dd><p>A boolean to indicate if theme values should be cached by EWL</p></dd><dt><span class="term">/ewl/theme/color_classes/override</span></dt><dd><p>Override the default colour classes</p></dd><dt><span class="term">/ewl/theme/color_classes/count</span></dt><dd><p>The number of colour classes that are overridden</p></dd><dt><span class="term">/ewl/theme/color_class/[n]/name</span></dt><dd><p>The name of the [n]th colour class</p></dd><dt><span class="term">/ewl/theme/color_class/[n][rgba]</span></dt><dd><p>A key for each of the r, g, b, a values of the colour class</p></dd></dl></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2511659"></a>Application configuration</h2></div></div><div></div></div><p>
The best way for an application to handle its specific configuration is to
also use Ecore_Config. Doing so is simple and already handles things like
defaults and callbacks for data changes.
</p><p>
As a safety precaution you should probably make a call to
<tt class="function">ecore_init()</tt> in your code before using the
Ecore_Config functions. This will guarantee that Ecore won't be shutdown
before you're finished using it. This means you will need to make a call to
<tt class="function">ecore_shutdown()</tt> when you're finished using
Ecore_Config.
</p><p>
Before you start using Ecore_Config you must make a call to <tt class="function">int
ecore_config_init(char *)</tt> where the parameter is the name you
want your configuration to appear under in Ecore_Config. This is also the
name that would be used with <span><b class="command">examine</b></span> to change your
configuration data. When you are finished using Ecore_Config you should call
<tt class="function">int ecore_config_shutdown(void)</tt> to close down the
Ecore_Config system.
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-Themes"></a>Chapter 6. EWL Themes</h2></div></div><div></div></div><p>
EWL uses the Edje library to handle off of its theming requirements. The
themes can either be defined in the configuration file or on the command
line using the <tt class="literal">--ewl-theme</tt> switch.
</p><p>
The use of Edje for the theming gives EWL a large amount of flexibility and
provides the themer with a lot of power to customize the look of EWL.
</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-Widgets"></a>Chapter 7. Widgets</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec-EwlBox">ewl_hbox and ewl_vbox</a></span></dt><dt><span class="sect1"><a href="#sec-EwlButton">ewl_button</a></span></dt><dt><span class="sect1"><a href="#sec-EwlCheckButton">ewl_checkbutton</a></span></dt><dt><span class="sect1"><a href="#sec-EwlCombo">ewl_combo</a></span></dt><dt><span class="sect1"><a href="#sec-EwlDialog">ewl_dialog</a></span></dt><dt><span class="sect1"><a href="#sec-EwlEntry">ewl_entry</a></span></dt><dt><span class="sect1"><a href="#sec-EwlFileDialog">ewl_filedialog</a></span></dt><dt><span class="sect1"><a href="#sec-EwlImage">ewl_image</a></span></dt><dt><span class="sect1"><a href="#sec-EwlMenu">ewl_menu</a></span></dt><dt><span class="sect1"><a href="#sec-EwlNotebook">ewl_notebook</a></span></dt><dt><span class="sect1"><a href="#sec-EwlPassword">ewl_password</a></span></dt><dt><span class="sect1"><a href="#sec-EwlProgressBar">ewl_progressbar</a></span></dt><dt><span class="sect1"><a href="#sec-Ewl-RadioButton">ewl_radiobutton</a></span></dt><dt><span class="sect1"><a href="#sec-EwlScrollpane">ewl_scrollpane</a></span></dt><dt><span class="sect1"><a href="#sec-EwlSeeker">ewl_seeker</a></span></dt><dt><span class="sect1"><a href="#sec-EwlSpinner">ewl_spinner</a></span></dt><dt><span class="sect1"><a href="#sec-EwlTable">ewl_table</a></span></dt><dt><span class="sect1"><a href="#sec-EwlText">ewl_text</a></span></dt><dt><span class="sect1"><a href="#sec-EwlTooltip">ewl_tooltip</a></span></dt><dt><span class="sect1"><a href="#sec-EwlTree">ewl_tree</a></span></dt><dt><span class="sect1"><a href="#sec-EwlMedia">ewl_media</a></span></dt><dt><span class="sect1"><a href="#sec-EwlWindow">ewl_window</a></span></dt></dl></div><p>
We will now look at each widget individually. See the code that creates the widget and a 
screen shot of the widget in action (if applicable). 
</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlBox"></a>ewl_hbox and ewl_vbox</h2></div></div><div></div></div><p>
The box widgets allow you to specify different ways in which the 
application will be laid out. You can create either a horizontal (hbox)
or vertical (vbox) box. A vertical box will have its children packed
from top to bottom while a horizontal box will have its widgets
packed from left to right.
</p><p>
A box widget will not show up in the application itself, it is just
used as a container for other widgets.
</p><p>
 </p><div class="example"><a name="id2511295"></a><p class="title"><b>Example 7.1. Creating EWL boxes</b></p><pre class="programlisting">
   Ewl_Widget *hbox = ewl_hbox_new();
   ewl_widget_show(hbox);

   Ewl_Widget *vbox = ewl_vbox_new();
   ewl_widget_show(vbox);
  </pre></div><p>
The box widgets are relativly simple to create and use, only requiring a call to the
new function.
</p><p>
The functions to manipulate the boxes include:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p><tt class="function">void ewl_box_orientation_set(Ewl_Box *, Ewl_Orientation)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">Ewl_Orientation ewl_box_orientation_get(Ewl_Box *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">void ewl_box_spacing_set(Ewl_Box *, int)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">void ewl_box_homogeneous_set(Ewl_Box *, int)</tt></p></li></ul></div><p>

The <tt class="literal">Ewl_Orientation</tt> flag can be one of:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_ORIENTATION_HORIZONTAL</p></li><li style="list-style-type: disc"><p>EWL_ORIENTATION_VERTICAL</p></li></ul></div><p>
</p><p>
The <tt class="function">ewl_box_spacing_set()</tt> will set the amount of spacing between the
items in the box to the given value. While the <tt class="function">ewl_box_homogeneous_set()</tt>
will set the box to give all items in it the same size if this is set to true, otherwise
they will have their required size.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlButton"></a>ewl_button</h2></div></div><div></div></div><p>
The button widget is simply a widget with a label attached. When the 
user clicks on the button the callback attached to 
<tt class="literal">EWL_CALLBACK_CLICKED</tt> will be executed.
</p><p>
 </p><div class="figure"><a name="id2512255"></a><p class="title"><b>Figure 7.1. An Ewl Button</b></p><span class="inlinemediaobject"><img src="img/entry.png" alt="Example of an EWL entry box"></span></div><p>
</p><p>
</p><div class="example"><a name="sec-EwlButtonCode"></a><p class="title"><b>Example 7.2. Creating a button</b></p><pre class="programlisting">
    Ewl_Widget *button = ewl_button_new("A button");
    ewl_object_alignment_set(EWL_OBJECT(button), EWL_FLAG_ALIGN_CENTER);
    ewl_callback_append(button, EWL_CALLBACK_CLICKED, button_cb, NULL);
    ewl_widget_show(button);
 </pre></div><p>
The label portion of the button can be aligned to any of the <tt class="literal">EWL_FLAG_ALIGN_*</tt>
settings.
</p><p>
</p><div class="example"><a name="sec-EwlButtonCB"></a><p class="title"><b>Example 7.3. Button Callback</b></p><pre class="programlisting">
void button_cb(Ewl_Widget *w, void *event, void *data) {
    printf("button pressed\n");
}
 </pre></div><p>
</p><p>
The label on a button can be manipulated after the button has been created through
the two calls:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p><tt class="function">char *ewl_button_label_get(EwlButton *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">void ewl_button_label_set(EwlButton *, char *)</tt></p></li></ul></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlCheckButton"></a>ewl_checkbutton</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2512389"></a><p class="title"><b>Figure 7.2. An Ewl Checkbutton</b></p><span class="inlinemediaobject"><img src="img/checkbutton.png" alt="Example of an EWL checkbutton"></span></div><p>
</p><p>
</p><div class="example"><a name="sec-EwlCheckButtonCode"></a><p class="title"><b>Example 7.4. Creating a checkbutton</b></p><pre class="programlisting">
    Ewl_Widget *cb = ewl_checkbutton_new("Label");
    ewl_checkbutton_label_position_set(EWL_CHECKBUTTON(cb), EWL_FLAG_ALIGN_LEFT);
    ewl_callback_append(cb, EWL_CALLBACK_VALUE_CHANGED, checkbutton_cb, NULL);
    ewl_widget_show(cb);
 </pre></div><p>
</p><p>
</p><div class="example"><a name="sec-EwlCheckButtonCB"></a><p class="title"><b>Example 7.5. Button Callback</b></p><pre class="programlisting">
void checkbutton_cb(Ewl_Widget *w, void *event, void *data) {
    if (ewl_checkbutton_is_checked(EWL_CHECKBUTTON(w)))
        printf("checked\n");
    else
        printf("Not checked\n");
}
 </pre></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlCombo"></a>ewl_combo</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2512489"></a><p class="title"><b>Figure 7.3. An Ewl Combo box</b></p><span class="inlinemediaobject"><img src="img/combo.png" alt="Example of an EWL combo box"></span></div><p>
</p><p>
</p><div class="example"><a name="sec-EwlComboCode"></a><p class="title"><b>Example 7.6. Creating a combo box</b></p><pre class="programlisting">
    Ewl_Widget *combo = ewl_combo_new("combo box");
    ewl_callback_append(combo, EWL_CALLBACK_VALUE_CHANGED, 
                                combo_change_cb, NULL);
    ewl_widget_show(combo);

    Ewl_widget *item1 = ewl_menu_item_new(NULL, "foo");
    ewl_container_child_append(EWL_CONTAINER(combo));
    ewl_widget_show(item1);
 </pre></div><p>
</p><p>
</p><div class="example"><a name="sec-EwlComboCodeCB"></a><p class="title"><b>Example 7.7. combo box value changed callback</b></p><pre class="programlisting">
void combo_change_cb(Ewl_Widget *w, void *event, void *data) {
    char *text = (char *)event;
    printf("Value changed to %s\n", text);
}
 </pre></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlDialog"></a>ewl_dialog</h2></div></div><div></div></div><p>
The <tt class="literal">Ewl_Dialog</tt> widget provides a way to display a simple
dialog box to the user which can then prompt for a response, give warnings
or just display simple messages.
</p><p>
 </p><div class="figure"><a name="id2512601"></a><p class="title"><b>Figure 7.4. An Ewl Dialog</b></p><span class="inlinemediaobject"><img src="img/dialog_box.png" alt="Example of an EWL dialog box"></span></div><p>
</p><p>
</p><div class="example"><a name="sec-EwlDialogCode"></a><p class="title"><b>Example 7.8. EWL Dialog code</b></p><pre class="programlisting">
    Ewl_Widget *dialog = NULL;
    Ewl_Widget *o = NULL;

    o = ewl_text_new("a dialog eh");
    ewl_object_alignment_set(EWL_OBJECT(o),
    EWL_FLAG_ALIGN_CENTER);
    ewl_widget_show(o);

    dialog = ewl_dialog_new(EWL_POSITION_BOTTOM);
    ewl_dialog_set_has_separator(EWL_DIALOG(dialog), 0);
    ewl_dialog_add_widget(EWL_DIALOG(dialog), o);
    ewl_object_alignment_set(EWL_OBJECT(dialog), EWL_FLAG_ALIGN_CENTER);
    ewl_widget_show(dialog);

    o = ewl_dialog_set_button(EWL_STOCK_OK, EWL_RESPONSE_OK);
    ewl_container_child_append(EWL_CONTAINER(dialog), o);
    ewl_callback_append(o, EWL_CALLBACK_CLICKED, dialog_clicked_cb, dialog);
    ewl_widget_show(o);

    o = ewl_dialog_set_button(EWL_STOCK_CANCEL, EWL_RESPONSE_CANCEL);
    ewl_container_child_append(EWL_CONTAINER(dialog), o);
    ewl_callback_append(o, EWL_CALLBACK_CLICKED, dialog_clicked_cb, dialog);
    ewl_widget_show(o);
</pre></div><p>
This example will create an <tt class="literal">Ewl_Dialog</tt> with two buttons:
an OK button and a Cancel button. The dialog itself is created with the
call to <tt class="function">ewl_dialog_new()</tt> passing the position of the
buttons relative to the window itself. The possible values are:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_POSITION_TOP</p></li><li style="list-style-type: disc"><p>EWL_POSITION_BOTTOM</p></li><li style="list-style-type: disc"><p>EWL_POSITION_LEFT</p></li><li style="list-style-type: disc"><p>EWL_POSITION_RIGHT</p></li></ul></div><p> 
</p><p>
A <tt class="literal">Ewl_Dialog</tt> can optionally have a horizontal line drawn
to seperate the two sections of the dialog. The line is controlled with the
<tt class="function">ewl_dialog_set_has_separator()</tt> where 0 means do not
draw separator and 1 means to draw the separator. There is a corresponding
<tt class="function">ewl_dialog_get_has_separator()</tt> returning 1 if there is
a separator and 0 otherwise.
</p><p>
The content of the main display area of the box is controlled through the
function <tt class="function">ewl_dialog_add_widget()</tt>. In this instance we
add a <tt class="literal">Ewl_Text</tt> object into the dialog.
</p><p>
Once the dialog is initialized we need to create any desired buttons. The
buttons are created by calling <tt class="function">ewl_dialog_set_button()</tt>
this will create a button. The parameters are the label of the button and
the response code to return from the button. There are several pre-defined
labels, including:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_STOCK_OK</p></li><li style="list-style-type: disc"><p>EWL_STOCK_APPLY</p></li><li style="list-style-type: disc"><p>EWL_STOCK_CANCEL</p></li><li style="list-style-type: disc"><p>EWL_STOCK_OPEN</p></li><li style="list-style-type: disc"><p>EWL_STOCK_SAVE</p></li><li style="list-style-type: disc"><p>EWL_STOCK_PAUSE</p></li><li style="list-style-type: disc"><p>EWL_STOCK_PLAY</p></li><li style="list-style-type: disc"><p>EWL_STOCK_STOP</p></li></ul></div><p>
The pre-defined response codes are:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_RESPONSE_OPEN</p></li><li style="list-style-type: disc"><p>EWL_RESPONSE_SAVE</p></li><li style="list-style-type: disc"><p>EWL_RESPONSE_OK</p></li><li style="list-style-type: disc"><p>EWL_RESPONSE_CANCEL</p></li><li style="list-style-type: disc"><p>EWL_RESPONSE_APPLY</p></li><li style="list-style-type: disc"><p>EWL_RESPONSE_PLAY</p></li><li style="list-style-type: disc"><p>EWL_RESPONSE_PAUSE</p></li><li style="list-style-type: disc"><p>EWL_RESPONSE_STOP</p></li></ul></div><p>
Once the buttons are created they need to be added to the dialog and have a
callback append for there <tt class="literal">EWL_CALLBACK_CLICKED</tt> state.
</p><p>
</p><div class="example"><a name="sec-EwlDialogCB"></a><p class="title"><b>Example 7.9. EWL Dialog callback</b></p><pre class="programlisting">
void dialog_clicked_cb(Ewl_Widget *w, void *event, void *data) {
    int d = EWL_BUTTON_STOCK(w)-&gt;response_id;

    if (d == EWL_RESPONSE_OK)
        printf("OK\n");
    else if (d == EWL_RESPONSE_CANCEL)
        printf("CANCEL\n");

    ewl_widget_destroy(EWL_WIDGET(data));
}
</pre></div><p>
The response code of the button that was clicked is available from the
<tt class="literal">Ewl_Button_Stock</tt> widget itself through its response_id
parameter. Using this value we can determine which of the buttons was
clicked. We also passed the <tt class="literal">Ewl_Dialog</tt> itself through the
data parameter so that we could destroy the dialog when we were finished.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlEntry"></a>ewl_entry</h2></div></div><div></div></div><p>
The EWL entry box is available when you need to retrieve text input from the user.
The box works on single lines, and the callback is triggered when the user presses
the 'Enter' key.
</p><p>
 </p><div class="figure"><a name="id2513072"></a><p class="title"><b>Figure 7.5. An EWL entry box</b></p><span class="inlinemediaobject"><img src="img/entry.png" alt="Example of an EWL entry box"></span></div><p>
</p><p>
 </p><div class="example"><a name="id2513104"></a><p class="title"><b>Example 7.10. Creating an EWL entry box</b></p><pre class="programlisting">
   Ewl_Widget *entry = ewl_entry_new();
   ewl_object_size_request(EWL_OBJECT(entry), 100, 15);
   ewl_object_padding_set(EWL_OBJECT(entry), 1, 1, 1, 1);
   ewl_callback_append(entry, EWL_CALLBACK_VALUE_CHANGED, entry_cb, NULL);
   ewl_widget_show(entry);
  </pre></div><p> 
The <tt class="literal">Ewl_Entry</tt> is a fairly simple object to work with, about the
only required setup is to create the new object and attach a callback for
<tt class="literal">EWL_CALLBACK_VALUE_CHANGED</tt> events. This example takes the 
extra steps of setting the size with <tt class="function">ewl_object_size_request()</tt>
and adding a little bit of padding to the widget with 
<tt class="function">ewl_object_padding_set()</tt>.
</p><p>
 </p><div class="example"><a name="id2513154"></a><p class="title"><b>Example 7.11. Ewl_Entry value changed callback</b></p><pre class="programlisting">
void entry_cb(Ewl_Widget *w, void *event, void *data) {
    char *s = ewl_entry_get_text(EWL_ENTRY(w));
    printf("%s\n", s);

    ewl_entry_set_text(EWL_ENTRY(w), "New Text");
}
  </pre></div><p>
This callback grabs the current value of the entry widget with the call to
<tt class="function">ewl_entry_get_text()</tt> and then resets the text to the 
value of 'New Text' by calling <tt class="function">ewl_entry_set_text()</tt>.
</p><p>
The <tt class="literal">Ewl_Entry</tt> object allows you to set whether or not the
text is editable with a call to 
<tt class="function">void ewl_entry_set_editable(Ewl_Entry *, unsigned int edit)</tt>
where <tt class="literal">edit</tt> is 0 for uneditable and editable otherwise.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlFileDialog"></a>ewl_filedialog</h2></div></div><div></div></div><p>
It is often desired to allow the user to open and save files. This can
be easily accomplished through the use of the <tt class="literal">Ewl_Filedialog</tt>.
</p><p>
 </p><div class="figure"><a name="id2513242"></a><p class="title"><b>Figure 7.6. An EWL file dialog</b></p><span class="inlinemediaobject"><img src="img/file_dialog.png" alt="Example of an EWL file dialog"></span></div><p>
This file dialog has been embedded into its own window, but it could have been
placed in another window in the same fashion.
</p><p>
 </p><div class="example"><a name="id2513277"></a><p class="title"><b>Example 7.12. Creating an EWL filedialog</b></p><pre class="programlisting">
   Ewl_Widget *filedialog = ewl_filedialog_new(EWL_FILEDIALOG_TYPE_OPEN);
   ewl_callback_append(filedialog, EWL_CALLBACK_VALUE_CHANGED, 
                            open_file_cb, NULL);
   ewl_widget_show(filedialog);
  </pre></div><p>
When the file dialog is created you specify a type either 
<tt class="literal">EWL_FILDIALOG_TYPE_OPEN</tt> or <tt class="literal">EWL_FILEDIALOG_TYPE_SAVE</tt>
depending on the type of file dialog desired. The callback 
<tt class="literal">EWL_CALLBACK_VALUE_CHANGED</tt> will be executed when the user clicks
the 'Open' button in the dialog.
</p><p>
It is also possible to pack other widgets into the filedialog itself. This is done through
the normal <tt class="function">ewl_container_child_append()</tt>. So, if you 
needed, for example, to add a 'Home' button, you could create the button and pack it 
into the file dialog where it will appear down the left side.
</p><p>
You can change the directory that is currently being viewed in the file dialog by
executing <tt class="function">void ewl_filedialog_set_directory(Ewl_Filedialog *, char *path)</tt>
where <tt class="literal">path</tt> is the full path to the desired directory.
</p><p>
 </p><div class="example"><a name="id2513353"></a><p class="title"><b>Example 7.13. Ewl_Filedialog open callback</b></p><pre class="programlisting">
void open_file_cb(Ewl_Widget *w, void *event, void *data) {
    char *filename = (char *)event;
    printf("selected file %s\n", filename);
}
  </pre></div><p>
The file that has been selected is passed to the callback as the <tt class="literal">event</tt>
parameter. If you wish to remove the filedialog you can do something similar to 
<tt class="literal">ewl_widget_hide(fd_win)</tt> where <tt class="literal">fd_win</tt> is the window
object holding the file dialog.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlImage"></a>ewl_image</h2></div></div><div></div></div><p>
</p><div class="example"><a name="id2513411"></a><p class="title"><b>Example 7.14. Ewl_Image</b></p><pre class="programlisting">
    Ewl_Widget *i = ewl_image_new("/usr/foo/img.png", NULL);
    ewl_widget_show(i);
</pre></div><p>
The <tt class="function">ewl_image_new()</tt> function takes two parameters, the
path to the image to be loaded and a key for the image data. The key is used
primarily to load edje groups or keyed data as the image.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlMenu"></a>ewl_menu</h2></div></div><div></div></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlNotebook"></a>ewl_notebook</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2513473"></a><p class="title"><b>Figure 7.7. An EWL Notebook</b></p><span class="inlinemediaobject"><img src="img/notebook.png" alt="Example of an EWL Notebook"></span></div><p>
</p><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlPassword"></a>ewl_password</h2></div></div><div></div></div><p>
The <tt class="literal">Ewl_Password</tt> widget provides similar functionality to
the <tt class="literal">Ewl_Text</tt> widget, except that any text entered will
not be displayed, instead a configurable obscuring character will be
displayed.
</p><p>
 </p><div class="figure"><a name="id2513543"></a><p class="title"><b>Figure 7.8. An EWL password dialog</b></p><span class="inlinemediaobject"><img src="img/passwd.png" alt="Example of an EWL password dialog"></span></div><p>
</p><p>
</p><div class="example"><a name="id2513575"></a><p class="title"><b>Example 7.15. Creating an EWL password</b></p><pre class="programlisting">
    Ewl_Widget *p = ewl_password_new("default");
    ewl_password_set_obscure(EWL_PASSWORD(p), "-");
    ewl_callback_append(p, EWL_CALLBACK_VALUE_CHANGED, passwd_cb, NULL);
    ewl_widget_show(p);
</pre></div><p>
The default obscuring character used is a '*' character. This can be easily
changed by calling 
<tt class="function">ewl_password_set_obscure(Ewl_Password *, char)</tt>.
There is also a corresponding 
<tt class="function">char ewl_password_get_obscure(Ewl_Password *)</tt> to
retrieve the current obscuring character. As with the
<tt class="literal">ewl_text</tt> widget there are two functions to get and set
the text of the widget: 
<tt class="function">ewl_password_set_text(Ewl_Password *, char *)</tt> and
<tt class="function">char *ewl_password_get_text(Ewl_Password *)</tt>.
</p><p>
When the user presses the enter key in the password box a
<tt class="literal">EWL_CALLBACK_VALUE_CHANGED</tt> will be triggered.
</p><div class="example"><a name="id2513640"></a><p class="title"><b>Example 7.16. Ewl_Password value changed callback</b></p><pre class="programlisting">
void passwd_cb(Ewl_Widget *, void *event, void *data) {
    char *text = ewl_password_get_text(EWL_PASSWORD(w));
    printf("text: %s\n", text);
}
</pre></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlProgressBar"></a>ewl_progressbar</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2513678"></a><p class="title"><b>Figure 7.9. An EWL progress bar</b></p><span class="inlinemediaobject"><img src="img/progressbar.png" alt="Example of an EWL progress bar"></span></div><p>
</p><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-Ewl-RadioButton"></a>ewl_radiobutton</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2513730"></a><p class="title"><b>Figure 7.10. An EWL radiobutton</b></p><span class="inlinemediaobject"><img src="img/radiobutton.png" alt="Example of an EWL radiobutton"></span></div><p>
</p><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlScrollpane"></a>ewl_scrollpane</h2></div></div><div></div></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlSeeker"></a>ewl_seeker</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2513801"></a><p class="title"><b>Figure 7.11. An EWL seeker</b></p><span class="inlinemediaobject"><img src="img/seeker.png" alt="Example of an EWL seeker"></span></div><p>
</p><p>
</p><div class="example"><a name="id2513833"></a><p class="title"><b>Example 7.17. Creating an EWL seeker</b></p><pre class="programlisting">
    Ewl_Widget *s = ewl_seeker_new(EWL_ORIENTATION_HORIZONTAL);
    ewl_seeker_value_set(EWL_SEEKER(s), 5.0);
    ewl_seeker_range_set(EWL_SEEKER(s), 10.0);
    ewl_seeker_step_set(EWL_SEEKER(s), 1);
    ewl_callback_append(s, EWL_CALLBACK_VALUE_CHANGED, seeker_cb, NULL);
    ewl_widget_show(s);
</pre></div><p>
</p><p>
</p><div class="example"><a name="id2513856"></a><p class="title"><b>Example 7.18. Ewl_Seeker callback</b></p><pre class="programlisting">
void seeker_cb(Ewl_Widget *w, void *event, void *data) {
    double val = ewl_seeker_value_get(EWL_SEEKER(w));
    printf("%f\n", val);
}
</pre></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlSpinner"></a>ewl_spinner</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2513893"></a><p class="title"><b>Figure 7.12. An EWL spinner</b></p><span class="inlinemediaobject"><img src="img/spinner.png" alt="Example of an EWL spinner"></span></div><p>
</p><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlTable"></a>ewl_table</h2></div></div><div></div></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlText"></a>ewl_text</h2></div></div><div></div></div><p>
The <tt class="literal">Ewl_Text</tt> widget provides for a multi-line text layout
widget. It can be utillized whenever the display of text is required in an
application. It works well with the <tt class="literal">Ewl_Scrollpane</tt> to
provide a scrollable text area.
</p><p>
</p><div class="example"><a name="sec-EwlTextCode"></a><p class="title"><b>Example 7.19. Ewl_Text code</b></p><pre class="programlisting">
    Ewl_Widget *text = ewl_text_new("text");
    ewl_widget_show(text);
</pre></div><p>
Creating the basic <tt class="literal">Ewl_Text</tt> object is pretty simple, the
object will be setup to diplay the parameter to
<tt class="function">ewl_text_new()</tt>.
</p><p>
Once the text object is created you can change the text, retrieve the
current text contents or get the text length with:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p><tt class="function">ewl_text_text_set(Ewl_Text *, char *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">ewl_text_text_prepend(Ewl_Text *, char *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">ewl_text_text_append(Ewl_Text *, char *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">ewl_text_text_insert(Ewl_Text *, char *, int index)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">char *ewl_text_text_get(Ewl_Text *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">int ewl_text_length_get(Ewl_Text *)</tt></p></li></ul></div><p>
</p><p>
The <tt class="literal">Ewl_Text</tt> widget allows you to preform styling changes
to the text in the widget. Different portions of the text can be different
colours, fonts or styles. The styling that is applied to a widget is based
on what is setup when the text is added to the widget. So, if you want your
text to be red, you need to set the colour of the
<tt class="literal">Ewl_Text</tt> object <span class="emphasis"><em>before</em></span> adding the
text.
</p><p>
The colour of the text can be manipulated with the
<tt class="function">ewl_text_color_set(Ewl_Text *, int r, int g, int b, int a)</tt>
call while the current colour information can be retrieved with the
<tt class="function">ewl_text_color_get(Ewl_Text *, int *r, int *g, int *b, int *a)</tt>.
</p><p>
The font settings of the text can be manipulated with the
<tt class="function">ewl_text_font_set(Ewl_Text *, char *font, int size)</tt>
call. With the calls to get the current font name as size defined as:
<tt class="function">char *ewl_text_font_get(Ewl_Text *)</tt> and
<tt class="function">int ewl_text_font_size_get(Ewl_Text *)</tt>.
</p><p>
To retrieve or set the alignment of the text widget there are the two
functions: <tt class="function">ewl_text_align_set(Ewl_Text *, unsigned int align)</tt>
and <tt class="function">unsigned int ewl_text_align_get(Ewl_Text *)</tt>. Where
the align parameter is one of the EWL alignment flags:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_CENTER</p></li><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_LEFT</p></li><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_RIGHT</p></li><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_TOP</p></li><li style="list-style-type: disc"><p>EWL_FLAG_ALIGN_BOTTOM</p></li></ul></div><p>
</p><p>
It is also possible to set the style of the text. This can include things
such as bolding the text or setting soft shadows. The styles that are
available are shipped through the Etox library and currently include:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p>bold</p></li><li style="list-style-type: disc"><p>outline</p></li><li style="list-style-type: disc"><p>plain</p></li><li style="list-style-type: disc"><p>raised</p></li><li style="list-style-type: disc"><p>shadow</p></li><li style="list-style-type: disc"><p>soft_shadow</p></li></ul></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlTooltip"></a>ewl_tooltip</h2></div></div><div></div></div><p>
 </p><div class="figure"><a name="id2514258"></a><p class="title"><b>Figure 7.13. An EWL tooltip</b></p><span class="inlinemediaobject"><img src="img/tooltip.png" alt="Example of an EWL tooltip"></span></div><p>
</p><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlTree"></a>ewl_tree</h2></div></div><div></div></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlMedia"></a>ewl_media</h2></div></div><div></div></div><p>
The <tt class="literal">Ewl_Media</tt> widget allows for the embedding of video
objects into your application. This is done by wrapping around the Emotion
library.
</p><p>
 </p><div class="figure"><a name="id2514341"></a><p class="title"><b>Figure 7.14. An EWL media object</b></p><span class="inlinemediaobject"><img src="img/ewl_media.png" alt="Example of an EWL Media object"></span></div><p>
</p><p>
</p><div class="example"><a name="sec-EwlMediaCode"></a><p class="title"><b>Example 7.20. Ewl_Media code</b></p><pre class="programlisting">
    Ewl_Media *m = ewl_media_new(file);
    ewl_callback_append(m, EWL_CALLBACK_REALIZE, video_realize_cb, NULL);
    ewl_callback_append(m, EWL_CALLBACK_VALUE_CHANGED, video_change_cb, NULL);
    ewl_widget_show(m);
</pre></div><p>
Creating the basic video object is no harder then creating the object and
showing it (assuming you've appended it to whatever container it is being
placed into). We hook the two callbacks
<tt class="literal">EWL_CALLBACK_REALIZE</tt> and
<tt class="literal">EWL_CALLBACK_VALUE_CHANGED</tt>. We hook in the realize
callback so we can determine the length of the video to be displayed if
desired. This is only available after the video has been realized, and will
return 0 until it has been realized. The value change callback will be
called whenever emotion advances the video. This can be used to setup a
timer, or a seek bar and have it auto advance for the video.
</p><p>
</p><div class="example"><a name="id2514420"></a><p class="title"><b>Example 7.21. Ewl_Media callbacks</b></p><pre class="programlisting">
void video_realize_cb(Ewl_Widget *w, void *event, void *data) {
    double len = ewl_media_length_get(EWL_MEDIA(video));
}   

void video_change_cb(Ewl_Widget *w, void *event, void *data) {
    char buf[512];
    int h, m;
    double s;
                
    ewl_media_position_time_get(EWL_MEDIA(video), &amp;h, &amp;m, &amp;s);
    snprintf(buf, sizeof(buf), "%02i:%02i:%02.0f", h, m, s);
}
 </pre></div><p>
</p><p>
The video that is being displayed can be changed by calling
<tt class="function">ewl_media_media_set(Ewl_Media *, char *)</tt> or if you just
wish to know what is currently playing you can call
<tt class="function">char *ewl_media_media_get(Ewl_Media *)</tt>. The length of
the current video can be retrieved by calling <tt class="function">int
ewl_media_length_get(Ewl_Media *)</tt>. The length can also be
retrieved as a time value by calling
<tt class="function">ewl_media_length_time_get(Ewl_Media *, int h, int m, double s)</tt>.
</p><p>
You can start the video playing by passing 1 to
<tt class="function">ewl_media_play_set(Ewl_Media *, int)</tt> or stop the video
by passing 0 to the same function.
</p><p>
To determine if the video codec allows for seeking in the video you can call
<tt class="function">int ewl_media_seekable_get(Ewl_Media *)</tt> which will
return 1 if the video is seekable, 0 otherwise.
<tt class="function">double ewl_media_position_get(Ewl_Media *)</tt> is used to determine
the current position in the video, while
<tt class="function">ewl_media_position_set(Ewl_Media *, double position)</tt>
can be used to set the position in the video. This value can also be
retrieved as a hours, minutes and seconds by calling
<tt class="function">ewl_media_position_time_get(Ewl_Media *, int h, int m, double s)</tt>.
</p><p>
If you wish to change the audio settings of the video there are several
functions available. These including the ability to get/set the current mute
settings: <tt class="function">int ewl_media_audio_mute_get(Ewl_Media *)</tt> and
<tt class="function">ewl_media_audio_mute_set(Ewl_Media *, int)</tt>. You can
also get/set the volume of the video through the calls:
<tt class="function">int ewl_media_audio_volume_get(Ewl_Media *)</tt> and
<tt class="function">ewl_media_audio_volume_set(Ewl_Media *, int)</tt>.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-EwlWindow"></a>ewl_window</h2></div></div><div></div></div><p>
An ewl_window will be used by every EWL application. This is the window that
will display all of the other desired EWL widgets.
</p><p>
 </p><div class="figure"><a name="id2514583"></a><p class="title"><b>Figure 7.15. An EWL Window</b></p><span class="inlinemediaobject"><img src="img/create_window.png" alt="Example of an EWL window"></span></div><p>
</p><p>
 </p><div class="example"><a name="sec-EwlWindowCode"></a><p class="title"><b>Example 7.22. Creating a Window</b></p><pre class="programlisting">
    Ewl_Widget *window = ewl_window_new();
    ewl_window_title_set(EWL_WINDOW(window), "foo window");
    ewl_window_class_set(EWL_WINDOW(window), "foo_class");
    ewl_window_name_set(EWL_WINDOW(window), "foo_name");
    ewl_object_size_request(EWL_OBJECT(window), 300, 400);
    ewl_callback_append(window, EWL_CALLBACK_DELETE_WINDOW, win_del_cb, NULL);
    ewl_widget_show(window);
  </pre></div><p>
Setting up the basic window is pretty simple. We take the extra steps of
calling: <tt class="function">ewl_window_title_set()</tt>, 
<tt class="function">ewl_window_name_set()</tt> and <tt class="function">ewl_window_class_set()</tt>
to fill in the information the window manager uses.
</p><p>
Since the window is a <tt class="literal">Ewl_Object</tt> like any other, we use the
<tt class="function">ewl_object_size_request()</tt> to request the starting size of
our window. We could have also called <tt class="function">ewl_object_minimum_size_set()</tt>
and <tt class="function">ewl_object_maximum_size_set()</tt> to constrain the 
minimum/maximum sizes of our window.
</p><p>
The main callback used by a Ewl_Window is the <tt class="literal">EWL_CALLBACK_DELETE_WINDOW</tt>.
This will be called when the window is being destroyed by the 
window manager. It should be used to cleanup any resources that the application has
used before exiting the application.
</p><p>
 </p><div class="example"><a name="sec-EwlWindowDestroyCb"></a><p class="title"><b>Example 7.23. Ewl Window destroy callback</b></p><pre class="programlisting">
void win_del_cb(Ewl_Widget *w, void *event, void *data) {
    ewl_widget_destroy(w);
    ewl_main_quit();
}
 </pre></div><p>
</p><p>
Some of the other operations involving the Ewl_Window object are:
</p><div class="itemizedlist"><ul type="bullet" compact><li style="list-style-type: disc"><p><tt class="function">char *ewl_window_title_get(Ewl_Window *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">char *ewl_window_name_get(Ewl_Window *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">char *ewl_window_class_get(Ewl_Window *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">void ewl_window_borderless_set(Ewl_Window *)</tt></p></li><li style="list-style-type: disc"><p><tt class="function">void ewl_window_move(Ewl_Window *, int x, int y)</tt></p></li><li style="list-style-type: disc"><p>
  <tt class="function">void ewl_window_position_get(Ewl_Window *, int *x, int *y)</tt>
 </p></li></ul></div><p>
The first three calls are pretty self explanatory. The <tt class="function">ewl_window_borderless_set()</tt>
can be used to tell the window manager not to display any decoration around the window, this includes
the border and the title bar. The function <tt class="function">ewl_window_move()</tt> is used to
position the window to a specific place on the desktop, indexed from the top
left corner. There is also a <tt class="function">ewl_window_position_get()</tt> which will return the position 
of the window on the desktop.
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ch-Contributing"></a>Chapter 8. Contributing</h2></div></div><div></div></div><p>
If you found this document useful, but lacking in some fashion, please consider
contributing back to the document itself. This document is available under an
open license and any submissions are greatly appreciated. Any submissions
can be sent to 
<tt class="literal"><a href="mailto:zero@perplexity.org" target="_top">zero@perplexity.org</a></tt>.
</p><p>
Note that any contributions to this document need to be licensed under
the Creative Commons NonCommercial-ShareAlike 1.0 License, which is what
this document uses.</p><p>
If you wish to contribute to the EWL or another part of the EFL, take a look at the 
<tt class="literal"><a href="http://www.enlightenment.org" target="_top">www.enlightenment.org</a></tt>
website. All the information on accessing CVS and the mailing lists can be found there.
</p><p>Thank you.</p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="apx-ewl_media_player_example"></a>Appendix A. EWL Media Player Example</h2></div></div><div></div></div><p>
</p><div class="example"><a name="id2517181"></a><p class="title"><b>Example A.1. Ewl Media Player</b></p><pre class="programlisting">
#include &lt;Ewl.h&gt;

static Ewl_Widget *video;
static Ewl_Widget *fd_win;
static Ewl_Widget *seeker;

typedef struct {
    char *name;
    Ewl_Callback_Function func;
} Control;

void del_cb(Ewl_Widget *w, void *event, void *data) {
    ewl_widget_hide(w);
    ewl_widget_destroy(w);
    ewl_main_quit();
}

void play_cb(Ewl_Widget *w, void *event, void *data ) {
    ewl_media_play_set(EWL_MEDIA(video), 1);
}

void stop_cb(Ewl_Widget *w, void *event, void *data ) {
    ewl_media_play_set(EWL_MEDIA(video), 0);
}

void ff_cb(Ewl_Widget *w, void *event, void *data ) {
    double p = ewl_media_position_get(EWL_MEDIA(video));
    ewl_media_position_set(EWL_MEDIA(video), p + 10.0);
}

void rew_cb(Ewl_Widget *w, void *event, void *data ) {
    double p = ewl_media_position_get(EWL_MEDIA(video));
    ewl_media_position_set(EWL_MEDIA(video), p - 10.0);
}

void video_realize_cb(Ewl_Widget *w, void *event, void *data) {
    double len = ewl_media_length_get(EWL_MEDIA(video));
    ewl_seeker_range_set(EWL_SEEKER(seeker), len);
}

void video_change_cb(Ewl_Widget *w, void *event, void *data) {
    char buf[512];
    int h, m;
    double s;
    Ewl_Text *t = (Ewl_Text *)data;
    double pos = ewl_media_position_get(EWL_MEDIA(video));

    ewl_seeker_value_set(EWL_SEEKER(seeker), pos);
    ewl_media_position_time_get(EWL_MEDIA(video), &amp;h, &amp;m, &amp;s);
    snprintf(buf, sizeof(buf), "%02i:%02i:%02.0f", h, m, s);
    ewl_text_text_set(t, buf);
}

void seeker_move_cb(Ewl_Widget *w, void *event, void *data) {
    double val = ewl_seeker_value_get(EWL_SEEKER(seeker));
    ewl_media_position_set(EWL_MEDIA(video), val);
}

void fd_win_del_cb(Ewl_Widget *w, void *event, void *data) {
    ewl_widget_hide(w);
    ewl_widget_destroy(w);
}

void open_file_cb(Ewl_Widget *w, void *event, void *data) {
    char *file = NULL;

    ewl_widget_hide(fd_win);
    file = (char *)event;
    if (file) 
        ewl_media_media_set(EWL_MEDIA(video), file);
}

void open_cb(Ewl_Widget *w, void *event, void *data ) {
    Ewl_Widget *fd = NULL;

    if (fd_win) {
        ewl_widget_show(fd_win);
        return;
    }

    fd_win = ewl_window_new();
    ewl_window_title_set(EWL_WINDOW(fd_win), "EWL Media Open");
    ewl_window_class_set(EWL_WINDOW(fd_win), "EWL_Media_Open");
    ewl_window_name_set(EWL_WINDOW(fd_win), "EWL_Media_Open");
    ewl_callback_append(fd_win, EWL_CALLBACK_DELETE_WINDOW, 
                                            fd_win_del_cb, NULL);
    ewl_widget_show(fd_win);

    fd = ewl_filedialog_new(EWL_FILEDIALOG_TYPE_OPEN);
    ewl_container_child_append(EWL_CONTAINER(fd_win), fd);
    ewl_callback_append(fd, EWL_CALLBACK_VALUE_CHANGED, open_file_cb, NULL);
    ewl_widget_show(fd);
}

void key_up_cb(Ewl_Widget *w, void *event, void *data) {
    Ewl_Event_Key_Up *e = (Ewl_Event_Key_Up *)event;

    if (!strcmp(e-&gt;keyname, "p"))
        ewl_media_play_set(EWL_MEDIA(video), 1);

    else if (!strcmp(e-&gt;keyname, "s"))
        ewl_media_play_set(EWL_MEDIA(video), 0);

    else if (!strcmp(e-&gt;keyname, "q"))
        del_cb(w, event, data);
}

int main(int argc, char ** argv) {
    Ewl_Widget *win = NULL, *o = NULL, *b = NULL;
    Ewl_Widget *controls = NULL, *time = NULL;
    char * file = NULL;

    if (!ewl_init(&amp;argc, argv)) {
        printf("Can't init ewl");
        return 1;
    }

    if (argc &gt; 1)
        file = argv[1];

    win = ewl_window_new();
    ewl_window_title_set(EWL_WINDOW(win), "EWL Media test");
    ewl_window_name_set(EWL_WINDOW(win), "EWL_Media_test");
    ewl_window_class_set(EWL_WINDOW(win), "EWL_Media_test");
    ewl_callback_append(win, EWL_CALLBACK_DELETE_WINDOW, del_cb, NULL);
    ewl_callback_append(win, EWL_CALLBACK_KEY_UP, key_up_cb, NULL);
    ewl_object_size_request(EWL_OBJECT(win), 320, 280);
    ewl_object_fill_policy_set(EWL_OBJECT(win), EWL_FLAG_FILL_ALL);
    ewl_widget_show(win);

    /* box to contain everything */
    b = ewl_vbox_new();
    ewl_container_child_append(EWL_CONTAINER(win), b);
    ewl_object_fill_policy_set(EWL_OBJECT(b), EWL_FLAG_FILL_ALL);
    ewl_widget_show(b);

    /* create the time widget now so we can pass it to the video as data */
    time = ewl_text_new("00:00:00");

    /* the video */
    video = ewl_media_new(file);
    ewl_container_child_append(EWL_CONTAINER(b), video);
    ewl_object_fill_policy_set(EWL_OBJECT(video), EWL_FLAG_FILL_ALL);
    ewl_callback_append(video, EWL_CALLBACK_REALIZE, video_realize_cb, NULL);
    ewl_callback_append(video, EWL_CALLBACK_VALUE_CHANGED, video_change_cb, time);
    ewl_widget_show(video);

    /* box to contain contols and scrollers */
    controls = ewl_vbox_new();
    ewl_object_fill_policy_set(EWL_OBJECT(controls), 
                EWL_FLAG_FILL_VSHRINK | EWL_FLAG_FILL_HFILL);
    ewl_container_child_append(EWL_CONTAINER(b), controls);
    ewl_widget_show(controls);

    /* hold he controls */
    b = ewl_hbox_new();
    ewl_container_child_append(EWL_CONTAINER(controls), b);
    ewl_widget_show(b);

    {
        Control controls [] = {
            { "play", play_cb },
            { "stop", stop_cb },
            { "rewind", rew_cb },
            { "fast forward", ff_cb },
            { "open", open_cb },
            { NULL, NULL }
        };
        int i;

        for(i = 0; controls[i].name != NULL; i++) {
            o = ewl_button_with_stock_new(controls[i].name);
            ewl_container_child_append(EWL_CONTAINER(b), o);
            ewl_callback_append(o, EWL_CALLBACK_CLICKED, 
                                    controls[i].func, NULL);
            ewl_widget_show(o);
        }
    }

    b = ewl_hbox_new();
    ewl_container_child_append(EWL_CONTAINER(controls), b);
    ewl_widget_show(b);

    /* the video seeker */
    seeker = ewl_seeker_new(EWL_ORIENTATION_HORIZONTAL);
    ewl_container_child_append(EWL_CONTAINER(b), seeker);
    ewl_object_fill_policy_set(EWL_OBJECT(seeker), 
                        EWL_FLAG_FILL_VSHRINK | EWL_FLAG_FILL_HFILL);
    ewl_seeker_value_set(EWL_SEEKER(seeker), 0.0);
    ewl_seeker_range_set(EWL_SEEKER(seeker), 0.0);
    ewl_seeker_step_set(EWL_SEEKER(seeker), 1.0);
    ewl_callback_append(seeker, EWL_CALLBACK_VALUE_CHANGED, seeker_move_cb, NULL);
    ewl_widget_show(seeker);

    /* the time text spot */
    ewl_container_child_append(EWL_CONTAINER(b), time);
    ewl_object_insets_set(EWL_OBJECT(time), 0, 3, 0, 0);
    ewl_object_fill_policy_set(EWL_OBJECT(time), EWL_FLAG_FILL_SHRINK);
    ewl_widget_show(time);

    ewl_main();
    return 0;
}
</pre></div><p>
</p></div></div></body></html>
